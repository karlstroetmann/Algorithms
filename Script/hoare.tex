\chapter{Der Hoare-Kalkül} 
In diesem Kapitel stellen wir den \emph{Hoare-Kalkül} vor, mit dessen Hilfe sich die
Korrektheit nicht-rekursiver Programme zeigen lässt.
Dieses Hilfsmittel ist der \emph{Hoare-Kalkül}, der 1969 von C.~A.~R.~Hoare 
\cite{hoare:69} vorgestellt wurde.

\section{Vor- und Nachbedingungen}
Grundlage des Hoare-Kalkül sind sogenannte \emph{Vor-} und \emph{Nach-Bedingungen}.  Ist
\texttt{P} ein Programm-Fragment und sind $F$ und $G$ logische Formeln, so sagen wir, dass
$F$ eine Vor-Bedingung und $G$ eine Nach-Bedingung für das Programm-Fragment \texttt{P}
ist, falls folgendes gilt: Wird das Programm-Fragment \texttt{P} in einer Situation
ausgeführt, in der vor der Ausführung von \texttt{P} die Formel $F$ gilt, so gilt nach der
Ausführung von $P$ die Formel $G$.  Dies schreiben wir als
\[ \hoare{F}{P}{G} \]
und sagen, dass \emph{$P$ die Spezifikation ``wenn vorher $F$, dann nachher $G$''} erfüllt.
Die Spezifikation 
\[ \hoare{F}{P}{G} \]
wird in der Literatur  als \emph{Hoare-Tripel} 
bezeichnet, denn diese Notation wurde von Sir Charles Antony Richard Hoare (geb.~1934) \cite{hoare:69}
eingeführt.
\vspace*{0.3cm}

\noindent
\textbf{Beispiele}:
\begin{enumerate}
\item Das Programm-Fragment, das nur aus der Zuweisung  ``\texttt{x := 1;}'' besteht,
      erfüllt trivialerweise die Spezifikation
      \[ \hoare{\mathtt{true}}{x := 1;}{x = 1}. \]
      Hier ist die Vorbedingung die triviale Bedingung \texttt{true}, denn
      die Nachbedingung $x = 1$ ist in jedem Fall richtig.
\item Das Programm-Fragment, das aus der Zuweisung  ``\texttt{x = x + 1;}'' besteht,
      erfüllt die Spezifikation
      \[ \hoare{x=1}{x := x + 1;}{x=2}. \]
      Hier ist die $x = 1$ die Vorbedingung und die Nachbedingung ist $x = 2$.
\item Wir betrachten wieder as Programm-Fragment  ``\texttt{x = x + 1;}'' und wählen als
      Vorbedingung diesmal die Formel $\textsl{prim}(x)$, die ausdrückt, dass $x$ eine
      Primzahl ist.  Das entsprechende Hoare-Tripel ist diesmal
      \[ \hoare{\textsl{prim}(x)}{x := x + 1;}{\textsl{prim}(x-1)}. \]
      Auf den ersten Blick sieht das seltsam aus.  Viele Studenten denken zunächst, dass
      dieses Hoare-Tripel die Form
      \[ \hoare{\textsl{prim}(x)}{x := x + 1;}{\textsl{prim}(x+1)} \] 
      haben müßte.  Das diese letzte Zeile falsch ist, können wir sehen, wenn wir für $x$
      den Wert $2$ einsetzen, dann dann ist die Vorbedingung $\textsl{prim}(2)$ erfüllt.
      Nach der Ausführung der Zuweisung hat $x$ den Wert $3$ und
      \\[0.2cm]
      \hspace*{1.3cm}
      $x - 1 = 3 - 1 = 2$
      \\[0.2cm]
      ist immer
      noch eine Primzahl, aber offenbar ist
      \\[0.2cm]
      \hspace*{1.3cm}
      $x + 1 = 3 + 1 = 4 = 2 \cdot 2$ 
      \\[0.2cm]
      keine Primzahl!
\end{enumerate}
Wir überlegen uns nun, wie sich die verschiedenen Teile eines Programms mit Hilfe von
Hoare-Tripeln spezifizieren lassen.  Die elementarsten Bestandteile eines Programms sind
die Zuweisungen.  Wir fangen daher mit der Analyse der Zuweisungen an.
 
\subsection{Spezifikation von Zuweisungen}
Wir wollen das letzte Beispiel verallgemeinern und untersuchen, wie sich die Vor- und
Nachbedingungen bei einer Zuweisung der Form 
\[ \texttt{x := h(x);} \]
zueinander verhalten.  Konkret stellen wir uns die Frage, wie wir die Nachbedingung $G$
aus einer bereits bekannten Vorbedingung $F$ berechnen können.  Zur Vereinfachung nehmen
wir an, dass die Funktion $h$ umkehrbar ist, dass es also eine Umkehr-Funktion $h^{-1}$ gibt,
so dass für alle $x$ gilt 
\[ h^{-1}\bigl(h(x)\bigr) = x \quad \mathtt{und} \quad h\bigl(h^{-1}(x)\bigr) = x. \]
Um die Sache konkret zu machen, betrachten wir ein Beispiel.  Die Zuweisung 
\[ \texttt{x := x + 1;} \]
können wir in der Form 
\[ \texttt{x := h(x);} \]
schreiben. Die Funktion $h$ hat dann die Form 
\[ h(x) = x + 1 \]
und die Umkehr-Funktion  ist offenbar 
\[ h^{-1}(x) = x - 1, \]
denn um die Addition von 1 rückgängig zu machen, müssen wir 1 subtrahieren.
Mit der Umkehr-Funktion lässt sich nun die Nachbedingung der Zuweisung ``\texttt{x := h(x);}'' aus der
Vorbedingung berechnen, denn es gilt
\[ \hoare{F}{x := h(x);}{F\sigma} \quad \mathrm{mit} \quad \sigma = \bigl[x \mapsto h^{-1}(x)\bigr]. \]
Hier bezeichnet $F\sigma$ die Anwendung der Substitution
$\sigma$ auf die Formel $F$: $F\sigma$ ist
dadurch definiert, dass alle Auftreten der Variable $x$ durch den Term $h^{-1}(x)$ ersetzt
werden.  Um zu verstehen warum die Nachbedingung sich gerade so berechnet, greifen wir das
Beispiel $\texttt{x := x + 1}$ wieder auf und wählen als Vorbedingung $F$ die Formel 
$x = 7$.  Wegen $h^{-1}(x) = x - 1$ hat die Substitution $\sigma$ die Form
$\sigma = [ x \mapsto x - 1 ]$ und damit hat $F\sigma$ die Form 
\[ (x = 7)[x \mapsto x - 1] \;\equiv\; (x - 1 = 7). \]
(An dieser Stelle habe ich das Zeichen ``$\equiv$'' benutzt, um die syntaktische Gleichheit
von Formeln ausdrücken zu können, die ihrerseits das Gleichheitszeichen ``$=$''
enthalten.)  Damit lautet die Spezifikation also 
\[ \hoare{x = 7}{x := x + 1;}{x - 1 = 7}. \]
Wegen der Äquivalenz $x - 1 = 7 \leftrightarrow x = 8$ ist das logisch dasselbe wie
\[ \hoare{x = 7}{x := x + 1;}{x = 8} \]
und diese Spezifikation ist offenbar korrekt, denn wenn $x$ vor der Zuweisung
``\texttt{x := x + 1;}'' den Wert $7$ hat, dann hat $x$ hinterher den Wert 8.

Wir überlegen uns nun, warum das Hoare-Tripel
\[ \hoare{F}{x := h(x);}{F\sigma} \quad \mathrm{mit} \quad \sigma = \bigl[x \mapsto h^{-1}(x)\bigr] \]
korrekt ist: Bevor die Zuweisung ``x \texttt{:=} h(x);'' durchgeführt wird,
hat die Variable $x$ einen festen Wert, den wir mit $x_0$ bezeichnen.  Für diesen
Wert $x_0$ gilt die Formel $F$, es gilt also vor der Zuweisung $F[x \mapsto x_0]$.
In der Formel $F[x \mapsto x_0]$ tritt die Variable $x$ nicht mehr auf, denn wir haben
diese Variable ja durch den Wert $x_0$ ersetzt.  Damit bleibt die Formel
\[ F[x \mapsto x_0] \]
auch nach der Zuweisung  ``\texttt{x = h(x);}'' gültig.  Nach der Zuweisung
hat die Variable $x$ aber den Wert $x = h(x_0)$.  Diese Gleichung lösen wir nach $x_0$
auf und finden 
\[ x_0 = h^{-1}(x). \]
Damit gilt also nach der Zuweisung die Formel 
\[ F[x \mapsto x_0] \equiv  F[x \mapsto h^{-1}(x)]. \]
Betrachten wir zum Abschluss dieser Diskussion ein weiteres Beispiel.  Es sei \textsl{prim}
ein einstelliges Prädikat, so dass $\textsl{prim}(x)$ genau dann wahr ist, wenn $x$ eine
Primzahlen ist.
Dann gilt 
\[ \hoare{\texttt{prim}(x)}{x := x + 1;}{\texttt{prim}(x-1)}. \]
Anschaulich ist das klar: Wenn die Zahl $x$ eine Primzahl ist und $x$ um den Wert Eins
inkrementiert wird, dann ist hinterher die Zahl $x-1$ eine Primzahl.

\paragraph{Andere Formen von Zuweisungen}
Nicht immer haben Zuweisungen die Form ``\texttt{x = h(x);}'' mit einer invertierbaren
Funktion $h$.  Oft wird einer Variable $x$ eine Konstante $c$ zugewiesen.  Falls die
Variable $x$ in der Formel $F$ nicht vorkommt, gilt dann offenbar
\[ \hoare{F}{x := c;}{F \wedge x = c}. \]
Die Formel $F$ kann hier dafür benutzt werden, um den Wert anderer Variablen einzugrenzen.

\paragraph{Allgemeine Zuweisungs-Regel}
In der Literatur findet sich die folgende Regel für Zuweisungen
\[ \hoare{F[x \mapsto t]}{x := t;}{F}. \]
Hierbei ist $t$ ein beliebiger Term, der die Variable $x$ enthalten kann.  Diese Regel ist
wie folgt zu lesen: 
\\[0.2cm]
\hspace*{1.3cm}
\begin{minipage}[c]{0.8\linewidth}
``\emph{Gilt die Formel $F(t)$ und weisen wir der Variablen $x$ den
        Wert $t$ zu, so gilt danach die Formel $F(x)$.}'' 
\end{minipage}
\\[0.2cm]
Die Korrektheit dieser Regel ist offensichtlich,
aber in der vorliegenden Form ist die Regel nicht sehr nützlich, denn um Sie anwenden zu
können, muss die Vorbedingung erst auf die Form $F(t)$, also $F[x \mapsto t]$ gebracht werden. 

\subsection{Die Abschwächungs-Regel}
Erfüllt ein Programm-Fragment $P$ die Spezifikation 
\[ \hoare{F}{P}{G} \]
und folgt aus der Formel $G$ die Formel $H$, gilt also
\[ G \rightarrow H, \]
so erfüllt das Programm-Fragment $P$ erst recht die Spezifikation 
\[ \hoare{F}{P}{H}, \]
denn wenn nach Ausführung von $P$ die Formel $G$ gilt, dann gilt die Formel $H$ erst recht.
Wir fassen diesen Tatbestand in einer \emph{Verifikations-Regel} zusammen:
\\[-0.2cm]
\[ \bruch{\quad \hoare{F}{P}{G}, \qquad G \rightarrow H \quad}{\hoare{F}{P}{H}}. \]
Über dem Bruchstrich stehen hier die beiden \emph{Prämissen} und unter dem Bruchstrich steht
die \emph{Konklusion}.  Die Konklusion und die erste Prämisse sind 
Hoare-Tripel, die zweite Prämisse  ist eine ganz normale logische Formel.
Falls die Prämissen wahr sind, so gilt auch die Konklusion.

\subsection{Zusammengesetze Anweisungen}
Haben die Programm-Fragmente $\texttt{P}$ und $\texttt{Q}$ die Spezifikationen
\[ \hoare{F_1}{P}{G_1}  \quad \mathrm{und} \quad \hoare{F_2}{Q}{G_2}  \]
und folgt die Vorbedingung $F_2$ aus der Nach-Bedingung $G_1$, dann gilt für die 
Zusammensetzung $\texttt{P;Q}$ von $\texttt{P}$ und $\texttt{Q}$ die
Spezifikation 
\[ \hoare{F_1}{P;Q}{G_2} \]
denn wenn anfangs $F_1$ gilt und zunächst $P$ ausgeführt wird, dann gilt danach $G_1$.
Aus $G_1$ folgt $F_2$ und wenn das Programm-Fragment $Q$ in der Situation $F_2$ ausgeführt
wird, dann wissen wir, dass danach $G_2$ gilt.
Wir fassen diese Überlegungen in einer Verifikations-Regel zusammen:
\\[-0.2cm]
\[ \bruch{\quad\hoare{F_1}{P}{G_1}, \qquad G_1 \rightarrow F_2, \qquad \hoare{F_2}{Q}{G_2}\quad}{
    \hoare{F_1}{P;Q}{G_2}} \]
Gelegentlich ist es bei dieser Verifikations-Regel so, 
dass die Formeln $G_1$ und $F_2$  identisch sind.  In diesem Fall ist die Implikation
$G_1 \rightarrow F_2$ trivial und kann weggelassen werden.  Dann nimmt die obige
Verifikations-Regel die folgende vereinfachte Form an:
\\[-0.2cm]
\[ \bruch{\quad\hoare{F_1}{P}{G_1}, \qquad \hoare{G_1}{Q}{G_2}\quad}{ \hoare{F_1}{P;Q}{G_2}} \]

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    x := x - y;
    y := y + x;
    x := y - x;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine trickreiche Implementierung zur Vertauschung zweier Werte.}
\label{fig:swap}
\end{figure}

\vspace*{0.3cm}

\noindent
\textbf{Beispiel:}
Wir betrachten  das in
Abbildung \ref{fig:swap} gezeigte Programm-Fragment.  Wir analysieren nun die Wirkung
dieses Programm-Fragments.  Dazu starten wir unsere Analyse mit der Vorbedingung
\[ \texttt{x} = a \wedge \texttt{y} = b. \]
Hier sind $a$ und $b$ zwei Variablen, in denen wir uns die Startwerte von \texttt{x} und
\texttt{y} merken.  Die erste Zuweisung liefert das Hoare-Tripel
\[ \hoare{\texttt{x} = a \wedge \texttt{y} = b}{x := x - y;}{(\texttt{x} = a \wedge \texttt{y} = b)\sigma} 
   \quad \mathrm{mit} \quad \sigma = [x \mapsto x + y],
\]
denn $x \mapsto x + y$ ist die Umkehr-Funktion von $x \mapsto x - y$.  Führen wir die Substitution
aus, so erhalten wir
\begin{equation}
  \label{eq:swap1}
 \hoare{\texttt{x} = a \wedge \texttt{y} = b}{x := x - y;}{\texttt{x + y} = a \wedge \texttt{y} = b}.   
\end{equation}
Die zweite Zuweisung liefert das Hoare-Tripel
\[ \hoare{\texttt{x + y} = a \wedge \texttt{y} = b}{y := y + x;}{(\texttt{x + y} = a \wedge \texttt{y} = b)\sigma} 
   \quad \mathrm{mit} \quad \sigma = [y \mapsto y - x],
\]
denn $y \mapsto y - x$ ist die Umkehr-Funktion der Funktion $y \mapsto y + x$.
Ausführung der Substitution liefert diesmal
\[ \hoare{\texttt{x + y} = a \wedge \texttt{y} = b}{y := y + x;}{
          \texttt{x + y - x} = a \wedge \texttt{y - x} = b}.
\]
Vereinfachen wir noch die Nachbedingung, so haben wir 
\begin{equation}
  \label{eq:swap2}
 \hoare{\texttt{x + y} = a \wedge \texttt{y} = b}{y := y + x;}{ \texttt{y} = a \wedge \texttt{y - x} = b}  
\end{equation}
gezeigt. Jetzt betrachten wir die letzte Zuweisung.  Wir erhalten
\[ \hoare{\texttt{y} = a \wedge \texttt{y - x} = b}{x := y - x;}{
          (\texttt{y} = a \wedge \texttt{y - x} = b)\sigma} 
   \quad \mathrm{mit} \quad \sigma = [x \mapsto y - x],
\]
denn $x \mapsto y - x$ ist die Umkehr-Funktion der Funktion $x \mapsto y - x$.
Führen wir die Substitution aus, so ergibt sich
\[ \hoare{\texttt{y} = a \wedge \texttt{y - x} = b}{x := y - x;}{
          \texttt{y} = a \wedge \texttt{y - (y - x)} = b} 
\]
Vereinfachung der Nachbedingung liefert schließlich
\begin{equation}
  \label{eq:swap3}
  \hoare{\texttt{y} = a \wedge \texttt{y - x} = b}{x := y - x;}{ \texttt{y} = a \wedge \texttt{x} = b}.   
\end{equation}
Fassen wir die Hoare-Tripel (\ref{eq:swap1}), (\ref{eq:swap2}) und (\ref{eq:swap3})
zusammen, so erhalten wir
\begin{equation}
  \label{eq:swap}
  \hoare{\texttt{x} = a \wedge \texttt{y} = b}{x := x + y; y := y + x; x := y - x;}{ 
         \texttt{y} = a \wedge \texttt{x} = b}.   
\end{equation}
Das Hoare-Tripel (\ref{eq:swap}) zeigt, dass das Programm-Fragment aus Abbildung
\ref{fig:swap} die Werte der Variablen $x$ und $y$ vertauscht: Wenn vor der Ausführung
dieses Programm-Fragments $x$ den Wert $a$ und $y$ den Wert $b$ hat, dann ist es nachher
gerade umgekehrt: $y$ hat den Wert $a$ und $x$ hat den Wert $b$.  Der in dem in Abbildung
\ref{fig:swap} gezeigte Trick wurde früher 
benutzt, um  Werte zu vertauschen, denn bei der oben angegebenen
Implementierung wird keine Hilfsvariable benötigt, so dass wir bei der Umsetzung dieses
Programms in Assembler mit weniger Registern auskommen.

\subsection{Alternativ-Anweisungen}
Um die Wirkung einer Alternativ-Anweisung der Form 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{if ($B$)  P  else  Q }
\\[0.2cm]
zu berechnen, nehmen wir an, dass vor der Ausführung dieser Anweisung die Vorbedingung
$F$ gilt.  Dann müssen wir die Wirkung der Programm-Fragmente $P$ und $Q$ analysieren.
Wenn $P$ ausgeführt wird, können wir neben $F$ noch die Bedingung $B$ annehmen, während
wir für die Ausführung von $Q$ die zusätzliche Bedingung $\neg B$ annehmen können.
Das liefert die folgende Verifikations-Regel:
\begin{equation}
  \label{eq:hoareIf}
  \bruch{\quad\hoare{F \wedge B}{P}{G}, \qquad \hoare{F \wedge \neg B}{Q}{G}\quad}{
              \hoare{F}{if ($B$) P else Q}{G}}  
\end{equation}
In der vorliegenden Form ist die Regel oft nicht unmittelbar anwendbar, denn die Analyse
der Programm-Fragmente \texttt{P} und \texttt{Q} liefert zunächst Hoare-Tripel der Form
\begin{equation}
  \label{eq:abschwaechung1}
 \hoare{F \wedge B}{P}{G_1} \qquad \mathrm{und} \qquad \hoare{F \wedge \neg B}{Q}{G_2},   
\end{equation}
wobei $G_1$ und $G_2$ zunächst verschieden sind.   Um die obige Regel dann trotzdem
anwenden zu können suchen wir eine Formel $G$, die sowohl aus $G_1$ als auch aus $G_2$
folgt, für die also
\[ G_1 \rightarrow G \qquad \mathrm{und} \qquad G_2 \rightarrow G \]
gilt.  Haben wir eine solche Formel $G$ gefunden, dann können wir mit Hilfe der
Abschwächungs-Regel (\ref{eq:abschwaechung1})
auf die Gültigkeit von
\[ \hoare{F \wedge B}{P}{G} \qquad \mathrm{und} \qquad \hoare{F \wedge \neg B}{Q}{G},    \] 
schließen und damit haben wir genau die Prämissen, um die 
Verifikations-Regel (\ref{eq:hoareIf}) anwenden zu können.
\vspace*{0.3cm}

\noindent
\textbf{Beispiel}:  Wir analysieren das folgende Programm-Fragment:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{if (x < y) \{ z := x; \} else \{ z := y; \}}
\\[0.2cm]
Wir starten mit der Vorbedingung 
\[ F = \bigl(\texttt{x} = a \wedge \texttt{y} = b\bigr) \]
und wollen zeigen, dass nach Ausführung der obigen Alternativ-Anweisung die Nachbedingung
\[ G = \bigl(z = \textsl{min}(a, b)\bigr) \]
gültig ist.  Für die erste Zuweisung erhalten wir das Hoare-Tripel 
\[ \hoare{\texttt{x} = a \wedge \texttt{y} = b \wedge \texttt{x} < \texttt{y}}{z := x;}{
          \texttt{x} = a \wedge \texttt{y} = b \wedge \texttt{x} < \texttt{y} \wedge 
          \texttt{z} = \texttt{x}}.
\]
Analog erhalten wir für die zweite Zuweisung
\[ \hoare{\texttt{x} = a \wedge \texttt{y} = b \wedge \texttt{x} \geq \texttt{y}}{z := y;}{
          \texttt{x} = a \wedge \texttt{y} = b \wedge \texttt{x} \geq \texttt{y} \wedge
          \texttt{z} = \texttt{y}}.
\]
Nun gilt einerseits
\[ \texttt{x} = a \wedge \texttt{y} = b \wedge \texttt{x} < \texttt{y} \wedge \texttt{z} = \texttt{x} 
   \rightarrow \texttt{z} = \min(a,b)
\]
und andererseits
\[ \texttt{x} = a \wedge \texttt{y} = b \wedge \texttt{x} \geq \texttt{y} \wedge \texttt{z} = \texttt{y} 
   \rightarrow \texttt{z} = \min(a,b).
\]
Durch Anwendung der Abschwächungs-Regel sehen wir also, dass
\begin{eqnarray*}
\hoare{\texttt{x} = a \wedge \texttt{y} = b \wedge \texttt{x} < \texttt{y}}{z := x;}{
       \texttt{z} = \min(a,b)} & & \mathrm{und} \\
\hoare{\texttt{x} = a \wedge \texttt{y} = b \wedge \texttt{x} \geq \texttt{y}}{z := y;}{
          \texttt{z} = \min(a,b)}
\end{eqnarray*}
gilt. Durch Anwendung der Verifikations-Regel für die Alternativ-Anweisung folgt dann, dass
\[ \hoare{\texttt{x} = a \wedge \texttt{y} = b}{if (x < y) \{ z := x; \} else \{ z := y; \}}{
          \texttt{z} = \min(a,b)}
\]
gilt und damit ist nachgewiesen, dass das entsprechende Programm-Fragment
das Minimum der Zahlen $a$ und $b$ berechnet.

\subsection{Schleifen}
Als letztes analysieren wir die Wirkung einer Schleife der Form 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{while ($B$) \{ P \}} 
\\[0.2cm]
Der entscheidende Punkt ist hier, dass die Nachbedingung für den $n$-ten
Schleifen-Durchlauf gleichzeitig die Vorbedingung für den $(n\!+\!1)$-ten Schleifen-Durchlauf
sein muss.  Das führt zu der Forderung, dass Vor- und Nachbedingung für den
Schleifen-Rumpf im wesentlichen identisch sein müssen.  Diese Bedingung trägt daher den
Namen \emph{Schleifen-Invariante}.  Im Detail hat die Verifikations-Regel die folgende Form:
\[ 
  \bruch{\hoare{I \wedge B}{P}{I}}{\quad \hoare{I}{while ($B$) \{ P \}}{I \wedge \neg B}\quad}
\]
Die Prämisse dieser Regel besagt, dass bei der Ausführung von $P$ die Invariante $I$
wahr bleiben muss, wobei wir als zusätzliche Vorbedingung noch die Formel $B$ annehmen
dürfen, denn \texttt{P} wird  nur ausgeführt, wenn $B$ wahr ist.
Die Konklusion besagt, dass wenn vor der Ausführung der Schleife die Invariante $I$ gültig
ist, dann gilt sie hinterher immer noch.  Anschaulich ist das klar, denn jede einzelne
Ausführung des Schleifen-Rumpfs \texttt{P} hat die Invariante $I$ ja erhalten.
Zusätzlich wissen wir noch, dass nach Beendigung der Schleife die Bedingung $\neg B$ gilt,
denn wenn $B$ gelten würde, würde die Schleife weiterlaufen.


\section{Der Euklid'sche Algorithmus}
Wir zeigen nun, wie die im letzten Abschnitt präsentierten Regeln verwendet werden können,
um die Korrektheit eines nicht-trivialen Programms zu zeigen.  Unser Ziel ist es, die
Korrektheit der in Abbildung \ref{fig:ggt.c} auf Seite \pageref{fig:ggt.c} gezeigten
\texttt{C}-Funktion nachzuweisen.  Diese Funktion implementiert den Euklid'schen
Algorithmus zur Berechnung des größten gemeinsamen Teilers zweier positiver natürlicher
Zahlen.  Bevor wir für diesen Algorithmus den Nachweis der Korrektheit
erbringen, erinnern wir daran, dass wir in der Mathematik-Vorlesung gezeigt haben dass
\[ \texttt{ggt}(x + y, y) = \texttt{ggt}(x,y) \quad \mbox{für alle $x, y \in \mathbb{N}$} \]  
gilt.


\subsection{Nachweis der Korrektheit des Euklid'schen Algorithmus}
Wir haben nun alles Material zusammen, um die Korrektheit des Euklid'schen Algorithmus,
der in Abbildung
\ref{fig:ggt.c} gezeigt wird, nachweisen zu können.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    ggt := procedure(x, y) {
        while (x != y) {
            if (x < y) {
                y := y - x;
            } else {
                x := x - y;
            }
        }
        return x;
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Der Euklid'sche Algorithmus zur Berechnung des größten gemeinsamen Teilers.}
\label{fig:ggt.c}
\end{figure}

Wir beginnen den Nachweis der Korrektheit damit, dass wir die Invariante formulieren, die
von der \texttt{while}-Schleife erhalten wird.  Wir definieren
\[ I := \bigl(x > 0 \wedge y > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b) \bigr).
\]
Hierbei haben wir die Startwerte von $x$ und $y$ mit $a$ und $b$ bezeichnet.
Um die Invariante $I$ zu Beginn sicherzustellen, ist zu fordern, dass die Funktion
\texttt{ggt} nur mit positiven ganzen Zahlen aufgerufen wird.  Bezeichnen wir diese Zahlen
mit $a$ und $b$, so gilt die Invariante offenbar zu Beginn, denn aus $x = a$ und $y = b$
folgt sofort $\texttt{ggt}(x,y) = \texttt{ggt}(a,b)$.

Um nachzuweisen, dass die Invariante $I$ in der Schleife erhalten bleibt, stellen wir für
die beiden Alternativen der \texttt{if}-Abfrage jeweils ein Hoare-Tripel auf.  Für die
erste Alternative wissen wir, dass
\[
  \hoare{I \wedge x \not= y \wedge x < y}{y := y - x;}{(I \wedge x \not= y \wedge x < y)\sigma} 
  \quad \mathrm{mit} \quad \sigma = [y \mapsto y + x]
\]
gilt.  Die Bedingung $x \not= y$ ist dabei die Bedingung der \texttt{while}-Schleife
und die Bedingung $x < y$ ist die Bedingung der \texttt{if}-Abfrage.
Wir formen den Ausdruck $(I \wedge x \not= y \wedge x < y)\sigma$ um:
\begin{eqnarray*}
 &                 & \bigl(I \wedge x \not= y \wedge x < y\bigr)\sigma \\
 & \leftrightarrow & \bigl(I \wedge x < y\bigr)\sigma 
                     \qquad\qquad \mbox{denn aus $x < y$ folgt $x \not= y$} \\
 & \leftrightarrow & \bigl(x > 0 \wedge y > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b) \wedge 
                     x < y\bigr)[y \mapsto y + x] \\
 & \leftrightarrow & x > 0 \wedge y + x > 0 \wedge \texttt{ggt}(x,y+x) = \texttt{ggt}(a,b)
                     \wedge x < y + x \\
 & \leftrightarrow & x > 0 \wedge y + x > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b) \wedge 0 < y
\end{eqnarray*}
Dabei haben wir bei der letzten Umformung die im letzten Abschnitt bewiesene Gleichung
\[ \texttt{ggt}(x,y+x) = \texttt{ggt}(x,y) \]
benutzt und die Ungleichung $x < y + x$ zu $0 < y$ vereinfacht.
Aus der letzten Formel folgt offenbar
\[ x > 0 \wedge y > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b). \]
Das ist aber genau unsere Invariante $I$.  Damit haben wir gezeigt, dass
\begin{equation}
  \label{eq:if1}
  \hoare{I \wedge x \not= y \wedge x < y}{y := y - x;}{I}
\end{equation}
gilt.  Nun betrachten wir die zweite Alternative der \texttt{if}-Abfrage.  Offenbar gilt
\[
  \hoare{I \wedge x \not= y \wedge x \geq y}{x := x - y;}{(I \wedge x \not= y \wedge x \geq y)\sigma} 
  \quad \mathrm{mit} \quad \sigma = [x \mapsto x + y].
\]
Wir formen den Ausdruck $(I \wedge x \not= y \wedge x \geq y)\sigma$ um:
\begin{eqnarray*}
 &   & \bigl(I \wedge x \not= y \wedge x \geq y\bigr)\sigma \\
 & \leftrightarrow & \bigl(I \wedge x > y \bigr)\sigma \\
 & \leftrightarrow & \bigl(x > 0 \wedge y > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b) \wedge 
             x > y \bigr)[x \mapsto x + y] \\
 & \leftrightarrow & x + y > 0 \wedge y > 0 \wedge \texttt{ggt}(x+y,y) = \texttt{ggt}(a,b) 
       \wedge x + y > y  \\
 & \leftrightarrow & x + y > 0 \wedge y > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b) 
       \wedge x > 0 
\end{eqnarray*}
Aus der letzten Formel folgt nun
\[ x > 0 \wedge y > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b). \]
Das ist aber wieder unsere Invariante $I$.  Also haben wir insgesamt
\begin{equation}
  \label{eq:if2}
  \hoare{I \wedge x \not= y \wedge x \geq y}{x := x - y;}{I} 
\end{equation}
gezeigt.  Aus den beiden Hoare-Tripeln (\ref{eq:if1}) und (\ref{eq:if2})
folgt nun mit der Regel für Alternativen die Gültigkeit von
\[
  \hoare{I \wedge x \not= y}{if (x < y) \{ x := x - y; \} else \{ y := y - x;\}}{I}. 
\]
Mit der Verifikations-Regel für Schleifen folgt daraus
\\[0.2cm]
\hspace*{1.3cm} 
$\{ I \}$
\\[0.1cm]
\hspace*{2.2cm}
\texttt{while (x != y ) \{} \\[0.1cm]
\hspace*{3.2cm}
         \texttt{if (x < y) \{ x := x - y; \} else \{ y := y - x;\}}
\\[0.1cm]
\hspace*{2.2cm}
\texttt{\}} \quad 
\\[0.1cm]
\hspace*{1.3cm}
$\{ I \wedge x = y \}$. 
\\[0.2cm]
Schreiben wir die Formel $I \wedge x = y$ aus, so sehen wir, dass die Nachbedingung der
\texttt{while}-Schleife durch die Formel
\[ 
   x > 0 \wedge y > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b) \wedge x = y
\]
gegeben ist.  Daraus erschließen wir die Korrektheit des Euklid'schen Algorithmus wie folgt:
\begin{eqnarray*}
&             &  x > 0 \wedge y > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b) \wedge x = y \\
& \Rightarrow & \texttt{ggt}(x,y) = \texttt{ggt}(a,b) \wedge x = y \\
& \Rightarrow & \texttt{ggt}(x,x) = \texttt{ggt}(a,b)  \\
& \Rightarrow & x = \texttt{ggt}(a,b) \qquad\qquad \mathrm{denn} \quad \texttt{ggt}(x,x) = x.
\end{eqnarray*}
Damit haben wir folgendes gezeigt:  Wenn die \texttt{while}-Schleife terminiert, dann
enthält die Variable $x$ den größten gemeinsamen Teiler der Werte $a$ und $b$, mit denen
die Variablen $x$ und $y$ initialisiert wurden.  Um den Beweis der Korrektheit
abzuschließen, müssen wir noch nachweisen, dass die \texttt{while}-Schleife tatsächlich in
jedem Fall terminiert.  Zu diesem Zweck definieren wir die Variable $s$ als
\[ s := x + y. \]
Die Variablen $x$ und $y$ sind natürliche Zahlen.  Damit ist dann auch $s$ eine natürliche Zahl.
Bei jedem Schleifendurchlauf wird die Zahl $s$ verkleinert, denn entweder wird $x$ von $s$
abgezogen oder es wird $y$ von $s$ abgezogen und die Invariante $I$ zeigt uns, dass sowohl $x$ als auch $y$
positiv sind.  Würde die Schleife unendlich lange laufen, so müßte $s$ irgendwann negative
Werte annehmen.  Da wir dies ausschließen können, muss die
Schleife abbrechen.  Damit ist die Korrektheit des Euklid'schen Algorithmus gezeigt.
\pagebreak


\noindent
\textbf{Aufgabe}:  Zeigen Sie, dass der Aufruf $\texttt{power}(x,y)$ der in Abbildung
\ref{fig:power.c} gezeigten Funktion $\texttt{power}(x,y)$ für gegebene natürliche Zahlen $x$
und $y$ die Potenz $x^y$ berechnet.
\vspace*{0.3cm}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 1.3cm,
                  xrightmargin  = 1.3cm,
                ]
    power := procedure(x, y) {
        r := 1;
        while (y > 0) {
            if (y % 2 == 1) {
                r := r * x;
            }
            x := x * x;
            y := y / 2;
        }
        return r;
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{C}-Programm zur Berechnung der Potenz.}
\label{fig:power.c}
\end{figure}

\noindent
\textbf{Hinweise}: 
\begin{enumerate}
\item Bezeichnen wir die Start-Werte von $x$ und $y$ mit $a$ und $b$,
      so ist eine mögliche Invariante für die \texttt{while}-Schleife durch die Formel 
      \\[0.2cm]
      \hspace*{1.3cm}
      $I := \bigl(r \cdot x^y = a^b\bigr)$
      \\[0.2cm]
      gegeben.  
\item Die Verifikations-Regel für die \emph{einarmige Alternative} lautet
      \\[0.2cm]
      \hspace*{1.3cm}
      $\bruch{\quad\hoare{F \wedge B}{P}{G}, \qquad F \wedge \neg B \rightarrow G\quad}{
                     \hoare{F}{if ($B$) \{ P \}}{G}}
      $
      \\[0.2cm]
      Diese Verifikations-Regel kann wie folgt interpretiert werden:
      \begin{enumerate}
      \item Falls $F$ und die Bedingung $B$ gilt, dann muss die Ausführung von 
            dem Programm-Fragment $P$ bewirken, dass nachher $G$ gilt.
      \item Falls $F$ und die Bedingung $\neg B$ gilt, dann muss daraus
            die Bedingung $G$ folgen.
      \item Unter diesen Bedingungen folgt dann aus der Vorbedingung $F$
            nach Ausführung von dem Programm-Fragment ``\texttt{if ($B$) \{ P \}}''
            die Nachbedingung $G$.
      \end{enumerate}
\end{enumerate}
\pagebreak


\noindent
\textbf{Lösung}:
Wir untersuchen Zeile für Zeile die Wirkung des Programms.
\begin{enumerate}
\item Wir bezeichnen den Anfangswert von $x$ mit $a$ und den Anfangswert von $y$ mit $b$. 
      Damit lautet die Vorbedingung der Anweisung ``\texttt{r = 1;}'' 
      \\[0.1cm]
      \hspace*{1.3cm}
      $x = a \wedge y = b$
      \\[0.1cm]
      Damit finden wir für die erste Anweisung das Hoare-Tripel
      \\[0.2cm]
      \hspace*{1.3cm}
      $\hoare{x = a \wedge y = b}{r := 1;}{x = a \wedge y = b \wedge r = 1}$. 
\item Als nächstes müssen wir zeigen, dass aus der Nachbedingung der ersten Anweisung
      die oben angegebene Invariante $I$ folgt.  Offenbar gilt
      \\[0.2cm]
      \hspace*{1.3cm}
      $x = a \wedge y = b \wedge r = 1 \rightarrow r \cdot x^y = a^b$.
\item Wir untersuchen nun die \texttt{if}-Abfrage.  Als Vorbedingung der
      \texttt{if}-Abfrage nehmen wir die Invariante $I$ zusammen mit der Bedingung 
      $y > 0$.  Für die Zuweisung ``\texttt{r = r * x;}'' erhalten wir dann die 
      Bedingung $I \wedge y > 0 \wedge y \mod 2 = 1$.  Das liefert das Hoare-Tripel
      \\[0.2cm]
      \hspace*{1.3cm}
      $\{r \cdot x^y = a^b \wedge y > 0 \wedge y \mod 2 = 1\}$
      \\[0.2cm]
      \hspace*{2.3cm} \texttt{r := r * x;}
      \\[0.2cm]
      \hspace*{1.3cm}
      $\{\bigl(r \cdot x^y = a^b \wedge y > 0 \wedge y \mod 2 = 1\bigr)[r \mapsto r/x]\}$
      \\[0.2cm]
      Die Nachbedingung vereinfacht sich zu 
      \\[0.2cm]
      \hspace*{1.3cm}
      $r/x \cdot x^y = a^b \wedge y > 0 \wedge y \mod 2 = 1$ 
      \\[0.2cm]
      und das ist dasselbe wie
      \\[0.2cm]
      \hspace*{1.3cm}
      $r \cdot x^{y-1} = a^b \wedge y > 0 \wedge y \mod 2 = 1$.
      \\[0.2cm]
      Um dies weiter vereinfachen zu können, schreiben wir
      \\[0.2cm]
      \hspace*{1.3cm}
      $y = 2 \cdot (y/2) + y \mod 2$.
      \\[0.2cm]
      Setzen wir diesen Wert von $y$ in der letzten Gleichung ein, so erhalten wir
      \\[0.2cm]
      \hspace*{1.3cm}
      $r \cdot x^{2 \cdot (y/2)} = a^b \wedge y > 0 \wedge y \mod 2 = 1$,
      \\[0.2cm]
      denn aus $y \mod 2 = 1$ folgt $y -1 = 2 \cdot (y/2)$.  Damit haben wir die
      Gültigkeit von
      \\[0.2cm]
      \hspace*{1.3cm}
      $\hoare{r \cdot x^y = a^b \wedge y > 0 \wedge y \mod 2 = 1}{r := r * x;}{
              r \cdot x^{2 \cdot (y/2)} = a^b}$
      \\[0.2cm]
      bewiesen.  Wir versuchen nun, unter der Bedingung $y \mod 2 = 0$ 
      die Invariante $I$ so umzuformen, dass sie mit der Nachbedingung dieses
      Hoare-Tripels  übereinstimmt.  Es gilt 
      \\[0.2cm]
      \hspace*{1.3cm}
      $r \cdot x^y = a^b \wedge y > 0 \wedge y \mod 2 = 0 \rightarrow 
       r \cdot x^{2 \cdot (y/2)} = a^b$,
      \\[0.2cm]
      denn aus $y \mod 2 = 0$ folgt $y = 2 \cdot (y/2)$.  Damit haben wir
      insgesamt für die \texttt{if}-Abfrage das folgende Hoare-Tripel gefunden:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\{r \cdot x^y = a^b \wedge y > 0 \}$
      \\[0.2cm]
      \hspace*{2.3cm} \texttt{if (y \% 2) == 1 \{ r := r * x;\}}
      \\[0.2cm]
      \hspace*{1.3cm}
      $\{ r \cdot x^{2 \cdot (y/2)} = a^b\}$
\item Als nächstes untersuchen wir die Zuweisung ``\texttt{x := x * x;}''.
      Als Vorbedingung nehmen wir natürlich die Nachbedingung der \texttt{if}-Abfrage.
      Wir erhalten das Hoare-Tripel
      \\[0.2cm]
      \hspace*{1.3cm}
      $\hoare{r \cdot x^{2 \cdot (y/2)} = a^b}{x := x * x;}{
              \bigl(r \cdot x^{2 \cdot (y/2)} = a^b\bigr)\bigl[x \mapsto x^{\frac{1}{2}}\bigr]}$
      \\[0.2cm]
      Führen wir die Substitution aus, so vereinfacht sich die Nachbedingung zu 
      \\[0.2cm]
      \hspace*{1.3cm}
      $r \cdot (x^{\frac{1}{2}})^{2 \cdot (y/2)} = a^b$
      \\[0.2cm]
      und dies kann weiter vereinfacht werden zu 
      \\[0.2cm]
      \hspace*{1.3cm}
      $r \cdot x^{y/2} = a^b$
      \\[0.2cm]
      Damit haben wir also insgesamt das Hoare-Tripel
      \\[0.2cm]
      \hspace*{1.3cm}
      $\hoare{r \cdot x^{2 \cdot (y/2)} = a^b}{x := x * x;}{
              r \cdot x^{y/2} = a^b}$
      \\[0.2cm]
      gefunden.
\item Die letzte Zuweisung ``\texttt{y := y / 2;}'' liefert nun das Hoare-Tripel
      \\[0.2cm]
      \hspace*{1.3cm}
      $\hoare{r \cdot x^{y/2} = a^b}{y := y / 2;}{r \cdot x^{y} = a^b}$.
      \\[0.2cm]
      Hier haben wir die allgemeine Zuweisungs-Regel
      \\[0.2cm]
      \hspace*{1.3cm}
      $\hoare{F[y \mapsto t]}{y := t;}{F}$
      \\[0.2cm]
      benutzt, wobei wir für $F$ die Formel $r \cdot x^{y} = a^b$ und für $t$ den Term 
      $y / 2$ verwendet haben.

      \textbf{Bemerkung}:  Es ist hier nicht möglich, die Zuweisungs-Regel
      \\[0.2cm]
      \hspace*{1.3cm}
      $\hoare{F}{x := h(x);}{F\sigma} \quad \mathrm{mit} \quad \sigma = \bigl[x \mapsto h^{-1}(x)\bigr]$
      \\[0.2cm]
      zu verwenden, denn die Funktion $y \mapsto y/2$ ist nicht umkehrbar, da
      sowohl $2/2 = 1$ als auch $3/2 = 1$ gilt.
\item Da  die Nachbedingung des letzten Hoare-Tripels  genau die Schleifen-Invariante $I$
      ist, haben wir insgesamt die Korrektheit des  folgenden Hoare-Tripels gezeigt: 
      \\[0.2cm]
      \hspace*{1.3cm} $\{ r \cdot x^y = a^b \}$                  \\[0.2cm]
      \hspace*{2.3cm} \texttt{while (y > 0) \{}                  \\
      \hspace*{2.8cm} \texttt{if (y \% 2 == 1) \{ r = r * x; \}}  \\
      \hspace*{2.8cm} \texttt{x = x * x;}                        \\
      \hspace*{2.8cm} \texttt{y = y / 2;}                        \\
      \hspace*{2.3cm} \texttt{\}}                                \\
      \hspace*{1.3cm} $\{ r \cdot x^y = a^b \wedge \neg y > 0\}$ \\[0.2cm]
      Da $y$ eine natürlich Zahl sein muss, denn $y$ wird ja nur durch die
      Ganzzahl-Divison 
      \\[0.2cm]
      \hspace*{1.3cm}
      $y = y / 2$
      \\[0.2cm]
      verändert, folgt aus $\neg y > 0$, dass $y = 0$ gilt.  Damit lautet die Nachbedingung der
      \texttt{while}-Schleife also 
      \\[0.2cm]
      \hspace*{1.3cm} $r \cdot x^y = a^b \wedge y = 0$,
      \\[0.2cm]
      was sich wegen $x^0 = 1$ zu 
      \\[0.2cm]
      \hspace*{1.3cm}
      $r = a^b$,
      \\[0.2cm]
      vereinfacht.  Insgesamt haben wir also gezeigt, dass die Variable $r$ am Ende der
      \texttt{while}-Schleife den Wert $a^b$ hat.  
\end{enumerate}
Es bleibt noch zu zeigen, dass die \texttt{while}-Schleife immer terminiert.
Einerseits wird die Variable \texttt{y}  in jedem Schritt ganzzahlig durch zwei geteilt, andererseits
läuft die Schleife nur solange, wie die Variable \texttt{y} positiv ist.  Daher muss die
Schleife abbrechen.
\hspace*{\fill} $\Box$

\subsection{Maschinelle Programm-Verifikation}
Die manuelle Verifikation nicht-trivialer Programm mit Hilfe des Hoare-Kalküls ist sehr
aufwendig.  Von Hand können nur Programme verifiziert werden, die in derselben
Größenordnung liegen, wie der oben behandelte Euklid'sche Algorithmus.  Es ist aber
möglich, den Prozess der Programm-Verifikation zumindest partiell zu automatisieren.
Sogenannte VCGs (\emph{\underline{v}erification \underline{c}ondition
  \underline{g}enerators}) reduzieren die Verifikation eines Programms auf den Nachweis
bestimmter logischer Formeln, die als \emph{Verifikations-Bedingungen} bezeichnet werden.
Die Verifikations-Bedingungen können dann mit der Unterstützung automatischer Beweise
nachgewiesen werden.  Auch dieses Vorgehen ist nur für Programme mittlerer Komplexität
praktikabel.  Im Internet finden Sie unter der Adresse
\\[0.2cm]
\hspace*{1.3cm}
\texttt{http://www.mathematik.uni-marburg.de/\symbol{126}gumm/NPPV/JavaProgramVerifierII.zip}
\\[0.2cm]
das System \textsc{Jpv} (\underline{J}ava \underline{p}rogram \underline{v}erifier), 
mit dessen Hilfe Programme verifiziert werden können.  Das dort zur Verfügung
gestellten Systeme ist nicht darauf ausgelegt, umfangreiche Programme zu verifizieren, es
reicht aber aus, um einen Eindruck in die Technik zu vermitteln.  Wir demonstrieren das
System am Beispiel der Verifikation des Programms zur Berechnung der Potenz.  Die
Benutzer-Eingabe hat in diesem Fall die in Abbildung \ref{fig:Power.ver} gezeigte Form.
\begin{enumerate}
\item Zeile 1 enthält, eingefasst in den Zeichen ``\texttt{\#\#}'', die Vorbedingung
      des Programms. Hier wird ausgesagt, dass die Variablen $x$ und $y$ zu Beginn
      zwei Zahlen $a$ und $b$.  Beim Beweis werden wir hinterher davon ausgehen, dass
      es sich bei $a$ und $b$ um natürliche Zahlen handelt.
\item Hinter der \texttt{while}-Schleife formulieren wir in Zeile 3 die Invariante der Schleife:
      \\[0.2cm]
      \hspace*{1.3cm}
      $r \cdot x^y = a^b$.
      \\[0.2cm]
      Da der Potenz-Operator in \textsc{Jpv} nicht zur Verfügung steht, haben wir für
      $x^y$ den Ausdruck $\texttt{pow}(x,y)$ verwendet.
\item Die letzte Zeile enthält die Nachbedingung des Programm-Fragments.  Hier wird
      ausgedrückt, dass am Ende der Rechnung $r = a^b$ gilt.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    ## x == a & y == b & b > 0 ##
      r = 1;
      while(y > 0) ## r * pow(x,y) == pow(a,b) ##
      {
         if (y % 2 == 1) {
            r = r * x;  
         }
         x = x * x;
         y = y / 2;
      }
    ## r == pow(a,b) ##
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Verifikation der Berechnung der Potenz mit \textsc{Jpv}.}
\label{fig:Power.ver}
\end{figure}

Wir können nun \textsc{Jpv} benutzen, um nachzuweisen, dass das oben gezeigte
Programm-Fragment die annotierte Spezifikation erfüllt.  Starten wir das System mit Hilfe
des Befehls
\\[0.2cm]
\hspace*{1.3cm}
\texttt{java -jar JPV.jar}
\\[0.2cm]
so werden die folgenden Verifi\-kations-Bedingungen erzeugt:
\begin{enumerate}
\item $x = a \wedge y = b \rightarrow 1 \cdot x^y = a^b$.
\item $r \cdot x^y = a^b \rightarrow r \cdot x^y = a^b$.
\item $y > 0 \wedge r \cdot x^y = a^b \wedge y \,\texttt{\%}\, 2 = 1 \rightarrow
        r \cdot x \cdot (x \cdot x)^{y / 2} = a^b$.
\item $y > 0 \wedge r \cdot x^y = a^b \wedge y \,\texttt{\%}\, 2 \not= 1    \rightarrow
        r \cdot (x \cdot x)^{y / 2} = a^b$.
\item $r \cdot (x \cdot x)^{y / 2} = a^b \rightarrow r \cdot (x \cdot x)^{y / 2} = a^b$.
\item $r \cdot x^{y / 2} = a^b    \rightarrow r \cdot x^{y / 2} = a^b$.
\item $r \cdot x^y = a^b \wedge y \leq 0    \rightarrow r = a^b$.
\end{enumerate}
Der in \textsc{Jpv} integrierte automatische Beweiser ist in der Lage, die 1., die 2., die
5. und die 6. dieser Verifikations-Bedingungen unmittelbar nachzuweisen.  Der Nachweis der
Korrektheit der restlichen Bedingungen ist dann vom Benutzer mit Papier und Bleistift zu erbringen.
Da wir die entsprechenden Beweise im wesentlichen schon beim Nachweis der Korrektheit des in
Abbildung \ref{fig:power.c} gezeigten Programms geführt haben, wiederholen wir sie hier
nicht noch einmal.


\section{Symbolische Programm-Ausführung}
Wir haben im letzten Abschnitt gesehen, dass der Hoare-Kalkül sehr schwerfällig ist.  Es
gibt noch eine weitere Methode, um die Korrektheit eines sequentiellen Programms
nachzuweisen.  Dies ist die Methode der \emph{symbolischen Programm-Ausführung}.  Wir
demonstrieren diese Methode an Hand des in Abbildung \ref{fig:power.c} gezeigten
Programms zur iterativen Berechnung der Potenz.


\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 1.3cm,
                  xrightmargin  = 1.3cm,
                  codes         = {\catcode`_=8\catcode`$=3},
                  commandchars  = \\\{\},
                ]
    power := procedure(x$_0$, y$_0$) \{
        r$_0$ := 1;
        while (y$_n$ > 0) \{
            if (y$_n$ % 2 == 1) \{
                r$_{n+1}$ := r$_n$ * x$_n$;
            \} 
            x$_{n+1}$ := x$_n$ * x$_n$;
            y$_{n+1}$ := y$_n$ / 2;            
        \} 
        return r$_N$;
    \};
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Das indizierte \texttt{C}-Programm zur Berechnung der Potenz.}
\label{fig:PowerIterative.iter}
\end{figure} % $


Der wesentliche Unterschied zwischen einer mathematischen Formel und einen Programm ist
der, dass alle Auftreten einer Variablen in einer mathematischen Formel den selben Wert
bezeichnen.  In einem Programm ist dies anders, denn die Werte einer Variablen ändern sich
dynamisch.  Um diesem  Verhalten Rechnung zu tragen, müssen wir die verschiedenen
Auftreten einer Formel unterscheiden können.  Dies geht am einfachsten, wenn wir die
Variablen so indizieren, dass der Index der Variablen sich jedesmal ändert, wenn die
Variable einen neuen Wert zugewiesen bekommt. 
Dabei müssen wir allerdings berücksichtigen, dass ein und dasselbe textuelle
Auftreten einer Variablen immer noch verschiedene Werte annehmen kann und zwar dann, wenn 
das Auftreten in einer Schleife liegt.  In diesem Fall müssen wir die Variable so
indizieren, dass noch ein Zähler für die Anzahl der Schleifen-Durchläufe in dem Index
eingebaut ist.  Um die Diskussion nicht zu abstrakt werden zu lassen, betrachten wir das
Beispiel in Abbildung \ref{fig:PowerIterative.iter}.  Hier hat die Variable \texttt{r} auf
der rechten Seite der Zuweisung in Zeile 6 den Wert $\texttt{r}_n$, auf der linken Seite
hat sie dann anschließend den Wert $\texttt{r}_{n+1}$ und am Ende der Schleife in Zeile 11 hat die
Variable \texttt{r} den Wert $\texttt{r}_N$, wobei $N$ die Anzahl der Schleifen-Durchläufe
angibt.

Wir beweisen nun die Korrektheit des abgebildeten Programms.  Wir definieren
\[ a := x_0, \quad b := y_0 \]
und zeigen, dass für die \texttt{while}-Schleife die Invariante
\begin{equation}
  \label{eq:powerInv}
   r_n \cdot x_n^{y_n} = a^b   
\end{equation}
gilt.  Diese Behauptung beweisen wir durch eine Induktion nach der Anzahl der
Schleifen-Durchläufe.
\begin{enumerate}
\item[I.A.] $n=0$:  Wegen $r_0 = 1$ und $x_0 = a$ sowie $y_0 = b$ gilt für $n= 0$ 
            \\[0.2cm]
            \hspace*{1.3cm}
            $r_n \cdot x_n^{y_n} = r_0 \cdot x_0^{y_0} = 1 \cdot a^{b} = a^b$.
\item[I.S.] $n \mapsto n + 1$:  Wir führen eine Fallunterscheidung nach dem Wert von $y \mod 2$ durch:
            \begin{enumerate}
            \item $y_n \mod 2 = 1$.  Dann gilt $y_{n} = 2 \cdot (y_n/2) + 1$.
                  Damit finden wir
                  \begin{eqnarray*}
                      &   & r_{n+1} \cdot x_{n+1}^{y_{n+1}} \\[0.2cm] 
                      & = & (r_{n} \cdot x_n) \cdot (x_{n} \cdot x_{n})^{y_{n}/2} \\[0.2cm] 
                      & = & r_{n} \cdot x_n \cdot x_{n}^{y_{n}/2} \cdot x_{n}^{y_{n}/2} \\[0.2cm] 
                      & = & r_{n} \cdot x_n^{1 + y_{n}/2 + y_{n}/2} \\[0.2cm] 
                      & = & r_{n} \cdot x_n^{2 \cdot (y_{n}/2) + 1} \\[0.2cm] 
                      & = & r_{n} \cdot x_n^{y_n} \\
                      & \stackrel{IV}{=} & a^{b} 
                  \end{eqnarray*}
            \item $y_n \mod 2 = 0$.  Dann gilt $y_{n} = 2 \cdot (y_n/2)$.
                  Damit finden wir
                  \begin{eqnarray*}
                      &   & r_{n+1} \cdot x_{n+1}^{y_{n+1}} \\[0.2cm] 
                      & = & r_{n} \cdot (x_{n} \cdot x_{n})^{y_{n}/2} \\[0.2cm] 
                      & = & r_{n} \cdot x_{n}^{y_{n}/2} \cdot x_{n}^{y_{n}/2} \\[0.2cm] 
                      & = & r_{n} \cdot x_n^{y_{n}/2 + y_{n}/2} \\[0.2cm] 
                      & = & r_{n} \cdot x_n^{2 \cdot (y_{n} / 2)} \\[0.2cm] 
                      & = & r_{n} \cdot x_n^{y_n} \\
                      & \stackrel{IV}{=} & a^{b} 
                  \end{eqnarray*}
            \end{enumerate}
\end{enumerate}
Damit ist die Gleichung (\ref{eq:powerInv}) bewiesen.   Wenn die \texttt{while}-Schleife
abbricht, dann muss $y_N = 0$ gelten.  Gleichung (\ref{eq:powerInv}) liefert für $n=N$:
\[ r_N \cdot x_N^{y_N} = x_0^{y_0} 
  \leftrightarrow  r_N \cdot x_N^{0}   = a^b
  \leftrightarrow  r_N \cdot 1         = a^b
  \leftrightarrow  r_N                 = a^b
\]
Damit haben wir insgesamt $r_N = a^b$ bewiesen und da wir schon wissen, dass
die \texttt{while}-Schleife terminiert, ist damit gezeigt, dass der
Funktions-Aufruf $\texttt{power}(a,b)$ tatsächlich den Wert $a^b$ berechnet.
\vspace*{0.3cm}
\pagebreak

\noindent
\textbf{Aufgabe}:  Weisen Sie mit der Methode der symbolischen Programm-Ausführung die
Korrektheit der in Abbildung \ref{fig:gcd.c} gezeigten effizienteren Version des
Euklid'schen Algorithmus nach. 
Sie dürfen dabei benutzen, dass für positive natürliche Zahlen $a$ und $b$ die Beziehung 
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{ggt}(a, b) = \mathtt{ggt}(a \,\texttt{\%}\, b, b)$
\\[0.2cm]
erfüllt ist.  

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    ggt := procedure(a, b) {
        while (b != 0) {
            r := a % b;
            a := b;
            b := r;
        }
        return a;
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Der Euklid'sche Algorithmus zur Berechnung des größten gemeinsamen Teilers.}
\label{fig:gcd.c}
\end{figure}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "logik"
%%% End: 
