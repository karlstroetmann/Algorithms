\section{Das Wolf-Ziege-Kohl-Problem}
Zum Abschluss dieses Kapitels wollen wir zeigen, wie mit Hilfe von Mengen auch komplexere
Problem gelöst werden können.  Wir wählen dazu das \emph{Wolf-Ziege-Kohl-Problem}, das wir
bereits im ersten Semester  bearbeitet haben:
\vspace*{0.3cm}

\begin{minipage}[c]{14cm}
{\sl
Ein Bauer will mit einem Wolf, einer Ziege und einem Kohl über einen Fluß übersetzen, um
diese als Waren auf dem Markt zu verkaufen.
Das Boot ist aber so klein, dass er nicht zwei Waren gleichzeitig mitnehmen kann.
Wenn er den Wolf mit der Ziege allein lässt, dann frißt der Wolf die Ziege und wenn er die
Ziege mit dem Kohl allein lässt, dann frißt die Ziege den Kohl. }
\end{minipage}
\vspace*{0.3cm}


\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    findPath := procedure(x, y, r) {
        p := { [x] };
        while (true) {
            oldP  := p;
            p     := p + pathProduct(p, r);
            found := { l in p | l[#l] == y };
            if (found != {}) { return arb(found); }
            if (p == oldP)   { return;            }
        }
    };
    pathProduct := procedure(p, q) {
        return { add(x,y) : x in p, y in q | x[#x] == y[1] && !cyclic(add(x,y)) };
    };
    cyclic := procedure(p) { 
        return #{ x : x in p } < #p;
    };
    add := procedure(p, q) {
        return p + q[2..];
    };
    problem := procedure(s) {
        return "goat" in s && "cabbage" in s || "wolf" in s && "goat" in s;
    };   
    all := { "farmer", "wolf", "goat", "cabbage" };
    p   := { [ s1, s2 ] : s1 in pow(all), s2 in pow(all) 
                        | s1 + s2 == all && s1 * s2 == {} 
           };
    r1  := { [ [ s1, s2 ], [ s1 - b, s2 + b ] ]: [s1, s2 ] in p, b in pow(s1) 
             | "farmer" in b && #b <= 2 && !problem(s1 - b) 
           };
    r2  := { [ [ s1, s2 ], [ s1 + b, s2 - b ] ]: [s1, s2] in p, b in pow(s2) 
             | "farmer" in b && #b <= 2 && !problem(s2 - b)
           };
    r   := r1 + r2;
    
    start := [ all, {} ];
    goal  := [ {}, all ];
    path  := findPath(start, goal, r);
    print(path);
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Lösung des Wolf-Ziege-Kohl-Problems in \textsc{SetlX}.}
\label{fig:wolf-ziege-kohl.stlx}
\end{figure}

\noindent
Wir hatten damals das in Abbildung
\ref{fig:wolf-ziege-kohl.stlx} auf Seite \pageref{fig:wolf-ziege-kohl.stlx} gezeigte
\textsc{Setl2}-Programm zur Lösung dieses Problems entwickelt.  
Wir wollen nun versuchen, diese Lösung in  \textsl{Java} zu reimplementieren.
Als erstes müssen wir überlegen, wie wir die Mengen, mit denen dort gearbeitet wird,
darstellen wollen.    In \textsl{Java} stehen hierfür die Klassen \texttt{TreeSet}
und \texttt{HashSet} zur Auswahl.  
Wir entscheiden uns für die Klasse \texttt{TreeSet}, denn bei der Klasse \texttt{HashSet}
gibt es Probleme, wenn wir Mengen von Mengen definieren wollen.
Auch bei der Klasse \texttt{TreeSet} gibt es an dieser Stelle Probleme, allerdings sind
diese Probleme einfacher zu lösen.

Versuchen wir
das Programm aus Abbildung \ref{fig:wolf-ziege-kohl.stlx} in \textsl{Java} umzusetzen,
so müssen wir  benötigen wir bei  der Umsetzung Mengen,
deren Elemente selbst wieder Mengen sind.  Die Elemente eines \texttt{TreeSet}s müssen
aber vergleichbar sein, für eine beliebige Klasse \texttt{E} kann nur dann eine Klasse
\texttt{TreeSet<E>} gebildet werden, wenn 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{E implements Comparable<E>}
\\[0.2cm]
gilt.  Leider wird die Schnittstelle \texttt{Comparable} von der Klasse
\texttt{TreeSet} selber nicht implementiert.  Damit erleiden wir Schiffbruch, wenn wir
versuchen,  eine Klasse der Form 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{TreeSet<TreeSet<E>>}
\\[0.2cm]
zu erzeugen und damit zu arbeiten.  Abbildung \ref{fig:SetOfSet.java} zeigt ein Programm,
bei dem wir eine Menge von Mengen von Zahlen anlegen wollen.  Der Versuch scheitert in dem
Moment, wo wir die zweite Menge in die Menge von Mengen einfügen wollen, denn dann merkt
die virtuelle Maschine, dass Objekte der Klasse \texttt{TreeSet} das Interface
\texttt{Comparable} nicht implementieren.  Wir erhalten die Fehlermeldung
\begin{verbatim}
    Exception in thread "main" java.lang.ClassCastException: 
         java.util.TreeSet cannot be cast to java.lang.Comparable
\end{verbatim}
Wir behelfen uns dadurch, dass wir eine neue Klasse \texttt{ComparableSet<E>}
definieren, die das Interface \texttt{Comparable} implementiert.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    import java.util.*;
    
    public class SetOfSet {
        public static void main(String[] args) {
            TreeSet<TreeSet<Integer>> all = new TreeSet<TreeSet<Integer>>();
            TreeSet<Integer> a = new TreeSet<Integer>();
            a.add(1);
            a.add(2);
            a.add(3);
            TreeSet<Integer> b = new TreeSet<Integer>();
            b.add(1);
            b.add(2);
            b.add(3);
            all.add(a);
            all.add(b);
            System.out.println(all);
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Mengen von Mengen: Vorsicht Falle!}
\label{fig:SetOfSet.java}
\end{figure}
\pagebreak


\subsection{Die Klasse \texttt{ComparableSet}}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    import java.util.*;
    
    public class ComparableSet<T extends Comparable<? super T>> 
        implements Comparable<ComparableSet<T>>, 
                   Iterable<T>
    {
        protected TreeSet<T> mSet;
    
        public TreeSet<T> getSet()           { return mSet;             }        
        public ComparableSet()               { mSet = new TreeSet<T>(); }
        public ComparableSet(TreeSet<T> set) { mSet = set;              } 
        public ComparableSet<T> deepCopy() {
            return new ComparableSet<T>(new java.util.TreeSet<T>(mSet));
        }
        public boolean isEmpty()      { return mSet.isEmpty();    }
        public boolean add(T element) { return mSet.add(element); }
        public Iterator<T> iterator() { return mSet.iterator();   }
        public int size()             { return mSet.size();       }

        public T any()                { return mSet.first();      }
        public String toString()      { return mSet.toString();   }
        
        public boolean equals(Object x) {
            if (x instanceof ComparableSet) {
                ComparableSet cmpSet = (ComparableSet) x;
                TreeSet       set    = cmpSet.mSet;
                return mSet.equals(set);
            }
            return false;
        }
        public boolean member(T element) {
            return mSet.contains(element);
        }
        public boolean isSubset(ComparableSet<T> set) {
            return set.getSet().containsAll(mSet);
        }
    \end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{ComparableSet<T>}, 1.~Teil.}
\label{fig:ComparableSet-1}
\end{figure}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = last,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
        public int compareTo(ComparableSet<T> comparableSet) {
            TreeSet<T>  set        = comparableSet.getSet();
            Iterator<T> iterFirst  = mSet.iterator();
            Iterator<T> iterSecond =  set.iterator();
            while (iterFirst.hasNext() && iterSecond.hasNext()) {
                T   first  = iterFirst .next();
                T   second = iterSecond.next();
                int cmp    = first.compareTo(second);
                if (cmp == 0) {
                    continue;
                }
                return cmp;
            }
            if (iterFirst.hasNext())  { return  1; }       
            if (iterSecond.hasNext()) { return -1; }
            return 0;
        }
        public ComparableSet<T> union(ComparableSet<T> comparableSet) {
            TreeSet<T> union = new TreeSet<T>(mSet);
            union.addAll(comparableSet.getSet());
            return new ComparableSet<T>(union);
        }    
        public ComparableSet<T> intersection(ComparableSet<T> comparableSet) {
            TreeSet<T> intersection = new TreeSet<T>(mSet);
            intersection.retainAll(comparableSet.getSet());
            return new ComparableSet<T>(intersection);
        }    
        public ComparableSet<T> difference(ComparableSet<T> comparableSet) {
            TreeSet<T> difference = new TreeSet<T>(mSet);
            difference.removeAll(comparableSet.getSet());
            return new ComparableSet<T>(difference);
        }
        public <S extends Comparable<? super S>> ComparableSet<Pair<T,S>>
            product(ComparableSet<S> comparableSet) 
        {
            TreeSet<Pair<T,S>> product = new TreeSet<Pair<T,S>>();
            for (T x: mSet) {
                for (S y: comparableSet.getSet()) {
                    product.add(new Pair<T,S>(x, y));
                }
            }       
            return new ComparableSet<Pair<T,S>>(product);
        }
        public ComparableSet<ComparableSet<T>> powerSet() {
            return new ComparableSet<ComparableSet<T>>(powerSet(mSet));
        }   
    \end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{ComparableSet<T>}, 2.~Teil.}
\label{fig:ComparableSet-2}
\end{figure}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = last,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
        private static <S extends Comparable<? super S>> TreeSet<ComparableSet<S>> 
            powerSet(TreeSet<S> set) 
        {
            if (set.isEmpty()) {
                TreeSet<ComparableSet<S>> power = new TreeSet<ComparableSet<S>>();
                ComparableSet<S>          empty = new ComparableSet<S>();
                power.add(empty);
                return power;
            }
            S          last = set.last();
            TreeSet<S> rest = (TreeSet<S>) set.headSet(last);
            TreeSet<ComparableSet<S>> powerRest = powerSet(rest);
            TreeSet<ComparableSet<S>> powerSet  = cloneSet(powerRest);
            addElement(powerRest, last);
            powerSet.addAll(powerRest);
            return powerSet;
        }
        private static <S extends Comparable<? super S>> void 
            addElement(TreeSet<ComparableSet<S>> setOfSets, S element) 
        {
            for (ComparableSet<S> set: setOfSets) {
                set.add(element);
            }
        }
        private static <S extends Comparable<? super S>> TreeSet<ComparableSet<S>> 
            cloneSet(TreeSet<ComparableSet<S>> set) 
        {
            TreeSet<ComparableSet<S>> result = new TreeSet<ComparableSet<S>>();
            for (ComparableSet<S> s: set) {
                result.add(s.deepCopy());
            }
            return result;
        }
        public static <T extends Comparable<? super T>> ComparableSet<T> 
            singleton(T element) 
        {
            TreeSet<T> set = new TreeSet<T>();
            set.add(element);
            return new ComparableSet<T>(set);
        }
        public static <T extends Comparable<? super T>> ComparableSet<T> 
            doubleton(T first, T second) 
        {
            TreeSet<T> set = new TreeSet<T>();
            set.add(first);
            set.add(second);
            return new ComparableSet<T>(set);
        }
    \end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{ComparableSet<T>}, 3.~Teil.}
\label{fig:ComparableSet-3}
\end{figure}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = last,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
        public static ComparableSet<Integer> range(int low, int high) {
            ComparableSet<Integer> result = new ComparableSet<Integer>();
            for (int i = low; i <= high; ++i) {
                result.add(i);
            }
            return result;
        }   
        public static <U extends Comparable<? super U>, 
                       V extends Comparable<? super V>, 
                       W extends Comparable<? super W>> ComparableSet<Pair<U,W>> 
            compose(ComparableSet<Pair<U,V>> R1, ComparableSet<Pair<V,W>> R2) 
        {
            ComparableSet<Pair<U,W>> result = new ComparableSet<Pair<U,W>>();
            for (Pair<U,V> xy: R1) {
                for (Pair<V,W> yz: R2) {
                    if (xy.getSecond().equals(yz.getFirst())) {
                        result.add(new Pair<U,W>(xy.getFirst(), yz.getSecond()));
                    }
               }
            }    
            return result;
        }
        public ComparableSet<T> select(Selector<T> selector) {
            TreeSet<T> result = new TreeSet<T>();
            for (T element: mSet) {
                if (selector.select(element)) { result.add(element); }
            }
            return new ComparableSet<T>(result);
        }
        public <S extends Comparable<? super S>> ComparableSet<S> 
            transform(Transformer<S, T> transformer) 
        {
            TreeSet<S> result = new TreeSet<S>();
            for (T element: mSet) {
                result.add(transformer.transform(element));
            }
            return new ComparableSet<S>(result);
        }
    \end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{ComparableSet<T>}, 4.~Teil.}
\label{fig:ComparableSet-4}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
        public static <T extends Comparable<? super T>, 
                       X extends Comparable<? super X>, 
                       Y extends Comparable<? super Y>> ComparableSet<T>
        combineSets(ComparableSet<X> S1, 
                    ComparableSet<Y> S2, 
                    Combinator<T,X,Y> combinator) 
        {
            TreeSet<T> result = new TreeSet<T>();
            for (X x: S1) {
                for (Y y: S2) {
                    result.add(combinator.combine(x, y));
                }
            }
            return new ComparableSet<T>(result);
        }
    }    
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{ComparableSet<T>}, 5.~Teil.}
\label{fig:ComparableSet-5}
\end{figure}


Die Abbildungen 
\ref{fig:ComparableSet-1}, \ref{fig:ComparableSet-2}, \ref{fig:ComparableSet-3},
\ref{fig:ComparableSet-4} und \ref{fig:ComparableSet-5}
zeigen die Implementierung der Klasse \texttt{ComparableSet}.  Wir diskutieren die
Implementierung jetzt im Detail.
\begin{enumerate}
\item In Zeile 3 fordern wir für den Typ-Parameter \texttt{T} der Klasse
      \texttt{ComparableSet<T>}, dass
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{T extends Comparable<? super T>}
      \\[0.2cm]
      gilt.  Hier steht das Fragezeichen ``\texttt{?}'' für eine Oberklasse \texttt{O}
      von \texttt{T}.  Die Forderung ist also, dass es eine Klasse \texttt{O} gibt, die
      eine Oberklasse der Elemente von \texttt{T} ist, und für die außerdem
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{T extends Comparable<O>}
      \\[0.2cm]
      gilt.  Das Interface \texttt{Comparable<O>} hat die Form
      \begin{verbatim}
      interface Comparable<O> { int compareTo(O o); }
      \end{verbatim}
      Also spezifiziert der String ``\texttt{T extends Comparable<? super T>}'', dass
      Elemente der Klasse \texttt{T} mit Elementen jeder Oberklasse von \texttt{T}
      vergleichbar sein müssen.  Im ersten Moment denken Sie eventuell, dass es reichen
      würde, wenn wir 
\begin{verbatim}
      ComparableSet<T extends ComparableSet<T>>
\end{verbatim}
      schreiben würden.  Das würde aber dann nicht mehr funktionieren, wenn wir zunächst
      eine Klasse \texttt{A} hätten, die als
\begin{verbatim}
      class A implements Comparable<A> { ... }
\end{verbatim}
      definiert ist und von dieser Klasse später eine Klasse \texttt{B} ableiten, welche die
      Methode\\
      $\textsl{compareTo}()$ von der Klasse \texttt{A} erbt.  Das Problem ist,
      dass für \texttt{B} in dem Fall nur
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{B implements Comparable<A>}
      \\[0.2cm]
      gilt und eben nicht
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{B implements Comparable<B>}.
      \\[0.2cm]
      Damit könnten wir keine Klasse \texttt{ComparableSet<B>} mehr bilden und
      müssten statt dessen auf die ungenauere Klasse \texttt{ComparableSet<A>} ausweichen,
      wobei  wir Typinformationen verlieren würden.
\item Die Klasse \texttt{ComparableSet} ist letztlich nur eine Verpackung eines 
      Objektes der Klasse \texttt{TreeSet}, das in Zeile 7 durch die Member-Variable
      \texttt{mSet}  definiert wird.  An dieser Stelle stellt sich die Frage,
      warum wir die Klasse \texttt{ComparableSet} nicht von der Klasse \texttt{TreeSet}
      ableiten.  Der Grund für dieses Vorgehen ist, dass die wesentlichen Methoden, die in der
      Klasse \texttt{TreeSet} implementiert sind, die Mengen, auf denen sie arbeiten,
      verändern.  Wenn wir beispielsweise für zwei Mengen $a$ und $b$ die Methode
      \\[0.2cm]
      \hspace*{1.3cm}
      $a.\textsl{addAll}(b)$
      \\[0.2cm]
      aufrufen um die Vereinigung $a \cup b$ zu berechnen, so hat die Menge $a$ nach
      diesem Aufruf ihren alten Wert verloren.  Solche Seiteneffekte sind für die Art und
      Weise, in der wir Mengen benutzen wollen, sehr unerwüscht.  Die Methoden, die dem
      Benutzer der Klasse \texttt{ComparableSet} zur Verfügung gestellt werden, sollen
      frei von Seiteneffekten sein.  Beispielsweise werden wir eine Methode $\textsl{union}()$
      implementieren, die so beschaffen ist, dass für zwei Mengen $a$ und $b$
      \\[0.2cm]
      \hspace*{1.3cm}
      $a.\textsl{union}(b) = a \cup b$
      \\[0.2cm]
      gilt und dass außerdem die Variablen $a$ und $b$ bei dieser Operation ihre alten Werte behalten.
      Diese Methode $\textsl{union}()$ soll die in der Klasse \texttt{TreeSet} implementierte Klasse
      $\textsl{addAll}()$ ersetzen.  Würden wir die Klasse \texttt{ComparableSet} von der Klasse
      \texttt{TreeSet} ableiten, so hätte der Beutzer immer noch die Möglichkeit, beispielsweise die
      Methode $\textsl{addAll}()$ zu benutzen.  Dies soll verhindert werden, denn nur so können wir für
      die Klasse \texttt{ComparableSet} die folgende Garantie geben: Eine Variable vom Typ
      \texttt{ComparableSet} ändert Ihren Wert nur, wenn ihr explizit ein neuer Wert zugewiesen wird.
\item Die Methode $\textsl{deepCopy}()$ erzeugt eine Kopie einer gegebenen Menge.  Diese Methode ist
      einem Konstruktor-Aufruf der Form
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{new ComparableSet<T>}(s)$
      \\[0.2cm]
      dann vorzuziehen, wenn sich der \texttt{TreeSet} $s$ ändern kann, denn dann würde sich auch der
      erzeugte \texttt{ComparableSet<T>} ändern.
\item Eine Reihe von Methoden werden in den Zeilen 15 -- 21 dadurch implementiert, dass
      die entsprechenden Methoden der Klasse \texttt{TreeSet} aufgerufen werden.
\item Die Methode $\textsl{equals}()$ ermöglicht uns, ein Objekt vom Typ
      \texttt{ComparableSet} mit einem beliebigen anderem Objekt zu vergleichen.
\item Der Aufruf $c.\textsl{member}(e)$ überprüft, ob $e$ ein Element der Menge $c$ ist.
\item Der Aufruf $c.\textsl{isSubset}(s)$ überprüft, ob $c$ eine Teilmenge der Menge $s$ ist.
\item Der Aufruf $c.\textsl{compareTo}(s)$ vergleicht die Menge $c$ mit der Menge $s$.
      Der Vergleich ist ein \emph{lexikografischer} Vergleich.  Da sowohl $c$ als auch $s$
      geordnete Mengen sind, lassen sich die Elemente von $c$ und $s$ der Größe nach
      auflisten.  Wir vergleichen nun die Elemente von $c$ und $s$ paarweise, wobei wir
      mit dem kleinsten Element beginnen.  Das erste Element, bei dem sich die Mengen $c$
      und $s$ unterscheiden, entscheidet dann über den Vergleich.
      Werden beispielsweise die Mengen
      \\[0.2cm]
      \hspace*{1.3cm}
      $c = \{ 2, 7 \}$ \quad und \quad $s = \{ 2, 3, 7, 14 \}$
      \\[0.2cm]
      auf diese Weise verglichen, so vergleichen wir zunächst das kleinste Element
      beider Mengen.  Das ist die $2$.  Da dieses Element für beide Mengen gleich ist,
      gehen wir zum zweiten Element.  In der Menge $c$ finden wir hier die $7$, in der
      Menge $s$ steht hier die $3$.  Da $3 < 7$ ist, ist folgern wir $s < c$.

      Falls die Ordnung auf den Elementen eine totale Ordnung ist, so lässt sich zeigen,
      dass auch die lexikografische Ordnung, die auf Mengen von Mengen definiert ist, eine
      totale Ordnung ist. 
\item Anschließend definieren wir die Methoden 
      $\textsl{union}()$,
      $\textsl{intersection}()$ und
      $\textsl{difference}()$ so, dass die Methoden  die Vereinigung, den Schnitt und die
      Mengendifferenz berechnen.  Der wesentliche Unterschied zu den analogen Methoden der
      Klasse \texttt{TreeSet} besteht hier darin, dass beispielsweise bei dem Aufruf 
      $c.\textsl{union}(s)$ die Menge $c$ nicht verändert wird.
\item Der Aufruf $c.\textsl{product}(s)$ bildet das kartesische Produkt der Mengen
      $c$ und $s$, es gilt also 
      \\[0.2cm]
      \hspace*{1.3cm}
      $c.\textsl{product}(s) = \bigl\{ \pair(x,y) \mid x \in c \wedge y \in s \bigr\}$.
      \\[0.2cm]
      Damit die Implementierung dieser Methode funktioniert,  muss die Klasse \texttt{Pair} so definiert
      sein, dass die Klasse \texttt{Pair<S,T>} das Interface \texttt{Comparable} implementiert.
      Abbildung  \ref{fig:Pair.java} auf Seite \pageref{fig:Pair.java} zeigt die Implementierung dieser Klasse.
\item Der Aufruf $c.\textsl{powerSet}()$ berechnet die Potenz-Menge von $c$.
      Die Implementierung geschieht unter Zuhilfenahme der statischen Methode
      $\textsl{powerSet}(s)$, die für einen gegeben \texttt{TreeSet} $s$ die Potenz-Menge 
      berechnet. Die Implementierung der Methode $\textsl{powerSet}()$ basiert auf den folgenden Gleichungen:
      \begin{enumerate}
      \item $\textsl{powerSet}\bigl(\{\}\bigr) = \bigl\{ \{\} \bigr\}$,
      \item $\textsl{powerSet}\bigl(A \cup \{x\} \bigr) = 
             \textsl{powerSet}(A) \cup \bigl\{ \{x\} \cup s : s \in \textsl{powerSet}(A) \bigr\}$.
      \end{enumerate}
      Die Methode $\textsl{headSet}()$, die bei der Realisierung benutzt wird, kann wir
      folgt spezifiziert werden: Der Aufruf $s.\textsl{headSet}(l)$ liefert alle alle
      Elemente aus der Menge $s$, die kleiner als $l$ sind:
      \[ s.\textsl{headSet}(l) = \{ x \in s \mid x < l \}. \]
      Der Aufruf $s.\textsl{last}()$ liefert das größte Element der Menge $s$.  Damit können wir
      eine Menge $s$ in der Form
      \\[0.2cm]
      \hspace*{1.3cm}
      $s = \{ s.\textsl{last}() \} \cup s.\textsl{headSet}(s.\textsl{last}())$
      \\[0.2cm]
      in eine einelementige Menge und die restlichen Elemente disjunkt zerlegen.
\item Für eine Menge von Mengen $S$ fügt der Aufruf $\textsl{addElement}(S, e)$ das Element $e$ in jede Menge
      aus $S$ ein: 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{addElement}(S,e) = \bigl\{ m \cup \{e\} \mid m \in S \bigr\}$.
\item Für eine Menge von Mengen $S$ liefert der Aufruf $c.\textsl{cloneSet}(S)$
      eine Kopie der Menge $S$, die nicht die Mengen von $S$ enthält sondern Kopien
      dieser Mengen.
\item Der Aufruf $\textsl{singleton}(x)$ liefert die Menge $\{x\}$.
\item Der Aufruf $\textsl{doubleton}(x,y)$ liefert die Menge $\{x,y\}$.
\item Der Aufruf $\textsl{range}(a,b)$ liefert die Menge 
      \\[0.2cm]
      \hspace*{1.3cm} $\{ n \in \mathbb{Z} \mid a \leq n \wedge n \leq b \}$.
\item Die Methode $\textsl{compose}(R_1, R_2)$ berechnet das relationale Produkt 
      $R_1 \circ R_2$ der Relationen $R_1$ und $R_2$.  Dieses Produkt ist wie folgt 
      definiert:
      \[ 
      R_1 \circ R_2 = \bigl\{ \pair(x,z) \mid \exists y : \pair(x,y) \in R_1 \wedge \pair(y,z) \in R_2 \bigl\}. 
      \]
\item Die Methode $\textsl{select}()$ gestattet die Mengenbildung durch Auswahl.
      Der Aufruf $c.\textsl{select}(s)$ berechnet für eine Menge $c$ und einen
      \emph{Selektor} $s$ die Menge 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\{ x \in c \mid s.\textsl{select}(x) \}$.
      \\[0.2cm]
      Ein Selektor ist dabei einfach ein Objekt $s$, dass eine Methode
      $s.\textsl{select}(x)$ zur Verfügung stellt.  Diese Methode gibt als Ergebnis 
      entweder \texttt{true} oder \texttt{false} zurück.  Abbildung
      \ref{fig:Selector.java} zeigt das Interface \texttt{Selector}.

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public interface Selector<T> {
        public boolean select(T element);
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Das Interface \texttt{Selector}.}
\label{fig:Selector.java}
\end{figure}

\item Die Methode $\textsl{transform}()$ berechnet eine Bild-Menge.
      Der Aufruf $c.\textsl{transform}(t)$ berechnet für einen
      \emph{Transformer} $t$ die Menge
      \\[0.2cm]
      \hspace*{1.3cm}
      $\bigl\{ t.\textsl{transform}(x) \mid x \in c \bigr\}$.
      \\[0.2cm]
      Ein Transformer ist hier ein Objekt, dass eine Methode
      $\textsl{transform}()$ zur Verfügung stellt, mit der Elemente einer Menge \texttt{T}
      in Elemente einer Menge \texttt{S} umgewandelt werden können.
      Abbildung
      \ref{fig:Transformer.java} zeigt das Interface \texttt{Transformer}.

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public interface Transformer<S extends Comparable<? super S>, 
                                 T extends Comparable<? super T>> 
    {
        public S transform(T x);
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Das Interface \texttt{Transformer}.}
\label{fig:Transformer.java}
\end{figure}

\item Die Methode $\textsl{combineSets}(s_1, s_2, k)$ verknüpft zwei Mengen 
      mit einem \emph{Kombinator} $k$.  Es gilt
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{combineSets}(s_1, s_2, k) = 
      \bigl\{ k.\textsl{combine}(x,y) \mid x \in s_1 \wedge y \in s_2 \bigr\}$
      \\[0.2cm]
      Ein \emph{Kombinator} ist  ein Objekt, dass eine Methode
      $\textsl{combine}()$ zur Verfügung stellt, mit dem zwei Elemente 
      verknüpft werden können.
      Abbildung
      \ref{fig:Combinator.java} zeigt das Interface \texttt{Combinator}.

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public interface Combinator<T, X, Y>
    {
        public T combine(X x, Y y);
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Das Interface \texttt{Combinator}.}
\label{fig:Combinator.java}
\end{figure}
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class Pair<S extends Comparable<? super S>, 
                      T extends Comparable<? super T>> 
        implements Comparable<Pair<S,T>>
    {
        S mFirst;
        T mSecond;
        
        public Pair(S first, T second) {
            mFirst  = first;
            mSecond = second;
        }
        public int compareTo(Pair<S, T> pair) {
            int cmpFirst = mFirst.compareTo(pair.getFirst());
            if (cmpFirst < 0 || cmpFirst > 0) {
                return cmpFirst;
            }
            return mSecond.compareTo(pair.getSecond());
        }
        public String toString() {
            return "<" + mFirst + ", " + mSecond + ">";
        }
        public S getFirst()  { return mFirst;  }
        public T getSecond() { return mSecond; }
    
        public void setFirst(S first) { 
            mFirst = first; 
        }
        public void setSecond(T second) { 
            mSecond = second; 
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{Pair}.}
\label{fig:Pair.java}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class ComparableList<T extends Comparable<? super T>> 
        extends LinkedList<T>
        implements Comparable<ComparableList<T>>
    {
        public int compareTo(ComparableList<T> comparableList) { 
            Iterator<T> iterFirst  = iterator();
            Iterator<T> iterSecond = comparableList.iterator();
            while (iterFirst.hasNext() && iterSecond.hasNext()) {
                T   first  = iterFirst .next();
                T   second = iterSecond.next();
                int cmp    = first.compareTo(second);
                if (cmp == 0) {
                    continue;
                }
                return cmp;
            }
            if (iterFirst.hasNext()) {
                return 1;
            }       
            if (iterSecond.hasNext()) {
                return -1;
            }
            return 0;
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{ComparableList}.}
\label{fig:ComparableList.java}
\end{figure}

\subsection{Die Klasse \texttt{ComparableList}}
Nachdem wir nun mit Mengen so arbeiten können, wie wir dass in dr Sprache \textsc{SetlX} gewohnt sind,
benötigen wir als nächstes eine Klasse \texttt{ComparableList}, die Listen darstellt und außerdem das
Interface \texttt{Comparable} implementiert.  Die Implementierung dieser Klasse ist in Abbildung
\ref{fig:ComparableList.java} auf Seite \pageref{fig:ComparableList.java} gezeigt.  Bei der Lösung des
Wolf-Ziege-Kohl-Problems haben wir Listen nur benötigt, um die verschiedenen Pfade in einem Graphen
darzustellen.  Wir haben keine Operationen benutzt die Listen manipulieren.  Daher reicht es für dieses
Beispiel aus, wenn wir die Klasse \texttt{ComparableList} von \texttt{LinkedList} ableiten.  In diesem
Fall muss nur die Methode $\textsl{compareTo}()$ implementiert werden.  Dies geschieht ähnlich wie bei
Mengen über einen lexikografischen Vergleich der beiden Listen.

\subsection{Lösung des Wolf-Ziege-Kohl-Problems in \textsl{Java}}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    #define Point     ComparableSet<String>
    #define PointPair Pair<Point, Point>
    
    public class WolfZiegeKohl 
    {    
        public static void main(String args[]) {
            Point all = new Point();
            all.add("Bauer");
            all.add("Wolf");
            all.add("Ziege");
            all.add("Kohl");
            ComparableSet<Point> p = all.powerSet();
            ComparableSet<PointPair> r = new ComparableSet<PointPair>();
            for (Point s: p) {
                for (Point b : s.powerSet()) {
                    Point sb = s.difference(b);
                    if (b.member("Bauer") && b.size() <= 2 && !problem(sb)) 
                    {
                        PointPair ssb = new PointPair(s, sb);
                        r.add(ssb); 
                    }
                }
            }
            for (Point s: p) {
                Point as = all.difference(s);
                for (Point b : as.powerSet()) {
                    if (b.member("Bauer") && b.size() <= 2 && 
                        !problem(as.difference(b))           ) 
                    {
                        Point sb = s.union(b);
                        PointPair ssb = new PointPair(s, sb);
                        r.add(ssb); 
                    }
                }
            }
            Point goal = new Point();
            Relation<Point> relation = new Relation(r);
            ComparableList<Point> path = relation.findPath(all, goal);
            for (Point left : path) {
                Point right = all.difference(left);
                System.out.println(left + ", " + right);
            }
        }
        static boolean problem(Point s) {
            return (s.member("Ziege") && s.member("Kohl")) || 
                   (s.member("Wolf") && s.member("Ziege"));
        }
    }   
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Lösung des Wolf-Ziege-Kohl-Problems.}
\label{fig:WolfZiegeKohl.jpre}
\end{figure}


\noindent
Nach dem wir uns im letzten Abschnitt einen Rahmen geschaffen haben, in dem konzeptionell
dieselben Funktionen wie in \textsc{SetlX} zur Verfügung stehen, können wir nun daran
gehen, das im ersten Semester entwickelte \textsc{SetlX}-Programm in \textsl{Java} zu übersetzen.
Abbildung \ref{fig:WolfZiegeKohl.jpre} zeigt das Ergebnis dieser Übersetzung.
\begin{enumerate}
\item In den ersten beiden Zeilen definieren wir zwei Abkürzungen.  Zum einen möchten wir
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{Point} \quad als Abkürzung für \quad \texttt{ComparableSet<String>}
      \\[0.2cm]
      benutzen, zum anderen steht
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{PointPair} \quad als Abkürzung für \quad \texttt{Pair<Point, Point>}.
      \\[0.2cm]
      Durch die Verwendung dieser Abkürzungen ersparen wir es uns, später mit
      unlesbaren Klassenbezeichnungen der Form
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{ComparableSet<Pair<ComparableSet<String>, ComparableSet<String>>>}
      \\[0.2cm]
      arbeiten zu müssen.  Leider gibt es in der Sprache \textsl{Java} (im Gegensatz zu der
      Sprache \texttt{C\#}) keine
      Möglichkeit, Abkürzungen zu definieren, denn ein zu einem \texttt{typedef} analoges
      Konstrukt, wie Sie es beispielsweise in der Sprache \texttt{C} finden,
      gibt es in \textsl{Java} nicht.  Wir behelfen uns mit einem Trick und verwenden den
      \texttt{C}-Präprozessor, denn dieser kann Makros expandieren.  Daher haben wir in
      den ersten beiden Zeilen die entsprechenden Abkürzungen mit Hilfe der
      Präprozessor-Direktive ``\texttt{\#define}'' definiert.
      Um diese Abkürzungen expandieren zu können, speichern wir das in Abbildung
      \ref{fig:WolfZiegeKohl.jpre} gezeigte Programm in einer Datei mit dem Namen
      \texttt{WolfZiegeKohl.jpre} und rufen dann den \texttt{C}-Präprozessor mit dem Befehl
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{cpp -P WolfZiegeKohl.jpre WolfZiegeKohl.java}
      \\[0.2cm]
      auf.  Dieser Befehl expandiert die Makro-Definitionen und schreibt das Ergebnis in
      die Datei \texttt{WolfZiegeKohl.java}.  Die Option ``\texttt{-P}'' ist hier
      notwendig um die Zeilenmarkierungen, die andernfalls vom Präprozessor erzeugt
      würden, zu unterdrücken. 
\item Die Klasse \texttt{WolfZiegeKohl} enthält nur die Methode $\textsl{main}()$.
      Diese Methode löst das Problem und gibt die Lösung (allerdings sehr spartanisch) aus.
      Zunächst bilden wir dort die Menge  \texttt{all}, die die Strings
      ``\texttt{Bauer}'',
      ``\texttt{Wolf}'',
      ``\texttt{Ziege}'',
      ``\texttt{Kohl}'' enthält.
\item Die Menge \texttt{p} ist die Potenz-Menge von \texttt{all}.  
\item Die Menge \texttt{r} beschreibt die Zustandsübergangsrelation.
      Diese Relation wird in den beiden \texttt{for}-Schleifen in den Zeilen
      14 -- 23 und 24 -- 35 berechnet.
      Die erste \texttt{for}-Schleife berechnet die Übergänge, bei denen
      das Boot von links nach rechts übersetzt.  Mathematisch können diese Übergänge wie
      folgt zu einer Relation zusammen gefaßt werden:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\bigl\{ \pair(s, s - b) \colon s \in p, b \in  2^s \mid
               \mathtt{\symbol{34}bauer\symbol{34}} \in b \wedge \#b \leq 2 \wedge \neg
               \textsl{problem}(s - b) \}$
      \\[0.2cm]
      Die Variable $s$ ist hier die Menge der Objekte am linken Ufer und ist daher ein
      Element der Menge $p$, denn $p$ ist ja die Potenz-Menge von \texttt{all}.  Die
      Variable $b$ bezeichnet die Menge der Objekte, die im Boot vom linken Ufer zum
      rechten Ufer übersetzen.  Diese Menge ist eine
      Teilmenge von $s$ und damit ein Element der Potenz-Menge von $s$.  
      Die Menge \texttt{sb} besteht
      aus den Objekten, die nach der Überfahrt am linken Ufer verbleiben.
      Das ist gerade die Mengendifferenz $s \backslash b$.  
      
      Damit eine Überfahrt legal ist, müssen folgende Bedingungen erfüllt sein:
      \begin{enumerate}
      \item Der Bauer muss im Boot sitzen: 
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{b.member(\symbol{34}Bauer\symbol{34})}.
      \item Im Boot dürfen sich maximal zwei Objekte befinden:
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{b.size() <= 2}
      \item Es darf nach der Überfahrt am linken Ufer kein Problem geben:
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{!problem(sb)}
      \end{enumerate}
      Diese Bedingungen werden durch die \texttt{if}-Abfrage in Zeile 17 sichergestellt.
      Wenn die Bedingungen erfüllt sind, wird das Paar $\pair(\mathtt{s}, \mathtt{sb})$
      der Relation $r$ hinzugefügt.
\item Die Übergänge, bei denen das Boot von rechts nach links fährt, werden analog
      berechnet.  Mathematisch hat diese Relation die Form
      \\[0.2cm]
      \hspace*{1.3cm}
      $\bigl\{ \pair(s, s + b) \colon s \in p, b \in 2^{\mathtt{all} \backslash s} \mid
              \mathtt{\symbol{34}Bauer\symbol{34}} \in b \wedge \#B \leq 2 \wedge \neg
              \mathtt{problem}((\mathtt{all} \backslash s) \backslash b) 
       \bigr\}
      $.
      \\[0.2cm]
      Da $s$ wieder die Menge der Objekte am linken Ufer ist, finden wir die Menge der Objekte
      am rechten Ufer, indem wir die Menge $\mathtt{all} \backslash s$ bilden.  Diese
      Menge wird im Programm mit \texttt{as} bezeichnet.  Das Boot, also die Menge der
      Objekte, die von rechts nach links übersetzen, ist daher nun eine Teilmenge von \texttt{as}.
      Der Rest der Rechnung ist nun analog zum ersten Fall.
\item Anschließend wird in Zeil 36 der Zielzustand definiert:
      Am Ende sollen alle Objekte am rechten Ufer sein.  Links ist dann niemand mehr,
      folglich ist die entsprechende Menge leer.  Da der Aufruf
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{new Point()}
      \\[0.2cm]
      vom Präprozessor zu
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{ComparableSet<String>()}
      \\[0.2cm]
      expandiert wird, wird in Zeile 36 als Zielzustand tatsächlich die leere Menge
      berechnet.
\item Die Zuweisung ``\texttt{relation = new Relation(r)}'' wandelt nun die Menge von
      Paaren von Zuständen in ein Objekt der Klasse \texttt{Relation} um, die es uns
      über den Aufruf von $\textsl{findPath}()$ ermöglicht, einen Weg vom Start
      zum Ziel zu berechnen.  
\item Die Methode $\textsl{problem}(s)$ überprüft für eine gegebene Menge von Objekten,
      ob es zu einem Problem kommt, weil entweder die Ziege den Kohl oder der Wolf die
      Ziege frißt.
\end{enumerate}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    public class Relation<E extends Comparable<? super E>>
    {
        ComparableSet<Pair<E, E>> mR;
        
        public Relation(ComparableSet<Pair<E, E>> r) { mR = r; }
    
        public ComparableList<E> findPath(E start, E goal) {
            ComparableList<E> first = new ComparableList<E>();
            first.add(start);
            ComparableSet<ComparableList<E>> p    = ComparableSet.singleton(first);
            ComparableSet<ComparableList<E>> oldP = null;
            while (true) {
                oldP = p;
                p    = p.union(pathProduct(p));
                for (ComparableList<E> l : p) {
                    if (l.getLast().compareTo(goal) == 0) {
                        return l;
                    }
                }
                if (p.compareTo(oldP) == 0) {
                    return null;
                } 
            }
        }
        private ComparableSet<ComparableList<E>> 
            pathProduct(ComparableSet<ComparableList<E>> P) 
        {
            ComparableSet<ComparableList<E>> result = 
                new ComparableSet<ComparableList<E>>();
            for (ComparableList<E> p : P) {
                for (Pair<E, E> q : mR) {
                    if (p.getLast().compareTo(q.getFirst()) == 0) {
                        ComparableList<E> pq = new ComparableList<E>(p);
                        E second = q.getSecond();
                        pq.add(second);
                        if (!cyclic(pq)) {
                            result.add(pq);
                        }
                    }
                }
            }
            return result;
        }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{Relation}.}
\label{fig:Relation.java}
\end{figure}

\noindent
Als letztes diskutieren wir die Implementierung der Klasse \texttt{Relation}.
Diese Klasse verwaltet eine Menge von Paaren, die einen Graphen repräsentiert.
Diese Klasse stellt drei Methoden zur Verfügung.
\begin{enumerate}
\item Die Methode $r.\mathtt{findPath}(x,y)$ berechnet einen Pfad, der von dem Punkt $x$
      zu dem Punkt $y$ führt.
\item Die Methode $R.\textsl{pathProduct}(P)$ berechnet für eine Relation $R$ und
      eine Menge von Pfaden $P$ das sogenannte Pfad-Produkt $P \bullet R$, das für eine Relation $R$
      und eine Menge von Pfaden $P$ wie folgt definiert ist:
      \[ 
         P \bullet R = \bigl\{\; l + [y] \mid 
         l \in P \wedge \pair(x,y) \in R \wedge \textsl{last}(l) = x \;\bigr\}.
      \]
      Für einen Pfad $p$ bezeichnet dabei $\textsl{last}(p)$ den letzten Punkt des
      Pfades.  Anschaulich gesehen werden bei der Berechnung von $P \bullet R$
      die Pfade aus $P$ um die Relation $R$ verlängert:  Wenn einerseits eine Liste $l$ aus
      $P$ mit einem Punkt $x$ endet und wenn andererseits die Relation $R$
      ein Paar der Form $\pair(x, y)$ enthält, dann kann das Element $y$ an die Liste $l$
      angehängt werden.
\item Die Methode $\textsl{cyclic}()$ überprüft für eine gegebene Liste $l$, ob diese
      Liste ein Element mehrfach enthält und damit einen zyklischen Pfad darstellt.
      Um dies zu prüfen wird die Liste in eine Menge umgewandelt.  Wenn die Menge genauso
      viele Elemente enthält wie die Liste, dann kann die Liste kein Element doppelt
      enthalten haben und ist damit nicht zyklisch.
\end{enumerate}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = last,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
        private static <T extends Comparable<? super T>>
                boolean cyclic(ComparableList<T> l) 
        {
            ComparableSet<T> all = new ComparableSet<T>();
            for (T x : l) {
                all.add(x);
            }
            return all.size() < l.size();
        }        
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Methode $\textsl{cyclic}()$.}
\label{fig:cyclic.java}
\end{figure}
      
\vspace*{\fill}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "algorithmen"
%%% End: 
