\chapter{Abstrakte Daten-Typen und elementare Daten-Stukturen}
Ähnlich wie der Begriff des Algorithmus von bestimmten Details eines Programms
abstrahiert, abstrahiert der Begriff des \emph{abstrakten Daten-Typs} von bestimmten
Details konkreter Daten-Stukturen.  Durch die Verwendung dieses Begriffs wird es
möglich, Algorithmen von den zugrunde liegenden Daten-Stukturen zu trennen.
Wir geben im nächsten Abschnitt eine Definition von abstrakten Daten-Typen und
illustrieren das Konzept im folgenden Abschnitt an Hand von dem abstrakten Daten-Typ \textsl{Stack}.
Im zweiten Abschnitt zeigen wir, wie die Sprache \textsl{Java} die
Verwendung abstrakter Daten-Typen unterstützt.  In den folgenden Abschnitten betrachten
wir verschiedene Implementierungen des abstrakten Daten-Typs \textsl{Stack}.
Anschließend zeigen wir, wie sich arithmetische Ausdrücke mit Hilfe eines Stacks
auswerten lassen.
Im vorletzten Abschnitt diskutieren wir den Nutzen, den die Verwendung abstrakter
Daten-Typen hat. 

\section{Abstrakte Daten-Typen}
Formal definieren wir einen \emph{abstrakter Daten-Typ} als ein Tupel der Form
 $\langle T, P, Fz, Ts, Ax \rangle$.
Die einzelnen Komponenten dieses Tupels haben dabei die folgende Bedeutung.
\begin{enumerate}
\item $T$ ist der \emph{Name} des abstrakten Daten-Typs.
\item $P$ ist die Menge der verwendeten \emph{Typ-Parameter}.  Ein Typ-Parameter ist dabei
      einfach ein String.  Diesen String interpretieren wir als Typ-Variable,
      d.h.~wir können später für diesen String den Namen eines Daten-Typen einsetzen.
\item $\textsl{Fz}$ ist eine Menge von \emph{Funktions-Zeichen}.  Diese Funktions-Zeichen
      sind die Namen der Operationen, die der abstrakte Daten-Typ zur Vefrügung stellt,
\item $\textsl{Ts}$ ist eine Menge von \emph{Typ-Spezifikation}, die zu jedem Funktions-Zeichen
      $f \in \textsl{Fz}$
      eine \emph{Typ-Spezifikation} der Form \\[0.1cm]
      \hspace*{1.3cm} 
      $f: T_1 \times \cdots \times T_n \rightarrow S$. \\[0.1cm]
      enthält. Dabei sind $T_1$, $\cdots$, $T_n$ und $S$ Namen von 
      Daten-Typen.  Hier gibt es drei Möglichkeiten: 
      \begin{enumerate}
      \item Die Namen konkreter Daten-Typen, wie z.~B.~``\texttt{int}'' 
            oder ``\texttt{String}''.
      \item Die Namen abstrakter Daten-Typen.
      \item Ein Typ-Parameter aus der Menge $P$.
      \end{enumerate}
      Die Typ-Spezifikation $f: T_1 \times \cdots \times T_n \rightarrow S$ drückt aus, dass die
      Funktion $f$ in der Form \\[0.1cm] 
      \hspace*{1.3cm} $f(t_1,\cdots,t_n)$ \\[0.1cm]
      aufgerufen wird und dass für $i=1,\cdots,n$ das Argument $t_i$ vom Typ
      $T_i$ sein muss.  Außerdem sagt die Typ-Spezifikation aus, dass das
      Ergebnis, das von der Funktion $f$ berechnet wird, immer vom Typ $S$ ist.

      Zusätzlich fordern wir, dass entweder $T_1 = T$ ist, oder aber $S = T$
      gilt.  Es soll also entweder das erste Argument der Funktion $f$ den Wert
      $T$ haben, oder der Typ des von $f$ berechneten Ergebnisses soll gleich
      $T$ sein. Falls $T_1 \not= T$ ist (und damit zwangsläufig $S = T$ gilt),
      dann nennen wir die Funktion $f$ auch einen \emph{Konstruktor} des
      Daten-Typs $T$, andernfalls bezeichnen wir $f$ als \emph{Methode}.
\item $Ax$ ist eine Menge von prädikaten-logischen Formeln, die das Verhalten 
      des abstrakten Daten-Typs beschreiben.  Diese Formeln bezeichnen wir auch
      als die \emph{Axiome} des Daten-Typs.
\end{enumerate}
Wir geben sofort ein einfaches Beispiel für einen abstrakten Daten-Typ: den
\emph{Keller} (engl. \emph{stack}).  Einen Keller kann man sich anschaulich als
einen Stapel von  Elementen eines bestimmten Typs vorstellen, die aufeinander
gelegt werden, ähnlich wie die Teller in der Essensausgabe einer Kantine.  Dort
werden Teller immer oben auf den Stapel gelegt und in umgekehrter Reihenfolge
wieder vom Stapel entfernt.  Insbesondere ist es nicht möglich, einen Teller aus
der Mitte des Stapels zu entfernen.
Formal definieren wir den Daten-Typ des \emph{Kellers}
wie folgt:
\begin{enumerate}
\item Als Namen wählen wir \textsl{Stack}.
\item Die Menge der Typ-Parameter ist $\{ \textsl{Element} \}$.
\item Die Menge der Funktions-Zeichen ist \\[0.1cm]
      \hspace*{1.3cm} 
      $\bigl\{ \textsl{Stack}, \textsl{push}, \textsl{pop}, \textsl{top}, \textsl{isEmpty} \bigr\}$.
\item Die Typ-Spezifikationen der Funktions-Zeichen sind wie folgt:
      \begin{enumerate}
      \item $\textsl{Stack}: \textsl{Stack}$

            Links von dem Doppelpunkt steht hier die Funktion mit dem Namen
            \textsl{Stack}, rechts steht der Name des ADT.  In den gängigen
            Programmier-Sprachen (\textsl{Java}, \texttt{C++}, etc.) 
            werden bestimmte Funktionen mit dem selben Namen bezeichnet wie der zugehörige
            ADT.  Solche Funktionenen heißen Konstruktoren.  Der Rückgabe-Wert eines
            Konstruktors hat immer den Typ des ADT.

            Der Konstruktor $\textsl{Stack}$ kommt ohne Eingabe-Argumente aus.  Ein
            solcher Konstruktor wird auch als der \emph{Default-Konstruktor} bezeichnet.
            
            Der Aufruf $\textsl{Stack}()$ erzeugt einen neuen, leeren Stack.
      \item $\textsl{push}: \textsl{Stack} \times \textsl{Element} \rightarrow \textsl{Stack}$

            Der Aufruf $\textsl{push}(S,x)$ legt das Element $x$ oben auf den Stack $S$.
            Wir werden im folgenden eine Objekt-orientierte Schreibweise verwenden und
            den Aufruf  $\textsl{push}(S,x)$ als $S.\textsl{push}(x)$ schreiben.
      \item $\textsl{pop}: \textsl{Stack}  \rightarrow \textsl{Stack}$

            Der Aufruf $S.\textsl{pop}()$ entfernt das oberste Element von dem Stack $S$.
      \item $\textsl{top}: \textsl{Stack} \rightarrow \textsl{Element}$

            Der Aufruf $S.\textsl{top}()$ liefert das auf dem Stack $S$ zuoberst liegende Element. 
      \item $\textsl{isEmpty}: \textsl{Stack} \rightarrow \mathbb{B}$

            Der Aufruf $S.\textsl{isEmpty}()$ testet, ob der Stack $S$ leer ist.
      \end{enumerate}
\end{enumerate}
Die Anschauung, die dem  Begriff des Stacks zu Grunde liegt, wird durch die folgenden Axiome
erfaßt:
\begin{enumerate}
\item $\textsl{Stack}().\textsl{top}() = \Omega$

      Hier bezeichnet $\Omega$ den undefinierten Wert.  Der Aufruf $\textsl{Stack}()$
      liefert zunächst einen leeren Stack.  Das Axiom drückt also aus,
      das ein leerer Stack kein oberstes Element hat.
\item $S.\textsl{push}(x).\textsl{top}() = x$

      Legen wir auf den Stack $S$ mit $S.\textsl{push}(x)$ ein Element $x$, so 
      ist $x$ das oberste Element, was auf dem neu erhaltenen Stack liegt.
\item $\textsl{Stack}().\textsl{pop}() = \Omega$

      Der Versuch, von einem leeren Stack das oberste Element zu entfernen,
      liefert ein undefiniertes Ergebnis.
\item $S.\textsl{push}(x).\textsl{pop}() = S$

      Wenn wir auf den Stack $S$
      ein Element legen, und anschließend von dem resultierenden Stack das
      oberste Element wieder herunter nehmen, dann erhalten wir den
      ursprünglichen Stack $S$, mit dem wir gestartet sind.
\item $\textsl{Stack}().\textsl{isEmpty}() = \mathtt{true}$

      Erzeugen wir mit $\textsl{Stack}()$ einen neuen Stack, so ist dieser
      zunächst leer.
\item $S.\textsl{push}(x).\textsl{isEmpty}() = \mathtt{false}$

      Legen wir ein Element $x$ auf einen Stack $S$, so kann der Stack $S$
      danach nicht leer sein.
\end{enumerate}
Beim Betrachten der Axiome lässt sich eine gewisse Systematik erkennen.
Bezeichnen wir die Funktionen \texttt{Stack} und \texttt{push} als Generatoren
so geben die Axiome das Verhalten der restlichen Funktionen auf den von den Generatoren
erzeugten Stacks an. 

Stacks spielen in vielen Bereichen der Informatik eine wichtige Rolle.  Es gibt
sogar Stack-basierte Programmier-Sprachen: Dort müssen bei einem
Funktions-Aufruf alle Argumente zunächst auf einen Stack gelegt werden.  Die
aufrufende Funktion nimmt dann ihre Argumente vom Stack und legt das berechnete
Ergebnis wieder auf den Stack.  Die Sprache \textsl{PostScript} funktioniert
nach diesem Prinzip.  Die Sprache \textsl{Java} wird in einen \emph{Byte-Code}
übersetzt, der von der \emph{Java Virtual Machine} (kurz JVM) interpretiert
wird.  Die JVM ist ebenfalls stack-basiert.

Wir werden später noch sehen, wie  arithmetische Ausdrücke mit Hilfe
eines Stacks ausgewertet werden können. Vorher zeigen wir, wie sich der
abstrakte Daten-Typ des Stacks in der Programmier-Sprache \textsl{Java}
implementieren lässt.

\section{Darstellung abstrakter Daten-Typen in \textsl{Java}}
In \textsl{Java} können abstrakte Daten-Typen entweder durch ein \emph{Interface} oder
durch eine \emph{abstrakte Klasse} repräsentiert werden.   Für den Stack wählen wir die Darstellung
durch eine abstrakte Klasse, die in Abbildung \ref{fig:stack.java} auf Seite
\pageref{fig:stack.java} gezeigt wird.   Die Darstellung durch eine abstrakte Klasse ist
insofern flexibler, als wir hier die Möglichkeit haben, Methoden, die sich
bereits auf der Abstraktions-Ebene des ADT realisieren lassen, zu implementieren.

\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm
                ]
    public abstract class Stack<Element> implements Cloneable
    {
        public abstract void    push(Element e);
        public abstract void    pop();
        public abstract Element top();
        public abstract boolean isEmpty();
    
        public Stack<Element> clone() throws CloneNotSupportedException {    
            return (Stack<Element>) super.clone();
        }

        public final String toString() {
            Stack<Element> copy;
            try {
                copy = clone();
            } catch (CloneNotSupportedException e) {
                return "*** ERROR ***";
            }       
            String result = copy.convert();
            String dashes = "\n";
            for (int i = 0; i < result.length(); ++i) {
                dashes = dashes + "-";
            }
            return dashes + "\n" + result + dashes + "\n";
        }
    
        private String convert() {
            if (isEmpty()) {
                return "|";
            } else {
                Element top = top();
                pop();
                return convert() + " " + top + " |";
            }
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{darstellung des ADT-Stack in \textsl{Java}.}
  \label{fig:stack.java}
\end{figure} 

Wir diskutieren die Darstellung des ADT Stack in Java nun Zeile für Zeile.
\begin{enumerate}
\item In der ersten Zeile deklarieren wir die Klasse \texttt{Stack<Element>} als
      \emph{abstrakt}.  Das Schlüsselwort \texttt{abstract} drückt dabei aus,
      das wir in dieser Klasse lediglich die Signaturen der Methoden angeben,
      die Implementierungen der Methoden werden in der abstrakten Klasse
      nicht angegeben.

      Der Name der Klasse ist \texttt{Stack<Element>}.  Die Typ-Parameter des ADT 
      sind hier in spitzen Klammern eingefaßt.  Wenn es mehr als einen Typ-Parameter gibt,
      dann müssen diese durch Kommata getrennt werden.
      
      Durch  ``\texttt{implements Cloneable}'' drücken wir aus, 
      dass Objekte der Klasse \texttt{Stack<Element>} geklont, d.h.~kopiert werden können.
\item Zeile 3 enthält die Typ-Spezifikationen der Method \texttt{push}.
      Oben hatten wir diese Typ-Spezifikation als \\[0.1cm]
      \hspace*{1.3cm} 
      $\mathtt{push}: \mathtt{Stack} \times \mathtt{Element} \rightarrow \mathtt{Stack}$
      \\[0.1cm]
      angegeben, in \textsl{Java} hat diese Typ-Spezifikation die Form \\[0.1cm]
      \hspace*{1.3cm} \texttt{void push(Element e);} \\[0.1cm]
      Hier fallen zwei Dinge auf:
      \begin{enumerate}
      \item In \textsl{Java} hat die Methode \texttt{push} ein Argument,
            während sie in der Definition des ADT zwei Argumente hat.

            In Java wird das erste Argument unterdrückt, denn dieses Argument ist bei
            jeder Methode vorhanden und hat den Wert Stack.  Dieses Argument wird daher
            auch als \emph{implizites Argument} bezeichnet.  Diesem Umstand wird auch
            durch die Syntax eines Methoden-Aufrufs Rechnung getragen.  Wir schreiben \\[0.1cm]
            \hspace*{1.3cm} $s.\mathtt{push}(e)$ \\[0.1cm]
            an Stelle von $\mathtt{push}(s,e)$.
      \item Der Rückgabe-Typ von \texttt{push} ist als \texttt{void} deklariert und nicht
            als \texttt{Stack<Element>}.  Der Grund ist, dass ein Aufruf der Form \\[0.1cm]
            \hspace*{1.3cm} $s.\mathtt{push}(e)$
            \\[0.1cm]
            nicht einen neuen Stack berechnet, sondern den Stack $s$, der als als
            implizites erstes Argument der Methode verwendet wird, verändert.
      \end{enumerate}
\item Die Zeilen 4 -- 6 enthalten die Typ-Spezifikationen der restlichen Methoden.
\item Die Zeilen 8 -- 10 enthält die Definition einer Methode \texttt{clone()}.
      Diese Methode ermöglicht es, einen Klon (also eine Kopie) eines Objektes vom Typ
      \texttt{Stack} zu erzeugen.  Die Implementierung diskutieren wir später.
\item In den Zeilen 12 -- 25 definieren wir die Methode \texttt{toString()}, mit der wir
      ein Objekt vom Daten-Typ \texttt{Stack} in einen String umwandeln können.  Um die
      Implementierung dieser Methode zu verstehen, betrachten wir zunächst die Wirkung
      dieser Methode an Hand des folgenden Beispiels: 
      \begin{verbatim}
      Stack<Element> stack = new Stack<Element>();
      stack.push(1);
      stack.push(2);
      stack.push(3);
      stack.toString();
      \end{verbatim}
      \vspace*{-0.5cm}

      Dann hat der Ausdruck \texttt{stack.toString()} den folgenden Wert:
      \begin{verbatim}
      -------------
      | 1 | 2 | 3 |
      -------------
      \end{verbatim}
      \vspace*{-0.5cm}
      Bei dieser Darstellung ist das oberste Element des Stacks also das Element, was am
      weitesten rechts liegt.

      Die Implementierung der Methode \texttt{toString} verläuft in drei Schritten.
      \begin{enumerate}
      \item Zunächst erzeugen wir mit Hilfe der Methode \texttt{clone()} eine Kopie des
            Stacks.  Das ist deswegen notwendig, weil wir mit der Methode \texttt{top()}
            ja immer nur das erste Element des Stacks anschauen können.  Um das zweite
            Element zu bekommen, müssen wir vorher das erste Element vom Stack herunter
            nehmen.  Das geht mit der Operation \texttt{pop()}.  Die Methode
            \texttt{toString()} soll aber den Stack selbst nicht verändern.  Also kopieren
            wir vorher den Stack und ändern dann die Kopie.

            Beim Ausführen der Methode \texttt{clone()} könnte es Probleme geben, es
            könnte eine \emph{Exception} (Ausnahme) ausgelöst werden.  Die Ausnahme
            fangen wir durch den \texttt{try}-\texttt{catch}-Block in den Zeilen 14 -- 18
            ab und geben in diesem Fall als Ergebnis eine Fehlermeldung zurück.
      \item Die Hilfs-Methode \texttt{convert()} berechnet einen String der Form \\[0.1cm]
            \hspace*{1.3cm} \texttt{| 1 | 2 | 3 |}. \\[0.1cm]
            Hierzu wird mit der \texttt{if}-Abfrage in Zeile 28 eine Fallunterscheidung 
            durchgeführt: Falls der Stack leer ist, so ist das Ergebnis einfach nur der
            String ``\texttt{|}''.  Andernfalls fragen wir das oberste Element des Stacks
            mit dem Aufruf \texttt{top()} in 31 ab, entfernen es durch einen Aufruf von
            \texttt{pop()} vom Stack und rufen anschließend für den so verkleinerten Stack
            rekursiv die Methode \texttt{toString()} auf.  Das oberste Element des
            ursprünglichen Stacks wird dann hinten an das Ergebnis des rekursiven Aufrufs gehängt.
      \item Um zum Schluß noch die Linien darüber und darunter zu zeichnen, erzeugen wir
            in der \texttt{for}-Schleife in Zeile 21 -- 23 eine Linie der erforderlichen
            Länge und verketten diese mit dem von \texttt{convert()} gelieferten String.
      \end{enumerate}
\end{enumerate}
Beachten Sie, dass wir für Stacks die Methode \texttt{toString()} implementieren konnten ohne etwas
darüber zu wissen, wie die Stacks überhaupt implementiert werden.  Dies ist der
wesentliche Vorteil des Konzeptes des ADT: Der Begriff des ADT abstrahiert von den Details der
Implementierung und bietet damit eine Schnittstelle zu Stacks, die einfacher zu bedienen
ist, als wenn wir uns mit allen Details auseinander setzen müßten.  Ein weiterer
wesentlicher Vorteil ist die Austauschbarkeit konkreter Implementierungen des Stacks.  
Wir werden später verschiedene konkrete
Implementierungen des ADT \texttt{Stack} entwickeln.  Da die Methode \texttt{toString} auf
der abstrakten Ebene entwickelt worden ist, ist sie von den Details einer solchen konkreten
Implementierung unabhängig!


\section{Implementierung eines Stacks mit Hilfe eines \emph{Arrays}}
Eine Möglichkeit, einen Stack zu implementieren, besteht darin,
die in einem Stack abgelegten Elemente in einem Feld abzuspeichern. 
Zusätzlich wird dann noch eine Zeiger benötigt, der auf das oberste Element des Stacks 
zeigt. 
Abbildung \ref{fig:ArrayStack.java} auf Seite \pageref{fig:ArrayStack.java} zeigt eine solche
 Implementierung.

\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    public class ArrayStack<Element> extends Stack<Element>
    {
        Element[] mArray;  // abgespeicherte Elemente
        int       mIndex;  // Index der nächsten freien Stele in mArray
    
        public ArrayStack() {
            mArray = (Element[]) new Object[1];
            mIndex = 0;
        }        
        public void push(Element e) {
            int size = mArray.length;
            if (mIndex == size) {
                Element[] newArray = (Element[]) new Object[2 * size];
                for (int i = 0; i < size; ++i) {
                    newArray[i] = mArray[i];
                }
                mArray = newArray;
            }
            mArray[mIndex] = e;
            ++mIndex;
        }
        public void pop() {
            assert mIndex > 0 : "Stack underflow!";
            --mIndex;
        }    
        public Element top() {
            assert mIndex > 0 : "Stack is empty!";
            return (Element) mArray[mIndex - 1];
        }
        public boolean isEmpty() {
            return mIndex == 0;
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Array-basierte Implementierung eines Stacks.}
  \label{fig:ArrayStack.java}
\end{figure} 

\begin{enumerate}
\item Durch ``\texttt{extends Stack<Element>}'' deklarieren wir, dass die Klasse
      \texttt{ArrayStack<Element>} den abstrakten Daten-Typ \texttt{Stack<Element>}
      implementiert.
\item Die Daten-Struktur wird durch zwei Member-Variablen realisiert:
      \begin{enumerate}
      \item Die in Zeile 3 definierte Variable \texttt{mArray} bezeichnet das Feld,
            in dem die einzelnen Elemente, die auf den Stack geschoben werden,
            abgespeichert werden.
      \item Die in Zeile 4 definierte Variable \texttt{mIndex} gibt den Index in dem Feld
            \texttt{mArray} an, an dem das nächste Element abgelegt werden kann.
      \end{enumerate}
      Ich habe mir angewöhnt, jede Member-Variable mit dem Buchstaben \texttt{m}
      anfangen zu lassen.  Durch diese Konvention lassen sich Member-Variablen später einfach von
      den lokalen Variablen einer Methode unterscheiden.
\item In dem Konstruktor legen wir in Zeile 7 das Feld \texttt{mArray} mit einer
      Größe von 1 an und initialisieren die Variable \texttt{mIndex} mit 0, denn 
      0 ist der erste freie Index in diesem Feld.
\item Bei der Implementierung der Methode $\texttt{push}(e)$ überprüfen wir zunächst
      in Zeile 12, ob in dem Feld noch Platz vorhanden ist um
      ein weiteres Element abzuspeichern.  Falls dies nicht der Fall ist, 
      legen wir in Zeile 13  ein neues Feld an, das doppelt so groß ist wie das alte Feld.
      Anschließend kopieren wir in der \texttt{for}-Schleife in den Zeilen 14 -- 16
      die Elemente aus dem alten Feld in das neue Feld und setzen dann die 
      Variable \texttt{mArray} auf das neue Feld.  Der \emph{Garbage-Collector} der 
      \textsl{Java Virtual Machine}  sorgt jetzt dafür,
      dass der Speicher, der für das alte Feld allokiert worden war, 
      wieder verwendet werden kann.
      
      Anschließend speichern wir das Element $e$ an der durch \texttt{mIndex}
      angegebenen Stelle ab und erhöhen die Variable \texttt{mIndex}, so dass diese jetzt 
      wieder auf den nächsten freien Index in dem Array zeigt.
\item Die Funktion \texttt{pop()} können wir dadurch implementieren, dass wir
      die Variable \texttt{mIndex} dekrementieren.  Vorher stellen wir durch den Aufruf 
      von \texttt{assert} in Zeile 23 sicher, dass der Stack nicht leer ist.
      Damit der \texttt{assert} zur Laufzeit auch tatsächlich ausgeführt wird,
      müssen wir das Programm hinter mit der Option ``\texttt{-ea}'' starten, wir werden das
      Programm also in der Form
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{java -ea StackTest}
      \\[0.2cm]
      ausführen.  Die Option ``\texttt{-ea}'' steht für 
      \emph{\underline{e}nable \underline{a}ssertions}.
\item Da der Stack-Pointer immer auf das nächste noch freie Feld zeigt,
      liefert der Ausdruck \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArray[mIndex-1]} \\[0.1cm]
      in Zeile 28 das Element, das als letztes im Stack abgespeichert wurde.
      Dieses Element wird von der Methode $\mathtt{top}()$ zurück gegeben.
\item Die Prozedur \texttt{isEmpty()} überprüft in Zeile 31, ob der Index
      \texttt{mIndex} den Wert 0 hat, denn dann ist der Stack leer.
\end{enumerate}
Damit ist unsere Implementierung des Daten-Typs Stack vollständig.  Es bleibt
ein Programm zu erstellen, mit dem wir diese Implementierung testen können.
Abbildung \ref{fig:StackTest.java} auf Seite \pageref{fig:StackTest.java}
zeigt ein sehr einfaches Programm, in dem Stacks benutzt werden.  
Wir legen nacheinander die Zahlen $0, 1, \cdots, 32$
auf den Stack und geben jedesmal den Stack aus.  Anschließend nehmen wir diese Zahlen der
Reihe nach vom Stack herunter.
Wir werden am Ende dieses Kapitels noch eine anspruchsvollere Anwendung von Stacks
präsentieren, wenn wir Stacks zur Auswertung arithmetischer Ausdrücke verwenden.


\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    import java.util.*;
    
    public class StackTest 
    {
        public static void main(String[] args) {
            Stack<Integer> stack = new ArrayStack<Integer>();
            for (int i = 0; i < 33; ++i) {
                stack.push(i);
                System.out.println(stack);
            }
            for (int i = 0; i < 33; ++i) {
                System.out.println(i + ":" + stack.top());
                stack.pop();
                System.out.println(stack);
            }
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Test der Stack-Implementierung.}
  \label{fig:StackTest.java}
\end{figure} 

\section{Eine Listen-basierte Implementierung von Stacks}
Als nächstes zeigen wir eine alternative Implementierung des abstrakten Daten-Typs
\textsl{Stack}, die auf einer verketteten Liste basiert.
Abbildung \ref{fig:ListStack.java} auf Seite \pageref{fig:ListStack.java} zeigt die
Implementierung.

\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm
                ]
    public class ListStack<Element> extends Stack<Element>
    {
        class DPP {
            Element mData;
            DPP     mNextPointer;

            DPP(Element data, DPP nextPointer) {
                mData        = data;
                mNextPointer = nextPointer;
            }            
            DPP recursiveCopy(DPP pointer) {
                if (pointer == null) {
                    return pointer;
                } else {
                    Element data        = pointer.mData;
                    DPP     nextPointer = recursiveCopy(pointer.mNextPointer);
                    return new DPP(data, nextPointer);
                }
            }
        }    

        DPP mPointer;
        
        public ListStack() {
            mPointer = null;
        }
        public void push(Element e) {
            mPointer = new DPP(e, mPointer);
        }        
        public void pop() {
            assert mPointer != null : "Stack underflow!";
            mPointer = mPointer.mNextPointer;
        }
        public Element top() {
            assert mPointer != null : "Stack is empty!";
            return mPointer.mData;
        }
        public boolean isEmpty() {
            return mPointer == null;
        }       
        public ListStack<Element> clone() throws CloneNotSupportedException {
            ListStack<Element> result = new ListStack<Element>();
            if (mPointer != null) {
                result.mPointer = mPointer.recursiveCopy(mPointer);
            }
            return result;
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Implementierung eines Stacks mit Hilfe einer Liste}
  \label{fig:ListStack.java}
\end{figure} 

Um eine verkette Liste darzustellen, brauchen wir eine Daten-Struktur die Paare darstellt.
Dabei ist die erste Komponente eines solchen Paares ein Element, das abgespeichert werden
soll, und die zweite Komponente ist eine Referenz auf das nächste Paar.
In der Klasse \texttt{ListStack<Element>} definieren wir daher zunächst 
eine \emph{innere} Klasse \texttt{DPP} (zu lesen als \emph{data pointer pair}),
die ein solches Paar darstellt.
\begin{enumerate}
\item Die Klasse enthält ein Element, abgespeichert in der Variablen \texttt{mData}
      und eine Referenz auf das folgende Paar.  Die Referenz wird in der Variablen
      \texttt{mNextPointer} abgespeichert.
\item Der Konstruktor dieser Klasse bekommt als Argumente ein abzuspeicherndes Element
      und eine Referenz auf das nächste Paar.  Mit diesen Argumenten werden dann die
      Variablen \texttt{mData} und \texttt{mNextPointer} initialisiert.
\item Weierhin enthält die Klasse noch die Methode \texttt{recursiveCopy()},
      die später gebraucht wird um eine Liste zu klonen.  Diese Methode erzeugt ein neues
      Paar.  Die erste Komponente dieses Paars ist ist das Daten-Element, die zweite
      Komponente erhalten wir durch einen rekursiven Aufruf von
      $\texttt{recursiveCopy}()$.  
\item Die Klasse \texttt{ListStack<Element>} selber enthält als einzige Member-Variable
      die Referenz \texttt{mPointer}.  Wenn der Stack leer ist, dann hat dieser Pointer
      den Wert \texttt{null}. Sonst verweist die Referenz auf ein Objekt vom Typ \texttt{DPP}.
      In diesem Objekt liegt dann das oberste Stack-Element.
\item Der Konstruktor erzeugt einen leeren Stack, indem die Variable \texttt{mPointer} mit
      dem Wert \texttt{null} initialisiert wird.
\item Um ein neues Element auf den Stack zu legen, erzeugen wir ein Paar, das als erste
      Komponente das neue Element und als zweite Komponente eine Referenz auf die Liste
      enthält, die den bisherigen Stack repräsentierte.  Anschließend lassen wir
      \texttt{mPointer} auf dieses Paar zeigen.
\item Um die Funktion \texttt{pop()} zu implementieren, setzen wir \texttt{mPointer}
      auf die zweite Komponente des ersten Paares.
\item Die Funktion \texttt{top()} implementieren wir, indem wir die erste Komponente des
      Paares, auf das \texttt{mPointer} zeigt, zurück geben.
\item Der Stack ist genau dann leer, wenn \texttt{mPointer} den Wert \texttt{null} hat.
\end{enumerate}
Um diese zweite Implementierung des ADT \textsl{Stack} zu testen, reicht es aus, die Zeile
6 in der Implementierung der Klasse \texttt{StackTest} in Abbildung \ref{fig:StackTest.java}
 zu ändern.  Ursprünglich steht dort: \\[0.1cm]
\hspace*{1.3cm} \texttt{Stack<Integer> stack = new ArrayStack<Integer>();}
\\[0.2cm]
Wir ersetzen hier den Konstruktor-Aufruf \texttt{new ArrayStack<Integer>()} durch den
Aufruf des Konstruktors der  Klasse \texttt{ListStack} und erhalten dann:
\\[0.2cm]
\hspace*{1.3cm} \texttt{Stack<Integer> stack = new ListStack<Integer>();}
\\[0.2cm]
Vergleichen wir die beiden Implementierungen, so stellen wir fest, das die
Listen-basierte Implementierung mehr Speicherplatz als die Feld-basierte Implementierung
verwendet, weil wir jedes Element in einem Objekt der Klasse \texttt{DPP} verpacken
müssen.  Auf der anderen Seite sind aber die Laufzeiten bei allen Methoden der
Listen-basierten Implementierung konstant, wohingegen die Operation $\mathtt{push}(x)$ bei der
Feld-basierten Implementierung unter Umständen einen Aufwand erfordert, der proportional
zur Anzahl der im Stack gespeicherten Elemente ist.


\section{Auswertung arithmetischer Ausdrücke}
Wir zeigen jetzt, wie Stacks zur Auswertung arithmetischer Ausdrücke benutzt werden
können.  Unter einem \emph{arithmetischen Ausdruck} verstehen wir in diesem Zusammenhang
einen String, der aus natürlichen Zahlen und den Operator-Symbolen ``\texttt{+}'',
``\texttt{-}'', ``\texttt{*}'', ``\texttt{/}'', ``\texttt{\symbol{37}}'' und
``\texttt{\symbol{94}}'' aufgebaut ist.  Hierbei steht $x \;\mathtt{\symbol{37}}\; y$ für
den Rest, der bei der Division von $x$ durch $y$ übrig bleibt und
$x\;\mathtt{\symbol{94}}\;y$ steht für die Potenz $x^y$.  Alternativ kann die Potenz $x^y$
auch als $x \;\mathtt{**}\; y$ geschrieben werden.
Außerdem können arithmetische
Ausdrücke noch die beiden Klammer-Symbole ``\texttt{(}'' und ``\texttt{)}'' enthalten.  
Formal wird die Menge der arithmetische Ausdrücke \textsl{ArithExpr} induktiv definiert:
\begin{enumerate}
\item Jede Zahl $n \in \mathbb{N}$ ist ein arithmetischer Ausdruck:
      \[ n \in \textsl{ArithExpr} \quad \mbox{f.a. $n \in \mathbb{N}$}. \]
\item Sind $s$ und $t$ arithmetische Ausdrücke, so sind auch $s + t$, $s - t$, $s * t$, 
      $s / t$, $s \texttt{\symbol{37}} t$ und $s \texttt{\symbol{94}} t$
      arithmetische Ausdrücke:
      \begin{enumerate}
      \item $s \in \textsl{ArithExpr} \wedge t \in \textsl{ArithExpr} \rightarrow s + t \in \textsl{ArithExpr}$,
      \item $s \in \textsl{ArithExpr} \wedge t \in \textsl{ArithExpr} \rightarrow s - t \in \textsl{ArithExpr}$,
      \item $s \in \textsl{ArithExpr} \wedge t \in \textsl{ArithExpr} \rightarrow s * t \in \textsl{ArithExpr}$,
      \item $s \in \textsl{ArithExpr} \wedge t \in \textsl{ArithExpr} \rightarrow s \mathop{/} t \in \textsl{ArithExpr}$,
      \item $s \in \textsl{ArithExpr} \wedge t \in \textsl{ArithExpr} \rightarrow s
        \mathop{\symbol{37}} t \in \textsl{ArithExpr}$,
      \item $s \in \textsl{ArithExpr} \wedge t \in \textsl{ArithExpr} \rightarrow s \mathop{\symbol{94}} t \in \textsl{ArithExpr}$,
      \item $s \in \textsl{ArithExpr} \rightarrow (\, s\,) \in \textsl{ArithExpr}$.
      \end{enumerate}
\end{enumerate}
Haben wir nun einen String gegeben, der einen arithmetischen Ausdruck repräsentiert, als
Beispiel betrachten wir den String
\[ 4 + 3 * 2 \mathop{\mathtt{\symbol{94}}} 2 \mathop{\mathtt{\symbol{94}}} 3, \]
so ist zunächst nicht klar, in welcher Reihenfolge die arithmetischen Operationen
ausgeführt werden sollen.   Um hier Klarheit zu schaffen müssen wir festlegen, wie stark die
verschiedenen Operator-Symbol binden. Wir
vereinbaren, dass, wie in der Mathematik üblich, die Operatoren ``\texttt{*}'',
``\texttt{/}'' und ``\texttt{\symbol{37}}'' stärker binden als die
Operatoren ``\texttt{+}'' und ``\texttt{-}''.  Der Operator ``\texttt{\symbol{94}}''
bindet stärker als alle anderen Operatoren.
Außerdem sind die Operatoren ``\texttt{+}'', ``\texttt{-}'', ``\texttt{*}'',
``\texttt{/}'', ``\texttt{\symbol{37}}'' alle \emph{links-assoziativ}:  Ein Ausdruck der
Form \\[0.1cm]
\hspace*{1.3cm} \texttt{1 - 2 - 3} \quad wird  wie der Ausdruck \quad \texttt{(1 - 2) - 3} \\[0.1cm]
gelesen.  Der Operator ``\texttt{\symbol{94}}'' ist hingegen \emph{rechts-assoziativ}: Ein
arithmetischer Ausdruck der Form \\[0.1cm]
\hspace*{1.3cm} \texttt{2 \symbol{94} 3 \symbol{94} 2} \quad wird  wie der Ausdruck \quad 
\texttt{2 \symbol{94} (3 \symbol{94} 2)} \\[0.1cm]
interpretiert.  Unser Ziel ist es, ein Programm zu erstellen, dass einen String, der
einen arithmetischen Ausdruck darstellt, auswertet.  Dieses Programm wird ganz wesentlich
mit dem abstrakten Daten-Typ \textsl{Stack} arbeiten.

\subsection{Ein einführendes Beispiel}
Wir demonstrieren das Verfahren, mit dem wir arithmetische Ausdrücke auswerten, zunächst
an Hand eines Beispiels.
Wir betrachten den arithmetischen Ausdruck \\[0.1cm]
\hspace*{1.3cm} \texttt{1 + 2 * 3 - 4}. \\[0.1cm]
Wir verarbeiten einen solchen Ausdruck von links nach rechts, Token für Token.  Ein
\emph{Token} ist dabei entweder eine Zahl, eines der Operator-Symbole oder ein Klammer-Symbol.
Bei der Verarbeitung benutzen wir drei Stacks:
\begin{enumerate}
\item Der \emph{Token-Stack} enthält die eingegebenen Token.  Dieser Stack enthält also
      sowohl Zahlen als auch Operator-Symbole und Klammer-Symbole.
\item Der \emph{Argument-Stack} enthält  Zahlen.
\item Der \emph{Operator-Stack} enthält Operator-Symbole und 
      Klammer-Symbole der Form ``\texttt{(}''.
\end{enumerate}
Die Auswertung von \texttt{1 + 2 * 3 - 4} verläuft wie folgt:
\begin{enumerate}
\item Zu Beginn des Algorithmus enthält der Token-Stack die eingegebenen Tokens und die
      anderen beiden Stacks sind leer: \\[0.1cm]
      \hspace*{1.3cm} 
      \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34}, 3,
        \symbol{34}*\symbol{34}, 2, \symbol{34}+\symbol{34}, 1 ]}, 
      \\[0.1cm]
      Beachten Sie, dass bei der horizontalen Darstellung des Stacks das Token, was als
      nächstes von der Methode $\textsl{top}()$ zurück gegeben würde, am rechten Ende der
      Liste liegt.  \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = []}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = []}. 
\item Wir nehmen die Zahl \texttt{1} vom Token-Stack und legen sie auf den Argument-Stack.  
      Die Werte der Stacks sind jetzt \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34}, 3, \symbol{34}*\symbol{34}, 2, \symbol{34}+\symbol{34} ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = []}. 
\item Wir nehmen den Operator \texttt{\symbol{34}+\symbol{34}} vom Token-Stack und legen ihn auf den Operator-Stack.
      Dann gilt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34}, 3, \symbol{34}*\symbol{34}, 2 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1 ]} \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}+\symbol{34} ]}. 
\item Wir nehmen die Zahl \texttt{2} vom Token-Stack und legen sie auf den Argument-Stack.
      Dann gilt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34}, 3, \symbol{34}*\symbol{34} ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1, 2 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}+\symbol{34} ]}. 
\item Wir nehmen den Operator \texttt{\symbol{34}*\symbol{34}} vom Token-Stack und vergleichen diesen Operator mit
      dem Operator \texttt{\symbol{34}+\symbol{34}}, der oben auf dem Operator-Stack liegt.
      Da der Operator \texttt{\symbol{34}*\symbol{34}} stärker bindet als der Operator \texttt{\symbol{34}+\symbol{34}}
      legen wir den Operator \texttt{\symbol{34}*\symbol{34}} ebenfalls auf den Operator-Stack, denn wir 
      müssen diesen Operator auswerten, bevor wir den Operator \texttt{\symbol{34}+\symbol{34}} auswerten
      können.
      Dann gilt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34}, 3 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1, 2 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}+\symbol{34}, \symbol{34}*\symbol{34}]}. 
\item Wir nehmen  die Zahl \texttt{3} vom Token-Stack und legen sie auf den Argument-Stack.
      Dann gilt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34} ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1, 2, 3 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}+\symbol{34}, \symbol{34}*\symbol{34} ]}. 
\item Wir nehmen den Operator \texttt{\symbol{34}-\symbol{34}} vom Token-Stack und vergleichen diesen Operator mit dem
      Operator \texttt{\symbol{34}*\symbol{34}}, der jetzt oben auf dem Stack liegt.  Da der Operator
      \texttt{\symbol{34}*\symbol{34}} stärker bindet als der Operator \texttt{\symbol{34}-\symbol{34}},
      werten wir jetzt den Operator \texttt{\symbol{34}*\symbol{34}} aus:  Dazu      
      nehmen wir die  beiden Argumente 3 und 2 vom Argument-Stack, nehmen den Operator
      \texttt{\symbol{34}*\symbol{34}} vom Operator-Stack und berechnen, wie vom Operator \texttt{\symbol{34}*\symbol{34}}
      gefordert, das Produkt der beiden Argumente. Dieses Produkt legen wir dann wieder auf
      den Argument-Stack.  Den Operator \texttt{\symbol{34}-\symbol{34}} legen wir wieder
      auf den Token-Stack zurück, denn wir haben die entsprechende Operation ja noch nicht
      ausgeführt.   
      Dann haben unsere Stacks die folgende Gestalt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34} ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1, 6 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}+\symbol{34} ]}. 
\item Wir nehmen den Operator \texttt{\symbol{34}-\symbol{34}} vom Token-Stack und
      vergleichen diesen Operator mit dem Operator \texttt{\symbol{34}+\symbol{34}} der nun zuoberst auf dem Operator-Stack liegt.
      Da beide Operatoren gleich stark binden und verschieden sind, werten wir jetzt den Operator
      \texttt{\symbol{34}+\symbol{34}} aus:  Dazu nehmen wir die letzten beiden Argumente vom Argument-Stack, nehmen den Operator
      \texttt{\symbol{34}+\symbol{34}} vom Operator-Stack und berechnen die Summe der beiden Argumente.
      Diese Summe legen wir dann auf den Argument-Stack.  Außerdem legen wir den Operator
      \texttt{\symbol{34}-\symbol{34}} wieder auf den Token-Stack zurück.      
      Dann gilt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34} ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 7 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = []}. 
\item Wir nehmen  den Operator \texttt{\symbol{34}-\symbol{34}} vom Token-Stack und legen
      ihn auf den Operator-Stack.
      Dann gilt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 7 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}-\symbol{34} ]}. 
\item Wir nehmen die Zahl \texttt{4} vom Token-Stack und legen sie auf den Argument-Stack.
      Dann gilt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = []}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 7, 4 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}-\symbol{34} ]}. 
\item Der Input ist nun vollständig gelesen.
      Wir nehmen daher nun den Operator \texttt{\symbol{34}-\symbol{34}} vom Operator-Stack, der damit leer wird.
      Anschließend nehmen wir die beiden Argumente vom Argument-Stack, bilden die
      Differenz und legen diese auf den Argument-Stack.
      Damit gilt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = []}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 3 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = []}. \\[0.1cm]
      Das Ergebnis unserer Rechnung ist jetzt die noch auf dem Argument-Stack verbliebene
      Zahl 3.
\end{enumerate}

\subsection{Ein Algorithmus zur Auswertung arithmetischer Ausdrücke \label{algo-arith}}
Nach dem einführenden Beispiel entwickeln wir nun einen Algorithmus zur Auswertung
arithmetischer Ausdrücke.  Zunächst legen wir fest, welche Daten-Stukturen wir benutzen
wollen.
\begin{enumerate}
\item \texttt{mTokens} ist ein Stack von Eingabe-Token.  Wenn es sich bei den Token um Operatoren oder
      Klammer-Symbole handelt, dann haben diese Token den Typ \texttt{String}.
      Andernfalls stellen die Token Zahlen dar und haben den Typ \texttt{BigInteger}.
      Die gemeinsame Oberklasse der Klassen \texttt{String} und \texttt{BigInteger}
      ist \texttt{Object}.  Daher deklarieren wir die Variable \texttt{mTokens}
      in der zu entwickelnden Klasse \texttt{Calculator} als: \\[0.1cm]
      \hspace*{1.3cm} \texttt{Stack<Object> mTokenStack;}
\item \texttt{mArguments} ist ein Stack von ganzen Zahlen.  Wir deklarieren diesen Stack
      als \\[0.1cm]
      \hspace*{1.3cm} \texttt{Stack<BigInteger> mArguments;}
\item \texttt{mOperators} ist ein Stack, der die Operatoren und eventuell öffnende
      Klammern enthält.  Da wir Operatoren
      durch Strings darstellen, deklarieren wir diesen Stack als \\[0.1cm]
      \hspace*{1.3cm} \texttt{Stack<String> mOperators;}
\end{enumerate}
Wenn wir das einführende Beispiel betrachten und verallgemeinern, dann stellen wir fest,
dass wir Zahlen immer auf 
den Argument-Stack legen müssen, während bei Behandlung der Operatoren
zwei Fälle auftreten können:
\begin{enumerate}
\item Der Operator wird auf den Operator-Stack gelegt, falls einer der folgenden Fälle
      vorliegt:
      \begin{enumerate}
      \item Der Operator-Stack ist leer.
      \item Es liegt eine öffnende Klammer \texttt{\symbol{34}(\symbol{34}}
            auf dem Operator-Stack.
      \item Der neue Operator bindet stärker als der Operator, der bereits oben auf dem Operator-Stack liegt.
      \item Der neue Operator ist identisch mit dem Operator, der bereits oben auf dem Operator-Stack
            liegt und dieser Operator-Stack ist außerdem rechts-assoziativ.
        
      \end{enumerate}
\item Andernfalls wird der Operator wieder auf den Token-Stack zurück gelegt.
      Dann wird der oberste Operator, der auf dem Operator-Stack liegt,
      vom Operator-Stack heruntergenommen, die Argumente  dieses Operators werden vom
      Argument-Stack genommen, der Operator wird ausgewertet
      und das Ergebnis wird auf den Argument-Stack gelegt.
\end{enumerate}

\begin{figure}[!b]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    import java.util.*; 
    import java.math.*;
    
    public class Calculator {
        Stack<BigInteger> mArguments;
        Stack<String>     mOperators;
        Stack<Object>     mTokenStack;
        
        static boolean evalBefore(String op1, String op2) {
            if (op1.equals("(")) {
                return false;
            }
            if (precedence(op1) > precedence(op2)) {
                return true;
            } else if (precedence(op1) == precedence(op2)) {
                return op1.equals(op2) ? isLeftAssociative(op1) : true;
            } else {
                return false;
            }
        }       
        static int precedence(String operator) {
            if (operator.equals("+") || operator.equals("-")) {
                return 1;
            } else if ( operator.equals("*") || operator.equals("/") || 
                        operator.equals("%")) {
                return 2;
            } else if (operator.equals("**") || operator.equals("^")) {
                return 3;
            } else {
                System.out.println("ERROR: *** unkown operator *** ");
            }
            System.exit(1);
            return 0;
        }    
        static boolean isLeftAssociative(String operator) {
            if (operator.equals("+") || operator.equals("-") ||
                operator.equals("*") || operator.equals("/") || 
                operator.equals("%")) {
                return true;
            } else if (operator.equals("**") || operator.equals("^")) {
                return false;
            } else {
                System.out.println("ERROR: *** unkown operator *** ");
            }
            System.exit(1);
            return false;
        }
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Die Klasse \texttt{Calculator}}
  \label{fig:calculator.java}
\end{figure} 

\noindent
Die Abbildungen \ref{fig:calculator.java}, \ref{fig:calculator2.java} und
\ref{fig:calculator3.java}
auf den Seiten \pageref{fig:calculator.java}, \pageref{fig:calculator2.java} und
\pageref{fig:calculator3.java} zeigen  eine Implementierung des Algorithmus
zur Auswertung arithmetischer Ausdrücke in \textsl{Java}.
Wir diskutieren zunächst die Implementierung der statischen Methode \\[0.1cm]
\hspace*{1.3cm} \texttt{static boolean evalBefore(String op1, String op2)}.\\[0.1cm]
Diese Methode vergleicht die Operatoren \texttt{op1} und \texttt{op2} und entscheidet, ob
der Operator \texttt{op1} vor dem Operator \texttt{op2} ausgewertet werden muss.
Beim Aufruf dieser Methode
ist der Operator \texttt{op1} der Operator, der oben auf dem Operator-Stack liegt
und der Operator \texttt{op2} ist der Operator, der als letztes von dem Token-Stack
genommen worden ist.
Um entscheiden zu können, ob der Operator \texttt{op1}
vor dem Operator \texttt{op2} auszuwerten ist, ordnen wir jedem
Operator eine \emph{Präzedenz} zu.  Dies ist eine natürliche Zahl, die angibt, wie stark
der Operator bindet. Tabelle \ref{tab:predence} zeigt die Präzedenzen der von uns
verwendeten Operatoren.

\begin{table}[!h]
  \centering
\framebox{
  \begin{tabular}{|l|l|}
\hline
   Operator             & Präzedenz  \\
\hline
\hline
   \texttt{\symbol{34}+\symbol{34}}, \texttt{\symbol{34}-\symbol{34}}  & 1   \\
\hline
   \texttt{\symbol{34}*\symbol{34}}, \texttt{/}, \texttt{\symbol{37}}  & 2   \\
\hline
   \texttt{\symbol{94}}, \texttt{**}  & 3   \\
\hline
  \end{tabular}}
  \caption{Präzedenzen der Operatoren.}
  \label{tab:predence}
\end{table}

Ist die Präzedenz des Operators \texttt{op1} höher als die Präzedenz des Operators \texttt{op2}, so
bindet \texttt{op1} stärker als \texttt{op2} und wird daher vor diesem ausgewertet.
Ist die Präzedenz des Operators \texttt{op1} kleiner als die Präzedenz des Operators \texttt{op2}, so
wird der Operator \texttt{op2} auf den Operator-Stack gelegt.
In dem Fall, dass die Präzedenzen von \texttt{op1} und \texttt{op2} gleich sind, gibt es zwei Fälle:
\begin{enumerate}
\item $\mathtt{op1} \not= \mathtt{op2}$.

      Betrachten wir eine Beispiel: Der arithmetischer Ausdruck \\[0.1cm]
      \hspace*{1.3cm} \texttt{2 + 3 - 4} \quad wird implizit links geklammert: \quad \texttt{(2 + 3) - 4}. \\[0.1cm]
      Also wird in diesem Fall zunächst \texttt{op1} ausgewertet.  
\item $\mathtt{op1} = \mathtt{op2}$.

      In diesem Fall  spielt die \emph{Assoziativität} des Operators eine Rolle.
      Betrachten wir dazu zwei Beispiele: \\[0.1cm]
      \hspace*{1.3cm} \texttt{2 + 3 + 4} \quad wird interpretiert wie \quad \texttt{(2 + 3) + 4}, \\[0.1cm]
      denn wir sagen, dass der Operator ``\texttt{\symbol{34}+\symbol{34}}'' \emph{links-assoziativ}
      ist. Andererseits wird \\[0.1cm]
      \hspace*{1.3cm} \texttt{2 \symbol{94} 3 \symbol{94} 4}  \quad interpretiert als \quad \texttt{2 \symbol{94} (3 \symbol{94} 4)}, \\[0.1cm]
      denn wir sagen, dass der Operator ``\texttt{\symbol{94}}'' \emph{rechts-assoziativ} ist.

      Die Operatoren ``\texttt{\symbol{34}+\symbol{34}}'', ``\texttt{\symbol{34}-\symbol{34}}'', ``\texttt{\symbol{34}*\symbol{34}}'', ``\texttt{/}'' und 
      ``\texttt{\symbol{37}}'' sind alle links-assoziativ.  Hier wird als zunächst \texttt{op1} ausgewertet.
      Der Operator  ``\texttt{\symbol{94}}'' ist rechts-assoziativ.  Ist der oberste
      Operator auf dem Operator-Stack also ``\texttt{\symbol{94}}'' und wird dann nochmal
      der Operator ``\texttt{\symbol{94}}'' gelesen, so wird auch die neue Instanz dieses
      Operators auf den Stack gelegt.
\end{enumerate}
Mit diesem Vorüberlegung können wir nun die Implementierung von
$\texttt{evalBefore}(\mathtt{op1},\mathtt{op2})$ in  Abbildung \ref{fig:calculator.java}  verstehen.
\begin{enumerate}
\item Falls \texttt{op1} der String \texttt{\symbol{34}(\symbol{34}} ist, so legen wir
      \texttt{op2} auf jeden Fall auf den Stack, denn \texttt{\symbol{34}(\symbol{34}}
      ist ja gar kein Operator, denn wir auswerten könnten.
      Daher geben wir in Zeile 11 den Wert \texttt{false} zurück.
\item Falls die Präzedenz des Operators \texttt{op1} höher ist als die Präzedenz des
      Operators \texttt{op2}, so liefert $\texttt{evalBefore}(\mathtt{op1},\mathtt{op2})$
      in Zeile 14 den Wert \texttt{true}.
\item Falls die Präzedenzen der Operatoren \texttt{op1} und \texttt{op2} identisch sind,
      so gibt es zwei Fälle:
      \begin{enumerate}
      \item Sind die beiden Operatoren gleich, so ist das Ergebnis von
            \texttt{evalBefore(op1,op2)} genau dann \texttt{true}, wenn der Operator
            links-assoziativ ist.
      \item Falls die beiden Operatoren verschieden sind, hat das Ergebnis von
            \texttt{evalBefore(op1,op2)} den Wert \texttt{true}. 
      \end{enumerate}
      Diese beiden Fälle werden in Zeile 16 behandelt.
\item Ist die Präzedenz  des Operators \texttt{op1} kleiner als die Präzedenz des
      Operators \texttt{op2}, so liefert $\texttt{evalBefore}(\mathtt{op1},\mathtt{op2})$
      in Zeile 18 den Wert \texttt{false}.
\end{enumerate}
Die Implementierung der Methode \texttt{predence()} in den Zeilen 21 -- 34 ergibt sich
unmittelbar aus der Tabelle \ref{tab:predence} auf Seite \pageref{tab:predence}.
Die Implementierung der Methode \texttt{isLeftAssociative()} in den Zeilen 35 -- 47
legt fest, dass die Operatoren \texttt{\symbol{34}+\symbol{34}},
\texttt{\symbol{34}-\symbol{34}}, \texttt{\symbol{34}*\symbol{34}},
\texttt{\symbol{34}/\symbol{34}} und 
\texttt{\symbol{34}\symbol{37}\symbol{34}} links-assoziativ sind, während die Operatoren
\texttt{\symbol{34}**\symbol{34}} und \texttt{\symbol{34}\symbol{94}\symbol{34}}
rechts-assoziativ sind.

Abbildung \ref{fig:calculator2.java} auf Seite \pageref{fig:calculator2.java} zeigt die
Implementierung der Methode \texttt{popAndEvaluate()}.
Aufgabe dieser Methode ist es, 
\begin{enumerate}
\item einen Operator vom Operator-Stack zu nehmen (Zeile 49 -- 50), 
\item dessen Argumente vom Argument-Stack zu holen, (Zeile 51 -- 54),
\item den Operator auszuwerten (Zeile 55 -- 69) und
\item das Ergebnis wieder auf dem Argument-Stack abzulegen (Zeile 70).
\end{enumerate}
\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = last,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
        void popAndEvaluate() {
            String operator = mOperators.top();
            mOperators.pop();
            BigInteger rhs = mArguments.top();
            mArguments.pop();
            BigInteger lhs = mArguments.top();
            mArguments.pop();
            BigInteger result = null;
            if (operator.equals("+")) {
                result = lhs.add(rhs);
            } else if (operator.equals("-")) {
                result = lhs.subtract(rhs);
            } else if (operator.equals("*")) {
                result = lhs.multiply(rhs);
            } else if (operator.equals("/")) {
                result = lhs.divide(rhs);
            } else if (operator.equals("**") || operator.equals("^")) {
                result = lhs.pow(rhs.intValue());       
            } else {
                System.out.println("ERROR: *** Unknown Operator ***");
                System.exit(1);
            }
            mArguments.push(result);
        }
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Die Klasse \texttt{Calculator}}
  \label{fig:calculator2.java}
\end{figure}

\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = last,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
        public Calculator() {
            MyScanner scanner = new MyScanner(System.in);
            mTokenStack = scanner.getTokenStack();
            mArguments  = new ArrayStack<BigInteger>();
            mOperators  = new ArrayStack<String>();
            while (!mTokenStack.isEmpty()) {
                if (mTokenStack.top() instanceof BigInteger) {
                    BigInteger number = (BigInteger) mTokenStack.top();
                    mTokenStack.pop();
                    mArguments.push(number);
                    continue;
                } 
                String nextOp = (String) mTokenStack.top();
                mTokenStack.pop();
                if (mOperators.isEmpty() || nextOp.equals("(")) {
                    mOperators.push(nextOp);
                    continue;
                }
                String stackOp = mOperators.top();
                if (stackOp.equals("(") && nextOp.equals(")") ) {
                    mOperators.pop();
                } else if (nextOp.equals(")")) {
                    popAndEvaluate();
                    mTokenStack.push(nextOp);
                } else if (evalBefore(stackOp, nextOp)) {
                    popAndEvaluate();
                    mTokenStack.push(nextOp);
                } else {
                    mOperators.push(nextOp);
                }
            }
            while (!mOperators.isEmpty()) { 
                popAndEvaluate(); 
            }
            BigInteger result = mArguments.top();
            System.out.println("The result is: " + result);
        }    
        public static void main(String[] args) {
            Calculator calc = new Calculator();
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Der Konstruktor der  Klasse \texttt{Calculator}.}
  \label{fig:calculator3.java}
\end{figure}
\noindent
Damit können wir die in Abbildung \ref{fig:calculator3.java} gezeigte
Implementierung des Konstruktors der Klasse \texttt{Calculator}
diskutieren.  
\begin{enumerate}
\item Zunächst erzeugen wir in Zeile 73 ein Objekt der Klasse \texttt{MyScanner}.
      Dieser Scanner liest einen String ein und zerlegt diesen in Token.
      Wir erhalten in Zeile 74 einen Stack zurück, der die Token in der Reihenfolge
      enthält, in der sie eingelesen worden sind.  Geben wir beispielsweise den String \\[0.1cm]
      \hspace*{1.3cm} ``\texttt{1 + 2 * 3 - 4}'' \\[0.1cm]
      ein, so bekommt die Variable \texttt{mTokenStack} in Zeile 74 den Wert \\[0.1cm]
      \hspace*{1.3cm} [ 4, \symbol{34}-\symbol{34}, 3, \symbol{34}*\symbol{34}, 2, \symbol{34}+\symbol{34}, 1 ]
      \\[0.1cm]
      zugewiesen.
      Außerdem initialisieren wir den Argument-Stack und den Operator-Stack in Zeile 75 und 76.      
\item In der nächsten Phase verarbeiten wir die einzelnen Tokens des Token-Stacks
      und verteilen
      diese Tokens auf Argument-Stack und Operator-Stack wie folgt:
      \begin{enumerate}
      \item Ist das gelesene Token eine Zahl, so legen wir diese auf den Argument-Stack
            und lesen das nächste Token.
        
            Im folgenden können wir immer davon ausgehen, dass das gelesene Token ein
            Operator oder eine der beiden Klammern \texttt{\symbol{34}(\symbol{34}} oder
            \texttt{\symbol{34})\symbol{34}} ist. 
      \item Falls der Operator-Stack leer ist oder wenn das gelesene Token eine öffnende Klammer
            \texttt{\symbol{34}(\symbol{34}} ist, legen wir den Operator oder die Klammer auf den Operator-Stack.
      \item Falls das  Token eine schließende Klammer \texttt{\symbol{34})\symbol{34}} ist und wenn zusätzlich
            der Operator auf dem Operator-Stack eine öffnende Klammer \texttt{\symbol{34}(\symbol{34}} ist, so 
            entfernen wir diese Klammer vom Operator-Stack.
      \item Falls jetzt das Token aus dem Token-Stacks eine schließende Klammer
            \texttt{\symbol{34})\symbol{34}} 
            ist, so wissen wir, dass das Token auf dem Operator-Stack keine öffnende
            Klammer sein kann, sondern ein echter Operator ist. 
            Diesen Operator evaluieren wir mit Hilfe der Methode \texttt{popAndEvaluate()}.
            Gleichzeitig schieben wir die schließende Klammer, die wir vom Token-Stack genommen
            haben, wieder auf den Token-Stack zurück, denn wir haben die dazu gehörige
            öffnende Klammer ja noch nicht gefunden.

            Da wir danach wieder zum Beginn der Schleife zurück kehren, werden wir in
            diesem Fall solange Operatoren vom Operator-Stack nehmen und auswerten bis wir
            im Operator-Stack auf eine öffnende Klammer treffen.

            Im folgenden können wir davon ausgehen, dass weder das oberste Zeichen auf dem
            Operator-Stack, noch das oberste Token auf dem Token-Stack eine Klammer ist.
      \item Falls der oberste Operator auf dem Operator-Stack eine höhere Präzedenz hat
            als der zuletzt gelesene
            Operator,  evaluieren wir den obersten Operator auf dem
            Operator-Stack mit Hilfe der Methode \texttt{popAndEvaluate()}.

            Gleichzeitig schieben wir den Operator, den wir vom Token-Stack genommen
            haben, wieder auf den Token-Stack zurück, denn wir haben diesen Operator ja
            noch nicht weiter behandelt.
      \item Andernfalls legen wir den zuletzt gelesenen Operator auf den Operator-Stack.
      \end{enumerate}
      Diese Phase endet sobald der Token-Stack leer ist.
\item Zum Abschluß evaluieren wir alle noch auf dem Operator-Stack verbliebenen Operatoren
      mit Hilfe der Methode \texttt{popAndEvaluate()}.
      Wenn die Eingabe ein syntaktisch korrekter arithmetischer Ausdruck war,
      dann sollte am Ende der Rechnung noch genau eine Zahl auf  dem Argument-Stack
      liegen.  Diese Zahl ist dann unser Ergebnis, das wir ausgeben.
\end{enumerate}
Aus Gründen der Vollständigkeit zeigen wir in Abbildung \ref{fig:myscanner.java}
noch die Implementierung der Klasse \texttt{MyScanner}.  Wir benutzen die Klasse
\texttt{Scanner} aus dem Paket \texttt{java.io}.  Diese Klasse stellt unter anderem die
Methoden $\textsl{hasNext}()$ und $\textsl{hasNextBigInteger}()$ mit denen wir überprüfen
können, ob die Eingabe noch ungelesene Zeichen enthält und ob diese ungelesenen Zeichen
als ganze Zahl interpretiert werden können.  Die Methode $\textsl{nextBigInteger}()$ gibt
dann diese Zahl zurück.  Ein Aufruf von $\textsl{next}()$ liefert als Ergebnis den
nächsten String, der durch Leerzeichen, Tabulatoren oder Zeilenumbrüche begrenzt wird.
Um das Programm später laufen lassen zu können, müssen also alle arithmetischen Operatoren
von Leerzeichen begrenzt werden.  Außerdem ist beim Aufruf zu beachten, dass die Eingabe mit einem
\emph{End-Of-File}-Zeichen abgeschlossen werden muss.  Unter Unix ist dies Ctrl-D, unter
Windows wird hierfür Ctrl-Z verwendet.

\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = last,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    import java.math.*;
    import java.io.*;
    import java.util.*;
    
    public class MyScanner {
        private ArrayStack<Object> mTokenStack;
    
        public MyScanner(InputStream stream) {
            ArrayList<Object> tokenList = new ArrayList<Object>();
            System.out.println( "Enter arithmetic expression. " + 
                                "Separate Operators with white space:");
            Scanner scanner = new Scanner(stream);
            while (scanner.hasNext()) {
                if (scanner.hasNextBigInteger()) {
                    tokenList.add(scanner.nextBigInteger());
                } else {
                    tokenList.add(scanner.next());
                }
            }
            mTokenStack = new ArrayStack<Object>();
            for (int i = tokenList.size() - 1; i >= 0; --i) {
                mTokenStack.push(tokenList.get(i));
            }
        }
        public ArrayStack<Object> getTokenStack() {
            return mTokenStack;
        }
    }               
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Die Klasse \texttt{MyScanner}}
  \label{fig:myscanner.java}
\end{figure}






\section{Nutzen abstrakter Daten-Typen}
Wir sind nun in der Lage den Nutzen, den die Verwendung abstrakter Daten-Typen hat, zu
erkennen. 
\begin{enumerate}
\item Abstrakte Daten-Typen machen die Implementierung eines Algorithmus von der
      Implementierung der Daten-Typen unabhängig.

      Bei der Implementierung des Algorithmus zur Auswertung arithmetischer Ausdrücke
      mussten wir uns um die zugrunde liegenden Daten-Strukturen nicht weiter kümmern. 
      Es reichte aus, zwei Dinge zu wissen: 
      \begin{enumerate}
      \item Die Typ-Spezifikationen der verwendeten Funktionen.
      \item Die Axiome, die das Verhalten dieser Funktionen beschreiben.
      \end{enumerate}
      Der abstrakte Daten-Typ ist damit eine \emph{Schnittstelle} zwischen dem Algorithmus
      einerseits und der Daten-Struktur andererseits.  Dadurch ist es möglich, Algorithmus
      und Daten-Struktur von unterschiedlichen Personen entwickeln zu lassen.
\item Abstrakte Daten-Typen sind \emph{wiederverwendbar}.

      Die Definition des abstrakten Daten-Typs \emph{Stack} ist sehr allgemein. Dadurch
      ist dieser Daten-Typ vielseitig einsetzbar:  Wir werden später noch sehen, wie der
      ADT \emph{Stack} bei der Traversierung gerichteter Graphen eingesetzt werden kann.
\item Abstrakte Daten-Typen sind \emph{austauschbar}.

      Bei der Auswertung arithmetischer Ausdrücke können wir die
      Feld-basierte Implementierung des ADT \emph{Stack} mit minimalen Aufwand durch 
      eine Listen-basierte Implementierung ersetzen.  Dazu ist lediglich an drei Stellen
      der Aufruf eines Konstruktors abzuändern.
      Dadurch wird bei der
      Programm-Entwicklung das folgende Vorgehen möglich: Wir entwerfen den benötigten
      Algorithmus auf der Basis abstrakter Daten-Typen.  Für diese geben wir zunächst sehr
      einfache Implementierungen an, deren Effizienz eventuell noch zu wünschen übrig
      lässt.  In einem späteren Schritt wird evaluiert wo der Schuh am meisten drückt.
      Die ADTs, die bei dieser Evaluierung als performance-kritisch erkannt werden, können
      anschließend mit dem Ziel der Effizienz-Steigerung reimplementiert werden.
\end{enumerate}
\pagebreak

%\section{Abstrakte Daten-Typen in \textsc{Setl2}}
%Das Konzept abstrakter Daten-Typen kann in jeder Programmier-Sprache verwendet werden. 
%Einige Programmier-Sprachen bieten zusätzliche Unterstützung für dieses Konzept.
%Als objekt-orientierte Sprache unterstützt  \textsc{Setl2} abstrakte Daten-Typen 
%durch die Definition von Klassen.
%Wir demonstrieren die Verwendung von Klassen in \textsc{Setl2} am  Beispiel des abstrakten
%Daten-Typs \textsl{Stack}.

%\subsection{Stacks in \textsc{Setl2}}
%\begin{figure}[!h]
%  \centering
%\begin{Verbatim}[ frame         = lines, 
%                  framesep      = 0.3cm, 
%                  labelposition = bottomline,
%                  numbers       = left,
%                  numbersep     = -0.2cm,
%                  commandchars  = \\\{\},
%                  xleftmargin   = 0.8cm,
%                  xrightmargin  = 0.8cm
%                ]
%    \underline{class} Stack;
%        p\underline{rocedure} \underline{create}(); 
%        p\underline{rocedure} push(x);
%        p\underline{rocedure} pop();
%        p\underline{rocedure} top();
%        p\underline{rocedure} isEmpty();
%    \underline{end} Stack;
            
%    \underline{class} \underline{bod}y Stack;
%        \underline{var} list;
        
%        p\underline{rocedure} \underline{create}();
%            list := [];
%        \underline{end} \underline{create};
        
%        p\underline{rocedure} push(x);
%            list := list + [x];
%        \underline{end} push;
    
%        p\underline{rocedure} pop();
%            list := list(1 .. #list-1);
%        \underline{end} pop;
    
%        p\underline{rocedure} top();
%            \underline{return} list(#list);
%        \underline{end} top;
    
%        p\underline{rocedure} isEmpty();
%            \underline{return} list = [];
%        \underline{end} isEmpty;
    
%        p\underline{rocedure} \underline{selfstr}();
%            \underline{return} \underline{str}(list);
%        \underline{end} selfstr;
%    \underline{end} \underline{Stack};
%\end{Verbatim}
%\vspace*{-0.3cm}
%  \caption{Implementierung eines Stacks in \textsc{Setl2}}
%  \label{fig:stack-setl}
%\end{figure} 

%\noindent
%Abbildung \ref{fig:stack-setl} auf Seite \pageref{fig:stack-setl} zeigt, wie der ADT
%\emph{Stack} sich in \textsc{Setl2} mit Hilfe einer Klasse implementieren lässt.  Alle
%Schlüsselwörter der Sprache \textsc{Setl2} sind in der Abbildung unterstrichen worden.
%\begin{enumerate}
%\item In \textsc{Setl2} besteht ein ADT aus zwei Teilen, einer \emph{Klassen-Deklaration}
%      und einer \emph{Klassen-Definition}.
%\item Die Klassen-Deklaration hat die Form \\[0.1cm]
%      \hspace*{1.3cm} \texttt{class} \textsl{name}\texttt{;} \\[0.1cm]
%      \hspace*{2.3cm} \texttt{procedure} \texttt{create($\cdots$)}\texttt{;}  \\[0.1cm]
%      \hspace*{2.3cm} \emph{procedure-declaration}\texttt{;}  \\[0.1cm]
%      \hspace*{3.3cm} $\vdots$  \\[0.1cm]
%      \hspace*{2.3cm} \emph{procedure-declaration}\texttt{;} \\[0.1cm]
%      \hspace*{1.3cm} \texttt{end} \textsl{name}\texttt{;} \\[0.1cm]
%      Hierbei ist \textsl{name} der Name der Klasse.  Innerhalb der Klasse stehen
%      dann die Deklarationen der verschiedenen Prozeduren, die die Klasse nach außen zur
%      Verfügung stellt. Dabei hat die erste Prozedur-Deklaration eine besondere Form:
%      Die dort deklarierte Funktion hat immer den Namen \texttt{create()}.
%      Bei dieser Funktion handelt es sich um den \emph{Konstruktor} der Klasse.

%      Abbildung \ref{fig:stack-setl} zeigt in den Zeilen 1 -- 7 die Deklaration der Klasse
%      \texttt{Stack}.
%\item Die \emph{Klassen-Definition} hat die Form \\[0.1cm]
%      \hspace*{1.3cm} \texttt{class} \texttt{body} \textsl{name}\texttt{;} \\[0.1cm]
%      \hspace*{2.3cm} \emph{var-declaration}\texttt{;}  \\[0.1cm]
%      \hspace*{2.3cm} \emph{procedure-definition}\texttt{;}  \\[0.1cm]
%      \hspace*{3.3cm} $\vdots$  \\[0.1cm]
%      \hspace*{2.3cm} \emph{procedure-definition}\texttt{;} \\[0.1cm]
%      \hspace*{1.3cm} \texttt{end} \textsl{name}\texttt{;} \\[0.1cm]
%      Die einzelnen Komponenten haben die folgende Bedeutung:
%      \begin{enumerate}
%      \item \emph{var-declaration} listet die Variablen auf, die in einem Objekt
%            des ADT vorhanden sind.  Dadurch werden die internen Daten-Strukturen, durch
%            die Klasse realisiert wird, festgelegt.

%            In Abbildung \ref{fig:stack-setl} wird in Zeile 10 festgelegt, dass ein Stack
%            intern durch den Wert der Variablen \texttt{list} dargestellt wird.
%      \item Danach folgen die Definitionen der in der Klassen-Deklaration aufgelisteten 
%            Prozeduren.  Diese Prozedur-Definitionen unterscheiden sich nicht von den
%            Definitionen gewöhnlicher Prozeduren.

%      \item Zusätzlich können weiter Prozeduren definiert werden, die in der
%            Klassen-Deklaration nicht genannt werden.  Solche Hilfs-Prozeduren sind dann
%            außerhalb der Klasse nicht sichtbar und können nur innerhalb der Klasse
%            verwendet werden, also nur innerhalb der Prozedur-Definitionen in der
%            Klassen-Definition. 
%      \item Die Prozedur \texttt{selfstr()} hat eine besondere Funktion:
%            Sie wandelt ein Objekt des ADT in einen String um.  Dadurch können Objekte des
%            ADTs dann mit \texttt{print()} ausgedruckt werden.

%            In Abbildung \ref{fig:stack-setl} wird \texttt{selfstr()} mit Hilfe der
%            eingebauten Funktion \texttt{str()} realisiert: Diese Funktion kann alle
%            \texttt{Setl2}-Datenstrukturen in einen String umwandeln.
%      \end{enumerate}
%\end{enumerate}

%\begin{figure}[!ht]
%  \centering
%\begin{Verbatim}[ frame         = lines, 
%                  framesep      = 0.3cm, 
%                  labelposition = bottomline,
%                  numbers       = left,
%                  numbersep     = -0.2cm,
%                  xleftmargin   = 0.8cm,
%                  xrightmargin  = 0.8cm
%                ]
%    program main;
%        use Stack;
            
%        S := Stack();
%        print("S = ", S);
    
%        for i in {1..12} loop
%            S.push(i);
%            print("S = ", S);
%        end loop;    
    
%        for i in {1..12} loop
%            S.pop();
%            print("S = ", S);
%        end loop;    
%    end main;
%\end{Verbatim}
%\vspace*{-0.3cm}
%  \caption{Benutzung eines Stacks in \textsc{Setl2}}
%  \label{fig:stack-setl-use}
%\end{figure} 

%\noindent
%Werden die obige Klassen-Deklaration und die Klassen-Definition übersetzt, so wird der ADT
%\texttt{Stack} mit seinen Funktionen in der \textsc{Setl2}-Bibliothek \texttt{setl2.lib}
%abgespeichert.  Um diesen Daten-Typ auch nutzen zu können, muss ein Programm die Direktive \\[0.1cm]
%\hspace*{1.3cm} \texttt{use Stack;} \\[0.1cm]
%enthalten.  Abbildung \ref{fig:stack-setl-use} zeigt ein solches Programm mit der
%Direktive in Zeile 2.  Ein Stack kann nun mit Hilfe der Funktion \texttt{Stack()}  erzeugt
%werden.  Ein solcher Aufruf ruft intern den \emph{Konstruktor} der Klasse \texttt{Stack}
%auf.  Der Konstruktor war die Prozedur, die den Namen \texttt{create()} hat.  Aufgabe dieser
%Prozedur ist es, die internen Daten-Strukturen zu initialisieren, die den ADT repräsentieren.
%Im Falle des Stacks wurde einfach die Variable \texttt{list} auf die leere Liste \texttt{[]} gesetzt.

%Die Prozeduren, die der Daten-Typ Stack zur Verfügung stellt, werden nun in der Form \\[0.1cm]
%\hspace*{1.3cm} $S$\texttt{.}\textsl{function}($\cdots$) \\[0.1cm]
%aufgerufen. Hierbei muss $S$ ein Objekt sein, dass mit dem Konstruktor des Daten-Typs
%Stack erzeugt wurde. Zeile 8 und Zeile 13 zeigen, wie die Prozeduren \texttt{push()} und
%\texttt{pop()} aufgerufen werden.

%\subsection{Realisierung von komplexen Zahlen in \textsc{Setl2}}
%Wir geben ein weiteres Beispiel für die Implementierung eines abstrakten Daten-Typs in
%\textsc{Setl2}, an dem wir das Konzept des \emph{Überladens von Operatoren} demonstrieren
%können:
%Die Sprache \textsc{Setl2} selbst kennt keine komplexen Zahlen.  Es ist aber einfach,
%komplexe Zahlen als ADT in \textsc{Setl2} zu realisieren.
%Abbildung \ref{fig:complex-setl} auf Seite \pageref{fig:complex-setl}
%zeigt eine Implementierung des ADT \texttt{Complex}.

%\begin{figure}[!h]
%  \centering
%\begin{Verbatim}[ frame         = lines, 
%                  framesep      = 0.3cm, 
%                  labelposition = bottomline,
%                  numbers       = left,
%                  numbersep     = -0.2cm,
%                  xleftmargin   = 0.8cm,
%                  xrightmargin  = 0.8cm,
%                  commandchars  = \\\{\}
%                ]
%    class Complex;
%        procedure create(x, y);
%    end Complex;

%    class body Complex;
%        var real, imag;
    
%        procedure create(x,y);
%            real := x;
%            imag := y;
%        end create;
    
%        procedure \underline{self} + z;
%            return Complex(real + z.real, imag + z.imag);
%        end;
    
%        procedure \underline{self} - z;
%            return Complex(real - z.real, imag - z.imag);
%        end;
    
%        procedure \underline{self} * z;
%            resultReal := real * z.real - imag * z.imag;
%            resultImag := real * z.imag + imag * z.real;
%            return Complex(resultReal, resultImag);
%        end;
    
%        procedure \underline{self} / z;
%            denominator := z.real ** 2 + z.imag ** 2;
%            resultReal := (real * z.real + imag * z.imag) / denominator;
%            resultImag := (imag * z.real - real * z.imag) / denominator;
%            return Complex(resultReal, resultImag);
%        end;
    
%        procedure \underline{selfstr}();
%            return \underline{str}(real) + " + " + \underline{str}(imag) + " * i";
%        end \underline{selfstr};
%    end Complex;
%\end{Verbatim}
%\vspace*{-0.3cm}
%  \caption{Komplexe Zahlen in  \textsc{Setl2}}
%  \label{fig:complex-setl}
%\end{figure} 

%\begin{enumerate}
%\item Die Klassen-Deklaration deklariert nur den Konstruktor.
%      Dieser bekommt als Argumente den Real- und Imaginär-Teil der komplexen Zahl.
%\item Die Klassen-Definition legt in Zeile 6 zunächst fest, dass eine komplexe Zahl intern
%      durch die beiden Variablen \texttt{real} und \texttt{imag} repräsentiert wird,
%      die respektive den Real- und Imaginär-Teil der Zahl enthalten.
%      Im Konstruktor werden diese beiden Variablen mit den Argumenten \texttt{x} und
%      \texttt{y} initialisiert.
%\item Zusätzlich enthält die Klassen-Definition die Definition der Rechen-Operationen.
%      Diese Definitionen erfolgen mit einer speziellen Syntax: \\[0.1cm]
%      \hspace*{1.3cm} \texttt{procedure self} \textsl{op} \textsl{arg}\texttt{;} \\[0.1cm]
%      \hspace*{2.3cm} \textsl{body} \\[0.1cm]
%      \hspace*{1.3cm} \texttt{end;} \\[0.1cm]
%      Hier ist \textsl{op} der Name des zu definierenden Operators, also
%      z.B.~``\texttt{\symbol{34}+\symbol{34}}'' oder ``\texttt{\symbol{34}*\symbol{34}}'' und \textsl{arg} steht für das zweite
%      Argument dieses Operators.  \textsl{body} steht für den Rumpf der Prozedur.
%      Innerhalb des Rumpfes kann auf Real- und Imaginär-Teil des Arguments \textsl{arg} 
%      mit Hilfe der Notation \textsl{arg}\texttt{.real} und \textsl{arg}\texttt{.imag}
%      zurück gegriffen werden.
%\end{enumerate}
%Das Programm in Abbildung \ref{fig:complex-test.setl} zeigt, dass mit Hilfe der so
%eingeführten Klasse \texttt{Complex} in \textsc{Setl2} so mit komplexen Zahlen gerechnet werden kann, als ob
%diese ein Teil der Sprache \textsc{Setl2} wären.  In \textsl{Java} ist soetwas nicht
%möglich, dort können Operatoren nicht überladen werden.  Im Gegensatz dazu bietet die
%Sprache \texttt{C++} ebenfalls die Möglichkeit, Operatoren zu  
%überladen.

%\begin{figure}[!h]
%  \centering
%\begin{Verbatim}[ frame         = lines, 
%                  framesep      = 0.3cm, 
%                  labelposition = bottomline,
%                  numbers       = left,
%                  numbersep     = -0.2cm,
%                  xleftmargin   = 0.8cm,
%                  xrightmargin  = 0.8cm
%                ]
%    program main;
%        use Complex;
    
%        z1 := Complex(1,  1);
%        z2 := Complex(1, -1);
%        print(z1, " + ", z2, " = ", z1 + z2);
%        print(z1, " - ", z2, " = ", z1 - z2);
%        print("(", z1, ") * (", z2, ") = ", z1 * z2);
%        print("(", z1, ") / (", z2, ") = ", z1 / z2);
%    end main;
%\end{Verbatim}
%\vspace*{-0.3cm}
%  \caption{Komplexe Zahlen in  \textsc{Setl2}}
%  \label{fig:complex-test.setl}
%\end{figure} 




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "algorithmen"
%%% End: 
