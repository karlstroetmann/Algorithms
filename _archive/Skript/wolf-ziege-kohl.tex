\section{Das Wolf-Ziege-Kohl-Problem}
Zum Abschluss dieses Kapitels wollen wir zeigen, wie mit Hilfe von Mengen auch komplexere
Problem gel\"ost werden k\"onnen.  Wir w\"ahlen dazu das \emph{Wolf-Ziege-Kohl-Problem}, das wir
bereits im ersten Semester  bearbeitet haben:
\vspace*{0.3cm}

\begin{minipage}[c]{14cm}
{\sl
Ein Bauer will mit einem Wolf, einer Ziege und einem Kohl \"uber einen Fluss \"ubersetzen, um
diese als Waren auf dem Markt zu verkaufen.
Das Boot ist aber so klein, dass er nicht zwei Waren gleichzeitig mitnehmen kann.
Wenn er den Wolf mit der Ziege allein l\"asst, dann frisst der Wolf die Ziege und wenn er die
Ziege mit dem Kohl allein l\"asst, dann frisst die Ziege den Kohl. }
\end{minipage}
\vspace*{0.3cm}


\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    program main;
        All := { "Bauer", "Wolf", "Ziege", "Kohl" };
        P := pow All;
        R1 := { [ S, S - B ] : S in P, B in pow S |
                "Bauer" in B and #B <= 2 and not problem(S - B) 
              };
        R2 := { [ S, S + B ] : S in P, B in pow (All - S) |
                "Bauer" in B and #B <= 2 and not problem(All - S - B) };
        R := R1 + R2;
        start := All;
        goal  := {};
        path := reachable(start, goal, R);
        print(path);

        procedure problem(S);
            return ("Ziege" in S and "Kohl"  in S) or
                   ("Wolf"  in S and "Ziege" in S);
        end problem;

        procedure reachable(x, y, R);
            P := { [x] };
            loop
                Old_P := P;
                P     := P + path_product(P, R);
                Found := { p in P | p(#p) = y };
                if Found /= {} then
                    return arb Found;
                end if;
                if P = Old_P then
                    return;
                end if;
            end loop;
        end reachable;

        procedure path_product(P, Q);
            return { add(p,q) : p in P, q in Q 
                              | p(#p) = q(1) and not cyclic(add(p,q)) };
        end path_product;    

        procedure cyclic(p);
            return #{ x : x in p } < #p;
        end cyclic;

        procedure add(p, q);
            return p + q(2..);
        end add;    
    end main;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{L\"osung des Wolf-Ziege-Kohl-Problems in \textsc{Setl2}.}
\label{fig:wolf-ziege-kohl.stl}
\end{figure}

\noindent
Wir hatten damals das in Abbildung
\ref{fig:wolf-ziege-kohl.stl} auf Seite \pageref{fig:wolf-ziege-kohl.stl} gezeigte
\textsc{Setl2}-Programm zur L\"osung dieses Problems entwickelt.  
Wir wollen nun versuchen, diese L\"osung in  \textsl{Java} zu reimplementieren.
Als erstes m\"ussen wir \"uberlegen, wie wir die Mengen, mit denen dort gearbeitet wird,
darstellen wollen.    In \textsl{Java} stehen hierf\"ur die Klassen \texttt{TreeSet}
und \texttt{HashSet} zur Auswahl.  Die Klasse \texttt{TreeSet} ist durch
Rot-Schwarz-B\"aumen implementiert, w\"ahrend die Klasse \texttt{HashSet} mit Hilfe von
Hash-Tabellen implementiert ist.  Letztere haben im schlechtesten Fall eine h\"ohere
Komplexit\"at.  Daher entscheiden wir uns f\"ur die Klasse \texttt{TreeSet}.  Versuchen wir
das Programm aus Abbildung \ref{fig:wolf-ziege-kohl.stl} in \textsl{Java} umzusetzen,
so sto{\ss}en wir allerdings sofort auf ein Problem:  Bei der Umsetzung ben\"otigen wir Mengen,
deren Elemente selbst wieder Mengen sind.  Die Elemente eines \texttt{TreeSet}s m\"ussen
aber vergleichbar sein, f\"ur eine beliebige Klasse \texttt{E} kann nur dann eine Klasse
\texttt{TreeSet<E>} gebildet werden, wenn 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{E implements Comparable<E>}
\\[0.2cm]
gilt.  Leider wird die Schnittstelle \texttt{Comparable} aber von der Klasse
\texttt{TreeSet} selber nicht implementiert.  Damit erleiden wir Schiffbruch, wenn wir
versuchen,  eine Klasse der Form 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{TreeSet<TreeSet<E>>}
\\[0.2cm]
zu erzeugen und damit zu arbeiten.  Abbildung \ref{fig:SetOfSet.java} zeigt ein Programm,
bei dem wir eine Menge von Mengen von Zahlen anlegen wollen.  Der Versuch scheitert in dem
Moment, wo wir die zweite Menge in die Menge von Mengen einf\"ugen wollen, denn dann merkt
die virtuelle Maschine, dass Objekte der Klasse \texttt{TreeSet} das Interface
\texttt{Comparable} nicht implementieren.  Wir erhalten die Fehlermeldung
\begin{verbatim}
    Exception in thread "main" java.lang.ClassCastException: 
         java.util.TreeSet cannot be cast to java.lang.Comparable
\end{verbatim}
Wir behelfen uns dadurch, dass wir eine neue Klasse \texttt{ComparableSet<E>}
definieren, die das Interface \texttt{Comparable} implementiert.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    import java.util.*;
    
    public class SetOfSet {
        public static void main(String[] args) {
            TreeSet<TreeSet<Integer>> all = new TreeSet<TreeSet<Integer>>();
            TreeSet<Integer> a = new TreeSet<Integer>();
            a.add(1);
            a.add(2);
            a.add(3);
            TreeSet<Integer> b = new TreeSet<Integer>();
            b.add(1);
            b.add(2);
            b.add(3);
            all.add(a);
            all.add(b);
            System.out.println(all);
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Mengen von Mengen: Vorsicht Falle!}
\label{fig:SetOfSet.java}
\end{figure}



\subsection{Die Klasse \texttt{ComparableSet}}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    import java.util.*;
    
    public class ComparableSet<T extends Comparable<? super T>> 
        implements Comparable<ComparableSet<T>>, 
                   Iterable<T>
    {
        protected TreeSet<T> mSet;
    
        public TreeSet<T> getSet()           { return mSet;             }        
        public ComparableSet()               { mSet = new TreeSet<T>(); }
        public ComparableSet(TreeSet<T> set) { mSet = set;              } 
        public ComparableSet<T> deepCopy() {
            return new ComparableSet<T>(new java.util.TreeSet<T>(mSet));
        }
        public boolean isEmpty()      { return mSet.isEmpty();    }
        public boolean add(T element) { return mSet.add(element); }
        public Iterator<T> iterator() { return mSet.iterator();   }
        public int size()             { return mSet.size();       }

        public T any()                { return mSet.first();      }
        public String toString()      { return mSet.toString();   }
        
        public boolean equals(Object x) {
            if (x instanceof ComparableSet) {
                ComparableSet cmpSet = (ComparableSet) x;
                TreeSet       set    = cmpSet.mSet;
                return mSet.equals(set);
            }
            return false;
        }
        public boolean member(T element) {
            return mSet.contains(element);
        }
        public boolean isSubset(ComparableSet<T> set) {
            return set.getSet().containsAll(mSet);
        }
    \end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{ComparableSet<T>}, 1.~Teil.}
\label{fig:ComparableSet-1}
\end{figure}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = last,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
        public int compareTo(ComparableSet<T> comparableSet) {
            TreeSet<T>  set        = comparableSet.getSet();
            Iterator<T> iterFirst  = mSet.iterator();
            Iterator<T> iterSecond =  set.iterator();
            while (iterFirst.hasNext() && iterSecond.hasNext()) {
                T   first  = iterFirst .next();
                T   second = iterSecond.next();
                int cmp    = first.compareTo(second);
                if (cmp == 0) {
                    continue;
                }
                return cmp;
            }
            if (iterFirst.hasNext())  { return  1; }       
            if (iterSecond.hasNext()) { return -1; }
            return 0;
        }
        public ComparableSet<T> union(ComparableSet<T> comparableSet) {
            TreeSet<T> union = new TreeSet<T>(mSet);
            union.addAll(comparableSet.getSet());
            return new ComparableSet<T>(union);
        }    
        public ComparableSet<T> intersection(ComparableSet<T> comparableSet) {
            TreeSet<T> intersection = new TreeSet<T>(mSet);
            intersection.retainAll(comparableSet.getSet());
            return new ComparableSet<T>(intersection);
        }    
        public ComparableSet<T> difference(ComparableSet<T> comparableSet) {
            TreeSet<T> difference = new TreeSet<T>(mSet);
            difference.removeAll(comparableSet.getSet());
            return new ComparableSet<T>(difference);
        }
        public <S extends Comparable<? super S>> ComparableSet<Pair<T,S>>
            product(ComparableSet<S> comparableSet) 
        {
            TreeSet<Pair<T,S>> product = new TreeSet<Pair<T,S>>();
            for (T x: mSet) {
                for (S y: comparableSet.getSet()) {
                    product.add(new Pair<T,S>(x, y));
                }
            }       
            return new ComparableSet<Pair<T,S>>(product);
        }
        public ComparableSet<ComparableSet<T>> powerSet() {
            return new ComparableSet<ComparableSet<T>>(powerSet(mSet));
        }   
    \end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{ComparableSet<T>}, 2.~Teil.}
\label{fig:ComparableSet-2}
\end{figure}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = last,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
        private static <S extends Comparable<? super S>> TreeSet<ComparableSet<S>> 
            powerSet(TreeSet<S> set) 
        {
            if (set.isEmpty()) {
                TreeSet<ComparableSet<S>> power = new TreeSet<ComparableSet<S>>();
                ComparableSet<S>          empty = new ComparableSet<S>();
                power.add(empty);
                return power;
            }
            S          last = set.last();
            TreeSet<S> rest = (TreeSet<S>) set.headSet(last);
            TreeSet<ComparableSet<S>> powerRest = powerSet(rest);
            TreeSet<ComparableSet<S>> powerSet  = cloneSet(powerRest);
            addElement(powerRest, last);
            powerSet.addAll(powerRest);
            return powerSet;
        }
        private static <S extends Comparable<? super S>> void 
            addElement(TreeSet<ComparableSet<S>> setOfSets, S element) 
        {
            for (ComparableSet<S> set: setOfSets) {
                set.add(element);
            }
        }
        private static <S extends Comparable<? super S>> TreeSet<ComparableSet<S>> 
            cloneSet(TreeSet<ComparableSet<S>> set) 
        {
            TreeSet<ComparableSet<S>> result = new TreeSet<ComparableSet<S>>();
            for (ComparableSet<S> s: set) {
                result.add(s.deepCopy());
            }
            return result;
        }
        public static <T extends Comparable<? super T>> ComparableSet<T> 
            singleton(T element) 
        {
            TreeSet<T> set = new TreeSet<T>();
            set.add(element);
            return new ComparableSet<T>(set);
        }
        public static <T extends Comparable<? super T>> ComparableSet<T> 
            doubleton(T first, T second) 
        {
            TreeSet<T> set = new TreeSet<T>();
            set.add(first);
            set.add(second);
            return new ComparableSet<T>(set);
        }
    \end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{ComparableSet<T>}, 3.~Teil.}
\label{fig:ComparableSet-3}
\end{figure}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = last,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
        public static ComparableSet<Integer> range(int low, int high) {
            ComparableSet<Integer> result = new ComparableSet<Integer>();
            for (int i = low; i <= high; ++i) {
                result.add(i);
            }
            return result;
        }   
        public static <U extends Comparable<? super U>, 
                       V extends Comparable<? super V>, 
                       W extends Comparable<? super W>> ComparableSet<Pair<U,W>> 
            compose(ComparableSet<Pair<U,V>> R1, ComparableSet<Pair<V,W>> R2) 
        {
            ComparableSet<Pair<U,W>> result = new ComparableSet<Pair<U,W>>();
            for (Pair<U,V> xy: R1) {
                for (Pair<V,W> yz: R2) {
                    if (xy.getSecond().equals(yz.getFirst())) {
                        result.add(new Pair<U,W>(xy.getFirst(), yz.getSecond()));
                    }
               }
            }    
            return result;
        }
        public ComparableSet<T> select(Selector<T> selector) {
            TreeSet<T> result = new TreeSet<T>();
            for (T element: mSet) {
                if (selector.select(element)) { result.add(element); }
            }
            return new ComparableSet<T>(result);
        }
        public <S extends Comparable<? super S>> ComparableSet<S> 
            transform(Transformer<S, T> transformer) 
        {
            TreeSet<S> result = new TreeSet<S>();
            for (T element: mSet) {
                result.add(transformer.transform(element));
            }
            return new ComparableSet<S>(result);
        }
    \end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{ComparableSet<T>}, 4.~Teil.}
\label{fig:ComparableSet-4}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
        public static <T extends Comparable<? super T>, 
                       X extends Comparable<? super X>, 
                       Y extends Comparable<? super Y>> ComparableSet<T>
        combineSets(ComparableSet<X> S1, 
                    ComparableSet<Y> S2, 
                    Combinator<T,X,Y> combinator) 
        {
            TreeSet<T> result = new TreeSet<T>();
            for (X x: S1) {
                for (Y y: S2) {
                    result.add(combinator.combine(x, y));
                }
            }
            return new ComparableSet<T>(result);
        }
    }    
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{ComparableSet<T>}, 5.~Teil.}
\label{fig:ComparableSet-5}
\end{figure}


Die Abbildungen 
\ref{fig:ComparableSet-1}, \ref{fig:ComparableSet-2}, \ref{fig:ComparableSet-3},
\ref{fig:ComparableSet-4} und \ref{fig:ComparableSet-5}
zeigen die Implementierung der Klasse \texttt{ComparableSet}.  Wir diskutieren die
Implementierung jetzt im Detail.
\begin{enumerate}
\item In Zeile 3 fordern wir f\"ur den Typ-Parameter \texttt{T} der Klasse
      \texttt{ComparableSet<T>}, dass
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{T extends Comparable<? super T>}
      \\[0.2cm]
      gilt.  Hier steht das Fragezeichen ``\texttt{?}'' f\"ur eine Oberklasse \texttt{O}
      von \texttt{T}.  Die Forderung ist also, dass es eine Klasse \texttt{O} gibt, die
      eine Oberklasse der Elemente von \texttt{T} ist, und f\"ur die au{\ss}erdem
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{T extends Comparable<O>}
      \\[0.2cm]
      gilt.  Das Interface \texttt{Comparable<O>} hat die Form
      \begin{verbatim}
      interface Comparable<O> {
          int compareTo(O o);
      }
      \end{verbatim}
      Also spezifiziert der String ``\texttt{T extends Comparable<? super T>}'', dass
      Elemente der Klasse \texttt{T} mit Elementen jeder Oberklasse von \texttt{T}
      vergleichbar sein m\"ussen.  Im ersten Moment denken Sie eventuell, dass es reichen
      w\"urde, wenn wir 
\begin{verbatim}
      ComparableSet<T extends ComparableSet<T>>
\end{verbatim}
      schreiben w\"urden.  Das w\"urde aber dann nicht mehr funktionieren, wenn wir zun\"achst
      eine Klasse \texttt{A} h\"atten, die als
\begin{verbatim}
      class A implements Comparable<A> { ... }
\end{verbatim}
      definiert ist und von dieser Klasse sp\"ater eine Klasse \texttt{B} ableiten, welche die
      Methode\\
      $\textsl{compareTo}()$ von der Klasse \texttt{A} erbt.  Das Problem ist,
      dass f\"ur \texttt{B} in dem Fall nur
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{B implements Comparable<A>}
      \\[0.2cm]
      gilt und eben nicht
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{B implements Comparable<B>}.
      \\[0.2cm]
      Damit k\"onnten wir keine Klasse \texttt{ComparableSet<B>} mehr bilden und
      m\"ussten stattdessen auf die ungenauere Klasse \texttt{ComparableSet<A>} ausweichen,
      wobei  wir Typinformationen verlieren w\"urden.
\item Die Klasse \texttt{ComparableSet} ist letztlich nur eine Verpackung eines 
      Objektes der Klasse \texttt{TreeSet}, das in Zeile 7 durch die Member-Variable
      \texttt{mSet}  definiert wird.  An dieser Stelle stellt sich die Frage,
      warum wir die Klasse \texttt{ComparableSet} nicht von der Klasse \texttt{TreeSet}
      ableiten.  Der Grund f\"ur dieses Vorgehen ist, dass die wesentlichen Methoden, die in der
      Klasse \texttt{TreeSet} implementiert sind, die Mengen, auf denen sie arbeiten,
      ver\"andern.  Wenn wir beispielsweise f\"ur zwei Mengen $a$ und $b$ die Methode
      \\[0.2cm]
      \hspace*{1.3cm}
      $a.\textsl{addAll}(b)$
      \\[0.2cm]
      aufrufen um die Vereinigung $a \cup b$ zu berechnen, so hat die Menge $a$ nach
      diesem Aufruf ihren alten Wert verloren.  Solche Seiteneffekte sind f\"ur die Art und
      Weise, in der wir Mengen benutzen wollen, sehr unerw\"uscht.  Die Methoden, die dem
      Benutzer der Klasse \texttt{ComparableSet} zur Verf\"ugung gestellt werden, sollen
      frei von Seiteneffekten sein.  Beispielsweise werden wir eine Methode $\textsl{union}()$
      implementieren, die so beschaffen ist, dass f\"ur zwei Mengen $a$ und $b$
      \\[0.2cm]
      \hspace*{1.3cm}
      $a.\textsl{union}(b) = a \cup b$
      \\[0.2cm]
      gilt und dass au{\ss}erdem die Variablen $a$ und $b$ bei dieser Operation ihre alten Werte behalten.
      Diese Methode $\textsl{union}()$ soll die in der Klasse \texttt{TreeSet} implementierte Klasse
      $\textsl{addAll}()$ ersetzen.  W\"urden wir die Klasse \texttt{ComparableSet} von der Klasse
      \texttt{TreeSet} ableiten, so h\"atte der Beutzer immer noch die M\"oglichkeit, beispielsweise die
      Methode $\textsl{addAll}()$ zu benutzen.  Dies soll verhindert werden, denn nur so k\"onnen wir f\"ur
      die Klasse \texttt{ComparableSet} die folgende Garantie geben: Eine Variable vom Typ
      \texttt{ComparableSet} \"andert Ihren Wert nur, wenn ihr explizit ein neuer Wert zugewiesen wird.
\item Die Methode $\textsl{deepCopy}()$ erzeugt eine Kopie einer gegebenen Menge.  Diese Methode ist
      einem Konstruktor-Aufruf der Form
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{new ComparableSet<T>}(s)$
      \\[0.2cm]
      dann vorzuziehen, wenn sich der \texttt{TreeSet} $s$ \"andern kann, denn dann w\"urde sich auch der
      erzeugte \texttt{ComparableSet<T>} \"andern.
\item Eine Reihe von Methoden werden in den Zeilen 15 -- 21 dadurch implementiert, dass
      die entsprechenden Methoden der Klasse \texttt{TreeSet} aufgerufen werden.
\item Die Methode $\textsl{equals}()$ erm\"oglicht uns, ein Objekt vom Typ
      \texttt{ComparableSet} mit einem beliebigen anderem Objekt zu vergleichen.
\item Der Aufruf $c.\textsl{member}(e)$ \"uberpr\"uft, ob $e$ ein Element der Menge $c$ ist.
\item Der Aufruf $c.\textsl{isSubset}(s)$ \"uberpr\"uft, ob $c$ eine Teilmenge der Menge $s$ ist.
\item Der Aufruf $c.\textsl{compareTo}(s)$ vergleicht die Menge $c$ mit der Menge $s$.
      Der Vergleich ist ein \emph{lexikografischer} Vergleich.  Da sowohl $c$ als auch $s$
      geordnete Mengen sind, lassen sich die Elemente von $c$ und $s$ der Gr\"o{\ss}e nach
      auflisten.  Wir vergleichen nun die Elemente von $c$ und $s$ paarweise, wobei wir
      mit dem kleinsten Element beginnen.  Das erste Element, bei dem sich die Mengen $c$
      und $s$ unterscheiden, entscheidet dann \"uber den Vergleich.
      Werden beispielsweise die Mengen
      \\[0.2cm]
      \hspace*{1.3cm}
      $c = \{ 2, 7 \}$ \quad und \quad $s = \{ 2, 3, 7, 14 \}$
      \\[0.2cm]
      auf diese Weise verglichen, so vergleichen wir zun\"achst das kleinste Element
      beider Mengen.  Das ist die $2$.  Da dieses Element f\"ur beide Mengen gleich ist,
      gehen wir zum zweiten Element.  In der Menge $c$ finden wir hier die $7$, in der
      Menge $s$ steht hier die $3$.  Da $3 < 7$ ist, ist folgern wir $s < c$.

      Falls die Ordnung auf den Elementen eine totale Ordnung ist, so l\"asst sich zeigen,
      dass auch die lexikografische Ordnung, die auf Mengen von Mengen definiert ist, eine
      totale Ordnung ist. 
\item Anschlie{\ss}end definieren wir die Methoden 
      $\textsl{union}()$,
      $\textsl{intersection}()$ und
      $\textsl{difference}()$ so, dass die Methoden  die Vereinigung, den Schnitt und die
      Mengendifferenz berechnen.  Der wesentliche Unterschied zu den analogen Methoden der
      Klasse \texttt{TreeSet} besteht hier darin, dass beispielsweise bei dem Aufruf 
      $c.\textsl{union}(s)$ die Menge $c$ nicht ver\"andert wird.
\item Der Aufruf $c.\textsl{product}(s)$ bildet das kartesische Produkt der Mengen
      $c$ und $s$, es gilt also 
      \\[0.2cm]
      \hspace*{1.3cm}
      $c.\textsl{product}(s) = \bigl\{ \pair(x,y) \mid x \in c \wedge y \in s \bigr\}$.
      \\[0.2cm]
      Damit die Implementierung dieser Methode funktioniert,  muss die Klasse \texttt{Pair} so definiert
      sein, dass die Klasse \texttt{Pair<S,T>} das Interface \texttt{Comparable} implementiert.
      Abbildung  \ref{fig:Pair.java} auf Seite \pageref{fig:Pair.java} zeigt die Implementierung dieser Klasse.
\item Der Aufruf $c.\textsl{powerSet}()$ berechnet die Potenz-Menge von $c$.
      Die Implementierung geschieht unter Zuhilfenahme der statischen Methode
      $\textsl{powerSet}(s)$, die f\"ur einen gegeben \texttt{TreeSet} $s$ die Potenz-Menge 
      berechnet. Die Implementierung der Methode $\textsl{powerSet}()$ basiert auf den folgenden Gleichungen:
      \begin{enumerate}
      \item $\textsl{powerSet}\bigl(\{\}\bigr) = \bigl\{ \{\} \bigr\}$,
      \item $\textsl{powerSet}\bigl(A \cup \{x\} \bigr) = 
             \textsl{powerSet}(A) \cup \bigl\{ \{x\} \cup s : s \in \textsl{powerSet}(A) \bigr\}$.
      \end{enumerate}
      Die Methode $\textsl{headSet}()$, die bei der Realisierung benutzt wird, kann wir
      folgt spezifiziert werden: Der Aufruf $s.\textsl{headSet}(l)$ liefert alle alle
      Elemente aus der Menge $s$, die kleiner als $l$ sind:
      \[ s.\textsl{headSet}(l) = \{ x \in s \mid x < l \}. \]
      Der Aufruf $s.\textsl{last}()$ liefert das gr\"o{\ss}te Element der Menge $s$.  Damit k\"onnen wir
      eine Menge $s$ in der Form
      \\[0.2cm]
      \hspace*{1.3cm}
      $s = \{ s.\textsl{last}() \} \cup s.\textsl{headSet}(s.\textsl{last}())$
      \\[0.2cm]
      in eine einelementige Menge und die restlichen Elemente disjunkt zerlegen.
\item F\"ur eine Menge von Mengen $S$ f\"ugt der Aufruf $\textsl{addElement}(S, e)$ das Element $e$ in jede Menge
      aus $S$ ein: 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{addElement}(S,e) = \bigl\{ m \cup \{e\} \mid m \in S \bigr\}$.
\item F\"ur eine Menge von Mengen $S$ liefert der Aufruf $c.\textsl{cloneSet}(S)$
      eine Kopie der Menge $S$, die nicht die Mengen von $S$ enth\"alt sondern Kopien
      dieser Mengen.
\item Der Aufruf $\textsl{singleton}(x)$ liefert die Menge $\{x\}$.
\item Der Aufruf $\textsl{doubleton}(x,y)$ liefert die Menge $\{x,y\}$.
\item Der Aufruf $\textsl{range}(a,b)$ liefert die Menge 
      \\[0.2cm]
      \hspace*{1.3cm} $\{ n \in \mathbb{Z} \mid a \leq n \wedge n \leq b \}$.
\item Die Methode $\textsl{compose}(R_1, R_2)$ berechnet das relationale Produkt 
      $R_1 \circ R_2$ der Relationen $R_1$ und $R_2$.  Dieses Produkt ist wie folgt 
      definiert:
      \[ 
      R_1 \circ R_2 = \bigl\{ \pair(x,z) \mid \exists y : \pair(x,y) \in R_1 \wedge \pair(y,z) \in R_2 \bigl\}. 
      \]
\item Die Methode $\textsl{select}()$ gestattet die Mengenbildung durch Auswahl.
      Der Aufruf $c.\textsl{select}(s)$ berechnet f\"ur eine Menge $c$ und einen
      \emph{Selektor} $s$ die Menge 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\{ x \in c \mid s.\textsl{select}(x) \}$.
      \\[0.2cm]
      Ein Selektor ist dabei einfach ein Objekt $s$, dass eine Methode
      $s.\textsl{select}(x)$ zur Verf\"ugung stellt.  Diese Methode gibt als Ergebnis 
      entweder \texttt{true} oder \texttt{false} zur\"uck.  Abbildung
      \ref{fig:Selector.java} zeigt das Interface \texttt{Selector}.

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public interface Selector<T> {
        public boolean select(T element);
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Das Interface \texttt{Selector}.}
\label{fig:Selector.java}
\end{figure}

\item Die Methode $\textsl{transform}()$ berechnet eine Bild-Menge.
      Der Aufruf $c.\textsl{transform}(t)$ berechnet f\"ur einen
      \emph{Transformer} $t$ die Menge
      \\[0.2cm]
      \hspace*{1.3cm}
      $\bigl\{ t.\textsl{transform}(x) \mid x \in c \bigr\}$.
      \\[0.2cm]
      Ein Transformer ist hier ein Objekt, dass eine Methode
      $\textsl{transform}()$ zur Verf\"ugung stellt, mit der Elemente einer Menge \texttt{T}
      in Elemente einer Menge \texttt{S} umgewandelt werden k\"onnen.
      Abbildung
      \ref{fig:Transformer.java} zeigt das Interface \texttt{Transformer}.

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public interface Transformer<S extends Comparable<? super S>, 
                                 T extends Comparable<? super T>> 
    {
        public S transform(T x);
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Das Interface \texttt{Transformer}.}
\label{fig:Transformer.java}
\end{figure}

\item Die Methode $\textsl{combineSets}(s_1, s_2, k)$ verkn\"upft zwei Mengen 
      mit einem \emph{Kombinator} $k$.  Es gilt
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{combineSets}(s_1, s_2, k) = 
      \bigl\{ k.\textsl{combine}(x,y) \mid x \in s_1 \wedge y \in s_2 \bigr\}$
      \\[0.2cm]
      Ein \emph{Kombinator} ist  ein Objekt, dass eine Methode
      $\textsl{combine}()$ zur Verf\"ugung stellt, mit dem zwei Elemente 
      verkn\"upft werden k\"onnen.
      Abbildung
      \ref{fig:Combinator.java} zeigt das Interface \texttt{Combinator}.

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public interface Combinator<T, X, Y>
    {
        public T combine(X x, Y y);
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Das Interface \texttt{Combinator}.}
\label{fig:Combinator.java}
\end{figure}
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class Pair<S extends Comparable<? super S>, 
                      T extends Comparable<? super T>> 
        implements Comparable<Pair<S,T>>
    {
        S mFirst;
        T mSecond;
        
        public Pair(S first, T second) {
            mFirst  = first;
            mSecond = second;
        }
        public int compareTo(Pair<S, T> pair) {
            int cmpFirst = mFirst.compareTo(pair.getFirst());
            if (cmpFirst < 0 || cmpFirst > 0) {
                return cmpFirst;
            }
            return mSecond.compareTo(pair.getSecond());
        }
        public String toString() {
            return "<" + mFirst + ", " + mSecond + ">";
        }
        public S getFirst()  { return mFirst;  }
        public T getSecond() { return mSecond; }
    
        public void setFirst(S first) { 
            mFirst = first; 
        }
        public void setSecond(T second) { 
            mSecond = second; 
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{Pair}.}
\label{fig:Pair.java}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class ComparableList<T extends Comparable<? super T>> 
        extends LinkedList<T>
        implements Comparable<ComparableList<T>>
    {
        public int compareTo(ComparableList<T> comparableList) { 
            Iterator<T> iterFirst  = iterator();
            Iterator<T> iterSecond = comparableList.iterator();
            while (iterFirst.hasNext() && iterSecond.hasNext()) {
                T   first  = iterFirst .next();
                T   second = iterSecond.next();
                int cmp    = first.compareTo(second);
                if (cmp == 0) {
                    continue;
                }
                return cmp;
            }
            if (iterFirst.hasNext()) {
                return 1;
            }       
            if (iterSecond.hasNext()) {
                return -1;
            }
            return 0;
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{ComparableList}.}
\label{fig:ComparableList.java}
\end{figure}

\subsection{Die Klasse \texttt{ComparableList}}
Nachdem wir nun mit Mengen so arbeiten k\"onnen, wie wir dass in dr Sprache \textsl{Setl} gewohnt sind,
ben\"otigen wir als n\"achstes eine Klasse \texttt{ComparableList}, die Listen darstellt und au{\ss}erdem das
Interface \texttt{Comparable} implementiert.  Die Implementierung dieser Klasse ist in Abbildung
\ref{fig:ComparableList.java} auf Seite \pageref{fig:ComparableList.java} gezeigt.  Bei der L\"osung des
Wolf-Ziege-Kohl-Problems haben wir Listen nur ben\"otigt, um die verschiedenen Pfade in einem Graphen
darzustellen.  Wir haben keine Operationen benutzt die Listen manipulieren.  Daher reicht es f\"ur dieses
Beispiel aus, wenn wir die Klasse \texttt{ComparableList} von \texttt{LinkedList} ableiten.  In diesem
Fall muss nur die Methode $\textsl{compareTo}()$ implementiert werden.  Dies geschieht \"ahnlich wie bei
Mengen \"uber einen lexikografischen Vergleich der beiden Listen.
\pagebreak
\vspace*{\fill}

\pagebreak

\vspace*{\fill}

\pagebreak


\subsection{L\"osung des Wolf-Ziege-Kohl-Problems in \textsl{Java}}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    #define Point     ComparableSet<String>
    #define PointPair Pair<Point, Point>
    
    public class WolfZiegeKohl 
    {    
        public static void main(String args[]) {
            Point all = new Point();
            all.add("Bauer");
            all.add("Wolf");
            all.add("Ziege");
            all.add("Kohl");
            ComparableSet<Point> p = all.powerSet();
            ComparableSet<PointPair> r = new ComparableSet<PointPair>();
            for (Point s: p) {
                for (Point b : s.powerSet()) {
                    Point sb = s.difference(b);
                    if (b.member("Bauer") && b.size() <= 2 && !problem(sb)) 
                    {
                        PointPair ssb = new PointPair(s, sb);
                        r.add(ssb); 
                    }
                }
            }
            for (Point s: p) {
                Point as = all.difference(s);
                for (Point b : as.powerSet()) {
                    if (b.member("Bauer") && b.size() <= 2 && 
                        !problem(as.difference(b))           ) 
                    {
                        Point sb = s.union(b);
                        PointPair ssb = new PointPair(s, sb);
                        r.add(ssb); 
                    }
                }
            }
            Point goal = new Point();
            Relation<Point> relation = new Relation(r);
            ComparableList<Point> path = relation.findPath(all, goal);
            for (Point left : path) {
                Point right = all.difference(left);
                System.out.println(left + ", " + right);
            }
        }
        static boolean problem(Point s) {
            return (s.member("Ziege") && s.member("Kohl")) || 
                   (s.member("Wolf") && s.member("Ziege"));
        }
    }   
\end{Verbatim}
\vspace*{-0.3cm}
\caption{L\"osung des Wolf-Ziege-Kohl-Problems.}
\label{fig:WolfZiegeKohl.jpre}
\end{figure}


\noindent
Nach dem wir uns im letzten Abschnitt einen Rahmen geschaffen haben, in dem konzeptionell
dieselben Funktionen wie in \textsl{Setl} zur Verf\"ugung stehen, k\"onnen wir nun daran
gehen, das im ersten Semester entwickelte \textsl{Setl}-Programm in \textsl{Java} zu \"ubersetzen.
Abbildung \ref{fig:WolfZiegeKohl.jpre} zeigt das Ergebnis dieser Übersetzung.
\begin{enumerate}
\item In den ersten beiden Zeilen definieren wir zwei Abk\"urzungen.  Zum einen m\"ochten wir
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{Point} \quad als Abk\"urzung f\"ur \quad \texttt{ComparableSet<String>}
      \\[0.2cm]
      benutzen, zum anderen steht
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{PointPair} \quad als Abk\"urzung f\"ur \quad \texttt{Pair<Point, Point>}.
      \\[0.2cm]
      Durch die Verwendung dieser Abk\"urzungen ersparen wir es uns, sp\"ater mit
      unlesbaren Klassenbezeichnungen der Form
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{ComparableSet<Pair<ComparableSet<String>, ComparableSet<String>>>}
      \\[0.2cm]
      arbeiten zu m\"ussen.  Leider gibt es in der Sprache \textsl{Java} (im Gegensatz zu der
      Sprache \texttt{C\#}) keine
      M\"oglichkeit, Abk\"urzungen zu definieren, denn ein zu einem \texttt{typedef} analoges
      Konstrukt, wie Sie es beispielsweise in der Sprache \texttt{C} finden,
      gibt es in \textsl{Java} nicht.  Wir behelfen uns mit einem Trick und verwenden den
      \texttt{C}-Pr\"aprozessor, denn dieser kann Makros expandieren.  Daher haben wir in
      den ersten beiden Zeilen die entsprechenden Abk\"urzungen mit Hilfe der
      Pr\"aprozessor-Direktive ``\texttt{\#define}'' definiert.
      Um diese Abk\"urzungen expandieren zu k\"onnen, speichern wir das in Abbildung
      \ref{fig:WolfZiegeKohl.jpre} gezeigte Programm in einer Datei mit dem Namen
      \texttt{WolfZiegeKohl.jpre} und rufen dann den \texttt{C}-Pr\"aprozessor mit dem Befehl
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{cpp -P WolfZiegeKohl.jpre WolfZiegeKohl.java}
      \\[0.2cm]
      auf.  Dieser Befehl expandiert die Makro-Definitionen und schreibt das Ergebnis in
      die Datei \texttt{WolfZiegeKohl.java}.  Die Option ``\texttt{-P}'' ist hier
      notwendig um die Zeilenmarkierungen, die andernfalls vom Pr\"aprozessor erzeugt
      w\"urden, zu unterdr\"ucken. 
\item Die Klasse \texttt{WolfZiegeKohl} enth\"alt nur die Methode $\textsl{main}()$.
      Diese Methode l\"ost das Problem und gibt die L\"osung (allerdings sehr spartanisch) aus.
      Zun\"achst bilden wir dort die Menge  \texttt{all}, die die Strings
      ``\texttt{Bauer}'',
      ``\texttt{Wolf}'',
      ``\texttt{Ziege}'',
      ``\texttt{Kohl}'' enth\"alt.
\item Die Menge \texttt{p} ist die Potenz-Menge von \texttt{all}.  
\item Die Menge \texttt{r} beschreibt die Zustands\"ubergangsrelation.
      Diese Relation wird in den beiden \texttt{for}-Schleifen in den Zeilen
      14 -- 23 und 24 -- 35 berechnet.
      Die erste \texttt{for}-Schleife berechnet die Überg\"ange, bei denen
      das Boot von links nach rechts \"ubersetzt.  Mathematisch k\"onnen diese Überg\"ange wie
      folgt zu einer Relation zusammengefast werden:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\bigl\{ \pair(s, s - b) \colon s \in p, b \in  2^s \mid
               \mathtt{\symbol{34}bauer\symbol{34}} \in b \wedge \#b \leq 2 \wedge \neg
               \textsl{problem}(s - b) \}$
      \\[0.2cm]
      Die Variable $s$ ist hier die Menge der Objekte am linken Ufer und ist daher ein
      Element der Menge $p$, denn $p$ ist ja die Potenz-Menge von \texttt{all}.  Die
      Variable $b$ bezeichnet die Menge der Objekte, die im Boot vom linken Ufer zum
      rechten Ufer \"ubersetzen.  Diese Menge ist eine
      Teilmenge von $s$ und damit ein Element der Potenz-Menge von $s$.  
      Die Menge \texttt{sb} besteht
      aus den Objekten, die nach der Überfahrt am linken Ufer verbleiben.
      Das ist gerade die Mengendifferenz $s \backslash b$.  
      
      Damit eine Überfahrt legal ist, m\"ussen folgende Bedingungen erf\"ullt sein:
      \begin{enumerate}
      \item Der Bauer muss im Boot sitzen: 
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{b.member(\symbol{34}Bauer\symbol{34})}.
      \item Im Boot d\"urfen sich maximal zwei Objekte befinden:
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{b.size() <= 2}
      \item Es darf nach der Überfahrt am linken Ufer kein Problem geben:
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{!problem(sb)}
      \end{enumerate}
      Diese Bedingungen werden durch die \texttt{if}-Abfrage in Zeile 17 sichergestellt.
      Wenn die Bedingungen erf\"ullt sind, wird das Paar $\pair(\mathtt{s}, \mathtt{sb})$
      der Relation $r$ hinzugef\"ugt.
\item Die Überg\"ange, bei denen das Boot von rechts nach links f\"ahrt, werden analog
      berechnet.  Mathematisch hat diese Relation die Form
      \\[0.2cm]
      \hspace*{1.3cm}
      $\bigl\{ \pair(s, s + b) \colon s \in p, b \in 2^{\mathtt{all} - s} \mid
              \mathtt{\symbol{34}Bauer\symbol{34}} \in b \wedge \#B \leq 2 \wedge \neg
              \mathtt{problem}((\mathtt{all} \backslash s) \backslash b) 
       \bigr\}
      $.
      \\[0.2cm]
      Da $s$ wieder die Menge der Objekte am linken Ufer ist, finden wir die Menge der Objekte
      am rechten Ufer, indem wir die Menge $\mathtt{all} \backslash s$ bilden.  Diese
      Menge wird im Programm mit \texttt{as} bezeichnet.  Das Boot, also die Menge der
      Objekte, die von rechts nach links \"ubersetzen, ist daher nun eine Teilmenge von \texttt{as}.
      Der Rest der Rechnung ist nun analog zum ersten Fall.
\item Anschlie{\ss}end wird in Zeil 36 der Zielzustand definiert:
      Am Ende sollen alle Objekte am rechten Ufer sein.  Links ist dann niemand mehr,
      folglich ist die entsprechende Menge leer.  Da der Aufruf
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{new Point()}
      \\[0.2cm]
      vom Pr\"aprozessor zu
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{ComparableSet<String>()}
      \\[0.2cm]
      expandiert wird, wird in Zeile 36 als Zielzustand tats\"achlich die leere Menge
      berechnet.
\item Die Zuweisung ``\texttt{relation = new Relation(r)}'' wandelt nun die Menge von
      Paaren von Zust\"anden in ein Objekt der Klasse \texttt{Relation} um, die es uns
      \"uber den Aufruf von $\textsl{findPath}()$ erm\"oglicht, einen Weg vom Start
      zum Ziel zu berechnen.  
\item Die Methode $\textsl{problem}(s)$ \"uberpr\"uft f\"ur eine gegebene Menge von Objekten,
      ob es zu einem Problem kommt, weil entweder die Ziege den Kohl oder der Wolf die
      Ziege frisst.
\end{enumerate}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    public class Relation<E extends Comparable<? super E>>
    {
        ComparableSet<Pair<E, E>> mR;
        
        public Relation(ComparableSet<Pair<E, E>> r) { mR = r; }
    
        public ComparableList<E> findPath(E start, E goal) {
            ComparableList<E> first = new ComparableList<E>();
            first.add(start);
            ComparableSet<ComparableList<E>> p    = ComparableSet.singleton(first);
            ComparableSet<ComparableList<E>> oldP = null;
            while (true) {
                oldP = p;
                p    = p.union(pathProduct(p));
                for (ComparableList<E> l : p) {
                    if (l.getLast().compareTo(goal) == 0) {
                        return l;
                    }
                }
                if (p.compareTo(oldP) == 0) {
                    return null;
                } 
            }
        }
        private ComparableSet<ComparableList<E>> 
            pathProduct(ComparableSet<ComparableList<E>> P) 
        {
            ComparableSet<ComparableList<E>> result = 
                new ComparableSet<ComparableList<E>>();
            for (ComparableList<E> p : P) {
                for (Pair<E, E> q : mR) {
                    if (p.getLast().compareTo(q.getFirst()) == 0) {
                        ComparableList<E> pq = new ComparableList<E>(p);
                        E second = q.getSecond();
                        pq.add(second);
                        if (!cyclic(pq)) {
                            result.add(pq);
                        }
                    }
                }
            }
            return result;
        }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{Relation}.}
\label{fig:Relation.java}
\end{figure}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = last,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
        private static <T extends Comparable<? super T>>
                boolean cyclic(ComparableList<T> l) 
        {
            ComparableSet<T> all = new ComparableSet<T>();
            for (T x : l) {
                all.add(x);
            }
            return all.size() < l.size();
        }        
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Methode $\textsl{cyclic}()$.}
\label{fig:cyclic.java}
\end{figure}
      

\noindent
Als letztes diskutieren wir die Implementierung der Klasse \texttt{Relation}.
Diese Klasse verwaltet eine Menge von Paaren, die einen Graphen repr\"asentiert.
Diese Klasse stellt drei Methoden zur Verf\"ugung.
\begin{enumerate}
\item Die Methode $r.\mathtt{findPath}(x,y)$ berechnet einen Pfad, der von dem Punkt $x$
      zu dem Punkt $y$ f\"uhrt.
\item Die Methode $R.\textsl{pathProduct}(P)$ berechnet f\"ur eine Relation $R$ und
      eine Menge von Pfaden $P$ das sogenannte Pfad-Produkt $P \bullet R$, das f\"ur eine Relation $R$
      und eine Menge von Pfaden $P$ wie folgt definiert ist:
      \[ 
         P \bullet R = \bigl\{\; l + [y] \mid 
         l \in P \wedge \pair(x,y) \in R \wedge \textsl{last}(l) = x \;\bigr\}.
      \]
      F\"ur einen Pfad $p$ bezeichnet dabei $\textsl{last}(p)$ den letzten Punkt des
      Pfades.  Anschaulich gesehen werden bei der Berechnung von $P \bullet R$
      die Pfade aus $P$ um die Relation $R$ verl\"angert:  Wenn einerseits eine Liste $l$ aus
      $P$ mit einem Punkt $x$ endet und wenn andererseits die Relation $R$
      ein Paar der Form $\pair(x, y)$ enth\"alt, dann kann das Element $y$ an die Liste $l$
      angeh\"angt werden.
\item Die Methode $\textsl{cyclic}()$ \"uberpr\"uft f\"ur eine gegebene Liste $l$, ob diese
      Liste ein Element mehrfach enth\"alt und damit einen zyklischen Pfad darstellt.
      Um dies zu pr\"ufen wird die Liste in eine Menge umgewandelt.  Wenn die Menge genauso
      viele Elemente enth\"alt wie die Liste, dann kann die Liste kein Element doppelt
      enthalten haben und ist damit nicht zyklisch.
\end{enumerate}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "algorithmen"
%%% End: 
