\chapter{Der Hoare-Kalk\"ul} 
In diesem Kapitel stellen wir den \emph{Hoare-Kalk\"ul} vor, mit dessen Hilfe sich die
Korrektheit nicht-rekursiver Programme zeigen l\"asst.
Dieses Hilfsmittel ist der \emph{Hoare-Kalk\"ul}, der 1969 von C.~A.~R.~Hoare 
\cite{hoare:69} vorgestellt wurde.

\section{Vor- und Nachbedingungen}
Grundlage des Hoare-Kalk\"ul sind sogenannte \emph{Vor-} und \emph{Nach-Bedingungen}.  Ist
\texttt{P} ein Programm-Fragment und sind $F$ und $G$ logische Formeln, so sagen wir, dass
$F$ eine Vor-Bedingung und $G$ eine Nach-Bedingung f\"ur das Programm-Fragment \texttt{P}
ist, falls folgendes gilt: Wird das Programm-Fragment \texttt{P} in einer Situation
ausgef\"uhrt, in der vor der Ausf\"uhrung von \texttt{P} die Formel $F$ gilt, so gilt nach der
Ausf\"uhrung von $P$ die Formel $G$.  Dies schreiben wir als
\[ \hoare{F}{P}{G} \]
und sagen, dass \emph{$P$ die Spezifikation ``wenn vorher $F$, dann nachher $G$''} erf\"ullt.
Die Spezifikation 
\[ \hoare{F}{P}{G} \]
wird in der Literatur  als \emph{Hoare-Tripel} 
bezeichnet, denn diese Notation wurde von Sir Charles Antony Richard Hoare (geb.~1934) \cite{hoare:69}
eingef\"uhrt.
\vspace*{0.3cm}

\noindent
\textbf{Beispiele}:
\begin{enumerate}
\item Das Programm-Fragment, das nur aus der Zuweisung  ``\texttt{x := 1;}'' besteht,
      erf\"ullt trivialerweise die Spezifikation
      \[ \hoare{\mathtt{true}}{x := 1;}{x = 1}. \]
      Hier ist die Vorbedingung die triviale Bedingung \texttt{true}, denn
      die Nachbedingung $x = 1$ ist in jedem Fall richtig.
\item Das Programm-Fragment, das aus der Zuweisung  ``\texttt{x = x + 1;}'' besteht,
      erf\"ullt die Spezifikation
      \[ \hoare{x=1}{x := x + 1;}{x=2}. \]
      Hier ist die $x = 1$ die Vorbedingung und die Nachbedingung ist $x = 2$.
\item Wir betrachten wieder as Programm-Fragment  ``\texttt{x = x + 1;}'' und w\"ahlen als
      Vorbedingung diesmal die Formel $\textsl{prim}(x)$, die ausdr\"uckt, dass $x$ eine
      Primzahl ist.  Das entsprechende Hoare-Tripel ist diesmal
      \[ \hoare{\textsl{prim}(x)}{x := x + 1;}{\textsl{prim}(x-1)}. \]
      Auf den ersten Blick sieht das seltsam aus.  Viele Studenten denken zun\"achst, dass
      dieses Hoare-Tripel die Form
      \[ \hoare{\textsl{prim}(x)}{x := x + 1;}{\textsl{prim}(x+1)} \] 
      haben m\"usste.  Das diese letzte Zeile falsch ist, k\"onnen wir sehen, wenn wir f\"ur $x$
      den Wert $2$ einsetzen, dann dann ist die Vorbedingung $\textsl{prim}(2)$ erf\"ullt.
      Nach der Ausf\"uhrung der Zuweisung hat $x$ den Wert $3$ und
      \\[0.2cm]
      \hspace*{1.3cm}
      $x - 1 = 3 - 1 = 2$
      \\[0.2cm]
      ist immer
      noch eine Primzahl, aber offenbar ist
      \\[0.2cm]
      \hspace*{1.3cm}
      $x + 1 = 3 + 1 = 4 = 2 \cdot 2$ 
      \\[0.2cm]
      keine Primzahl!
\end{enumerate}
Wir \"uberlegen uns nun, wie sich die verschiedenen Teile eines Programms mit Hilfe von
Hoare-Tripeln spezifizieren lassen.  Die elementarsten Bestandteile eines Programms sind
die Zuweisungen.  Wir fangen daher mit der Analyse der Zuweisungen an.
 
\subsection{Spezifikation von Zuweisungen}
Wir wollen das letzte Beispiel verallgemeinern und untersuchen, wie sich die Vor- und
Nachbedingungen bei einer Zuweisung der Form 
\[ \texttt{x := h(x);} \]
zueinander verhalten.  Konkret stellen wir uns die Frage, wie wir die Nachbedingung $G$
aus einer bereits bekannten Vorbedingung $F$ berechnen k\"onnen.  Zur Vereinfachung nehmen
wir an, dass die Funktion $h$ umkehrbar ist, dass es also eine Umkehr-Funktion $h^{-1}$ gibt,
so dass f\"ur alle $x$ gilt 
\[ h^{-1}\bigl(h(x)\bigr) = x \quad \mathtt{und} \quad h\bigl(h^{-1}(x)\bigr) = x. \]
Um die Sache konkret zu machen, betrachten wir ein Beispiel.  Die Zuweisung 
\[ \texttt{x := x + 1;} \]
k\"onnen wir in der Form 
\[ \texttt{x := h(x);} \]
schreiben. Die Funktion $h$ hat dann die Form 
\[ h(x) = x + 1 \]
und die Umkehr-Funktion  ist offenbar 
\[ h^{-1}(x) = x - 1, \]
denn um die Addition von 1 r\"uckg\"angig zu machen, m\"ussen wir 1 subtrahieren.
Mit der Umkehr-Funktion l\"asst sich nun die Nachbedingung der Zuweisung ``\texttt{x := h(x);}'' aus der
Vorbedingung berechnen, denn es gilt
\[ \hoare{F}{x := h(x);}{F\sigma} \quad \mathrm{mit} \quad \sigma = \bigl[x \mapsto h^{-1}(x)\bigr]. \]
Hier bezeichnet $F\sigma$ die Anwendung der Substitution
$\sigma$ auf die Formel $F$: $F\sigma$ ist
dadurch definiert, dass alle Auftreten der Variable $x$ durch den Term $h^{-1}(x)$ ersetzt
werden.  Um zu verstehen warum die Nachbedingung sich gerade so berechnet, greifen wir das
Beispiel $\texttt{x := x + 1}$ wieder auf und w\"ahlen als Vorbedingung $F$ die Formel 
$x = 7$.  Wegen $h^{-1}(x) = x - 1$ hat die Substitution $\sigma$ die Form
$\sigma = [ x \mapsto x - 1 ]$ und damit hat $F\sigma$ die Form 
\[ (x = 7)[x \mapsto x - 1] \;\equiv\; (x - 1 = 7). \]
(An dieser Stelle habe ich das Zeichen ``$\equiv$'' benutzt, um die syntaktische Gleichheit
von Formeln ausdr\"ucken zu k\"onnen, die ihrerseits das Gleichheitszeichen ``$=$''
enthalten.)  Damit lautet die Spezifikation also 
\[ \hoare{x = 7}{x := x + 1;}{x - 1 = 7}. \]
Wegen der \"Aquivalenz $x - 1 = 7 \leftrightarrow x = 8$ ist das logisch dasselbe wie
\[ \hoare{x = 7}{x := x + 1;}{x = 8} \]
und diese Spezifikation ist offenbar korrekt, denn wenn $x$ vor der Zuweisung
``\texttt{x := x + 1;}'' den Wert $7$ hat, dann hat $x$ hinterher den Wert 8.

Wir \"uberlegen uns nun, warum das Hoare-Tripel
\[ \hoare{F}{x := h(x);}{F\sigma} \quad \mathrm{mit} \quad \sigma = \bigl[x \mapsto h^{-1}(x)\bigr] \]
korrekt ist: Bevor die Zuweisung ``x \texttt{:=} h(x);'' durchgef\"uhrt wird,
hat die Variable $x$ einen festen Wert, den wir mit $x_0$ bezeichnen.  F\"ur diesen
Wert $x_0$ gilt die Formel $F$, es gilt also vor der Zuweisung $F[x \mapsto x_0]$.
In der Formel $F[x \mapsto x_0]$ tritt die Variable $x$ nicht mehr auf, denn wir haben
diese Variable ja durch den Wert $x_0$ ersetzt.  Damit bleibt die Formel
\[ F[x \mapsto x_0] \]
auch nach der Zuweisung  ``\texttt{x = h(x);}'' g\"ultig.  Nach der Zuweisung
hat die Variable $x$ aber den Wert $x = h(x_0)$.  Diese Gleichung l\"osen wir nach $x_0$
auf und finden 
\[ x_0 = h^{-1}(x). \]
Damit gilt also nach der Zuweisung die Formel 
\[ F[x \mapsto x_0] \equiv  F[x \mapsto h^{-1}(x)]. \]
Betrachten wir zum Abschluss dieser Diskussion ein weiteres Beispiel.  Es sei \textsl{prim}
ein einstelliges Pr\"adikat, so dass $\textsl{prim}(x)$ genau dann wahr ist, wenn $x$ eine
Primzahlen ist.
Dann gilt 
\[ \hoare{\texttt{prim}(x)}{x := x + 1;}{\texttt{prim}(x-1)}. \]
Anschaulich ist das klar: Wenn die Zahl $x$ eine Primzahl ist und $x$ um den Wert Eins
inkrementiert wird, dann ist hinterher die Zahl $x-1$ eine Primzahl.

\paragraph{Andere Formen von Zuweisungen}
Nicht immer haben Zuweisungen die Form ``\texttt{x = h(x);}'' mit einer invertierbaren
Funktion $h$.  Oft wird einer Variable $x$ eine Konstante $c$ zugewiesen.  Falls die
Variable $x$ in der Formel $F$ nicht vorkommt, gilt dann offenbar
\[ \hoare{F}{x := c;}{F \wedge x = c}. \]
Die Formel $F$ kann hier daf\"ur benutzt werden, um den Wert anderer Variablen einzugrenzen.

\paragraph{Allgemeine Zuweisungs-Regel}
In der Literatur findet sich die folgende Regel f\"ur Zuweisungen
\[ \hoare{F[x \mapsto t]}{x := t;}{F}. \]
Hierbei ist $t$ ein beliebiger Term, der die Variable $x$ enthalten kann.  Diese Regel ist
wie folgt zu lesen: 
\\[0.2cm]
\hspace*{1.3cm}
\begin{minipage}[c]{0.8\linewidth}
``\emph{Gilt die Formel $F(t)$ und weisen wir der Variablen $x$ den
        Wert $t$ zu, so gilt danach die Formel $F(x)$.}'' 
\end{minipage}
\\[0.2cm]
Die Korrektheit dieser Regel ist offensichtlich,
aber in der vorliegenden Form ist die Regel nicht sehr n\"utzlich, denn um Sie anwenden zu
k\"onnen, muss die Vorbedingung erst auf die Form $F(t)$, also $F[x \mapsto t]$ gebracht werden. 

\subsection{Die Abschw\"achungs-Regel}
Erf\"ullt ein Programm-Fragment $P$ die Spezifikation 
\[ \hoare{F}{P}{G} \]
und folgt aus der Formel $G$ die Formel $H$, gilt also
\[ G \rightarrow H, \]
so erf\"ullt das Programm-Fragment $P$ erst recht die Spezifikation 
\[ \hoare{F}{P}{H}, \]
denn wenn nach Ausf\"uhrung von $P$ die Formel $G$ gilt, dann gilt die Formel $H$ erst recht.
Wir fassen diesen Tatbestand in einer \emph{Verifikations-Regel} zusammen:
\\[-0.2cm]
\[ \bruch{\quad \hoare{F}{P}{G}, \qquad G \rightarrow H \quad}{\hoare{F}{P}{H}}. \]
\"Uber dem Bruchstrich stehen hier die beiden \emph{Pr\"amissen} und unter dem Bruchstrich steht
die \emph{Konklusion}.  Die Konklusion und die erste Pr\"amisse sind 
Hoare-Tripel, die zweite Pr\"amisse  ist eine ganz normale logische Formel.
Falls die Pr\"amissen wahr sind, so gilt auch die Konklusion.

\subsection{Zusammengesetze Anweisungen}
Haben die Programm-Fragmente $\texttt{P}$ und $\texttt{Q}$ die Spezifikationen
\[ \hoare{F_1}{P}{G_1}  \quad \mathrm{und} \quad \hoare{F_2}{Q}{G_2}  \]
und folgt die Vorbedingung $F_2$ aus der Nach-Bedingung $G_1$, dann gilt f\"ur die 
Zusammensetzung $\texttt{P;Q}$ von $\texttt{P}$ und $\texttt{Q}$ die
Spezifikation 
\[ \hoare{F_1}{P;Q}{G_2} \]
denn wenn anfangs $F_1$ gilt und zun\"achst $P$ ausgef\"uhrt wird, dann gilt danach $G_1$.
Aus $G_1$ folgt $F_2$ und wenn das Programm-Fragment $Q$ in der Situation $F_2$ ausgef\"uhrt
wird, dann wissen wir, dass danach $G_2$ gilt.
Wir fassen diese \"Uberlegungen in einer Verifikations-Regel zusammen:
\\[-0.2cm]
\[ \bruch{\quad\hoare{F_1}{P}{G_1}, \qquad G_1 \rightarrow F_2, \qquad \hoare{F_2}{Q}{G_2}\quad}{
    \hoare{F_1}{P;Q}{G_2}} \]
Gelegentlich ist es bei dieser Verifikations-Regel so, 
dass die Formeln $G_1$ und $F_2$  identisch sind.  In diesem Fall ist die Implikation
$G_1 \rightarrow F_2$ trivial und kann weggelassen werden.  Dann nimmt die obige
Verifikations-Regel die folgende vereinfachte Form an:
\\[-0.2cm]
\[ \bruch{\quad\hoare{F_1}{P}{G_1}, \qquad \hoare{G_1}{Q}{G_2}\quad}{ \hoare{F_1}{P;Q}{G_2}} \]

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    x := x - y;
    y := y + x;
    x := y - x;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine trickreiche Implementierung zur Vertauschung zweier Werte.}
\label{fig:swap}
\end{figure}

\vspace*{0.3cm}

\noindent
\textbf{Beispiel:}
Wir betrachten  das in
Abbildung \ref{fig:swap} gezeigte Programm-Fragment.  Wir analysieren nun die Wirkung
dieses Programm-Fragments.  Dazu starten wir unsere Analyse mit der Vorbedingung
\[ \texttt{x} = a \wedge \texttt{y} = b. \]
Hier sind $a$ und $b$ zwei Variablen, in denen wir uns die Startwerte von \texttt{x} und
\texttt{y} merken.  Die erste Zuweisung liefert das Hoare-Tripel
\[ \hoare{\texttt{x} = a \wedge \texttt{y} = b}{x := x - y;}{(\texttt{x} = a \wedge \texttt{y} = b)\sigma} 
   \quad \mathrm{mit} \quad \sigma = [x \mapsto x + y],
\]
denn $x \mapsto x + y$ ist die Umkehr-Funktion von $x \mapsto x - y$.  F\"uhren wir die Substitution
aus, so erhalten wir
\begin{equation}
  \label{eq:swap1}
 \hoare{\texttt{x} = a \wedge \texttt{y} = b}{x := x - y;}{\texttt{x + y} = a \wedge \texttt{y} = b}.   
\end{equation}
Die zweite Zuweisung liefert das Hoare-Tripel
\[ \hoare{\texttt{x + y} = a \wedge \texttt{y} = b}{y := y + x;}{(\texttt{x + y} = a \wedge \texttt{y} = b)\sigma} 
   \quad \mathrm{mit} \quad \sigma = [y \mapsto y - x],
\]
denn $y \mapsto y - x$ ist die Umkehr-Funktion der Funktion $y \mapsto y + x$.
Ausf\"uhrung der Substitution liefert diesmal
\[ \hoare{\texttt{x + y} = a \wedge \texttt{y} = b}{y := y + x;}{
          \texttt{x + y - x} = a \wedge \texttt{y - x} = b}.
\]
Vereinfachen wir noch die Nachbedingung, so haben wir 
\begin{equation}
  \label{eq:swap2}
 \hoare{\texttt{x + y} = a \wedge \texttt{y} = b}{y := y + x;}{ \texttt{y} = a \wedge \texttt{y - x} = b}  
\end{equation}
gezeigt. Jetzt betrachten wir die letzte Zuweisung.  Wir erhalten
\[ \hoare{\texttt{y} = a \wedge \texttt{y - x} = b}{x := y - x;}{
          (\texttt{y} = a \wedge \texttt{y - x} = b)\sigma} 
   \quad \mathrm{mit} \quad \sigma = [x \mapsto y - x],
\]
denn $x \mapsto y - x$ ist die Umkehr-Funktion der Funktion $x \mapsto y - x$.
F\"uhren wir die Substitution aus, so ergibt sich
\[ \hoare{\texttt{y} = a \wedge \texttt{y - x} = b}{x := y - x;}{
          \texttt{y} = a \wedge \texttt{y - (y - x)} = b} 
\]
Vereinfachung der Nachbedingung liefert schlie{\ss}lich
\begin{equation}
  \label{eq:swap3}
  \hoare{\texttt{y} = a \wedge \texttt{y - x} = b}{x := y - x;}{ \texttt{y} = a \wedge \texttt{x} = b}.   
\end{equation}
Fassen wir die Hoare-Tripel (\ref{eq:swap1}), (\ref{eq:swap2}) und (\ref{eq:swap3})
zusammen, so erhalten wir
\begin{equation}
  \label{eq:swap}
  \hoare{\texttt{x} = a \wedge \texttt{y} = b}{x := x + y; y := y + x; x := y - x;}{ 
         \texttt{y} = a \wedge \texttt{x} = b}.   
\end{equation}
Das Hoare-Tripel (\ref{eq:swap}) zeigt, dass das Programm-Fragment aus Abbildung
\ref{fig:swap} die Werte der Variablen $x$ und $y$ vertauscht: Wenn vor der Ausf\"uhrung
dieses Programm-Fragments $x$ den Wert $a$ und $y$ den Wert $b$ hat, dann ist es nachher
gerade umgekehrt: $y$ hat den Wert $a$ und $x$ hat den Wert $b$.  Der in dem in Abbildung
\ref{fig:swap} gezeigte Trick wurde fr\"uher 
benutzt, um  Werte zu vertauschen, denn bei der oben angegebenen
Implementierung wird keine Hilfsvariable ben\"otigt, so dass wir bei der Umsetzung dieses
Programms in Assembler mit weniger Registern auskommen.

\subsection{Alternativ-Anweisungen}
Um die Wirkung einer Alternativ-Anweisung der Form 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{if ($B$)  P  else  Q }
\\[0.2cm]
zu berechnen, nehmen wir an, dass vor der Ausf\"uhrung dieser Anweisung die Vorbedingung
$F$ gilt.  Dann m\"ussen wir die Wirkung der Programm-Fragmente $P$ und $Q$ analysieren.
Wenn $P$ ausgef\"uhrt wird, k\"onnen wir neben $F$ noch die Bedingung $B$ annehmen, w\"ahrend
wir f\"ur die Ausf\"uhrung von $Q$ die zus\"atzliche Bedingung $\neg B$ annehmen k\"onnen.
Das liefert die folgende Verifikations-Regel:
\begin{equation}
  \label{eq:hoareIf}
  \bruch{\quad\hoare{F \wedge B}{P}{G}, \qquad \hoare{F \wedge \neg B}{Q}{G}\quad}{
              \hoare{F}{if ($B$) P else Q}{G}}  
\end{equation}
In der vorliegenden Form ist die Regel oft nicht unmittelbar anwendbar, denn die Analyse
der Programm-Fragmente \texttt{P} und \texttt{Q} liefert zun\"achst Hoare-Tripel der Form
\begin{equation}
  \label{eq:abschwaechung1}
 \hoare{F \wedge B}{P}{G_1} \qquad \mathrm{und} \qquad \hoare{F \wedge \neg B}{Q}{G_2},   
\end{equation}
wobei $G_1$ und $G_2$ zun\"achst verschieden sind.   Um die obige Regel dann trotzdem
anwenden zu k\"onnen suchen wir eine Formel $G$, die sowohl aus $G_1$ als auch aus $G_2$
folgt, f\"ur die also
\[ G_1 \rightarrow G \qquad \mathrm{und} \qquad G_2 \rightarrow G \]
gilt.  Haben wir eine solche Formel $G$ gefunden, dann k\"onnen wir mit Hilfe der
Abschw\"achungs-Regel (\ref{eq:abschwaechung1})
auf die G\"ultigkeit von
\[ \hoare{F \wedge B}{P}{G} \qquad \mathrm{und} \qquad \hoare{F \wedge \neg B}{Q}{G},    \] 
schlie{\ss}en und damit haben wir genau die Pr\"amissen, um die 
Verifikations-Regel (\ref{eq:hoareIf}) anwenden zu k\"onnen.
\vspace*{0.3cm}

\noindent
\textbf{Beispiel}:  Wir analysieren das folgende Programm-Fragment:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{if (x < y) \{ z := x; \} else \{ z := y; \}}
\\[0.2cm]
Wir starten mit der Vorbedingung 
\[ F = \bigl(\texttt{x} = a \wedge \texttt{y} = b\bigr) \]
und wollen zeigen, dass nach Ausf\"uhrung der obigen Alternativ-Anweisung die Nachbedingung
\[ G = \bigl(z = \textsl{min}(a, b)\bigr) \]
g\"ultig ist.  F\"ur die erste Zuweisung erhalten wir das Hoare-Tripel 
\[ \hoare{\texttt{x} = a \wedge \texttt{y} = b \wedge \texttt{x} < \texttt{y}}{z := x;}{
          \texttt{x} = a \wedge \texttt{y} = b \wedge \texttt{x} < \texttt{y} \wedge 
          \texttt{z} = \texttt{x}}.
\]
Analog erhalten wir f\"ur die zweite Zuweisung
\[ \hoare{\texttt{x} = a \wedge \texttt{y} = b \wedge \texttt{x} \geq \texttt{y}}{z := y;}{
          \texttt{x} = a \wedge \texttt{y} = b \wedge \texttt{x} \geq \texttt{y} \wedge
          \texttt{z} = \texttt{y}}.
\]
Nun gilt einerseits
\[ \texttt{x} = a \wedge \texttt{y} = b \wedge \texttt{x} < \texttt{y} \wedge \texttt{z} = \texttt{x} 
   \rightarrow \texttt{z} = \min(a,b)
\]
und andererseits
\[ \texttt{x} = a \wedge \texttt{y} = b \wedge \texttt{x} \geq \texttt{y} \wedge \texttt{z} = \texttt{y} 
   \rightarrow \texttt{z} = \min(a,b).
\]
Durch Anwendung der Abschw\"achungs-Regel sehen wir also, dass
\begin{eqnarray*}
\hoare{\texttt{x} = a \wedge \texttt{y} = b \wedge \texttt{x} < \texttt{y}}{z := x;}{
       \texttt{z} = \min(a,b)} & & \mathrm{und} \\
\hoare{\texttt{x} = a \wedge \texttt{y} = b \wedge \texttt{x} \geq \texttt{y}}{z := y;}{
          \texttt{z} = \min(a,b)}
\end{eqnarray*}
gilt. Durch Anwendung der Verifikations-Regel f\"ur die Alternativ-Anweisung folgt dann, dass
\[ \hoare{\texttt{x} = a \wedge \texttt{y} = b}{if (x < y) \{ z := x; \} else \{ z := y; \}}{
          \texttt{z} = \min(a,b)}
\]
gilt und damit ist nachgewiesen, dass das entsprechende Programm-Fragment
das Minimum der Zahlen $a$ und $b$ berechnet.

\subsection{Schleifen}
Als letztes analysieren wir die Wirkung einer Schleife der Form 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{while ($B$) \{ P \}} 
\\[0.2cm]
Der entscheidende Punkt ist hier, dass die Nachbedingung f\"ur den $n$-ten
Schleifen-Durchlauf gleichzeitig die Vorbedingung f\"ur den $(n\!+\!1)$-ten Schleifen-Durchlauf
sein muss.  Das f\"uhrt zu der Forderung, dass Vor- und Nachbedingung f\"ur den
Schleifen-Rumpf im Wesentlichen identisch sein m\"ussen.  Diese Bedingung tr\"agt daher den
Namen \emph{Schleifen-Invariante}.  Im Detail hat die Verifikations-Regel die folgende Form:
\[ 
  \bruch{\hoare{I \wedge B}{P}{I}}{\quad \hoare{I}{while ($B$) \{ P \}}{I \wedge \neg B}\quad}
\]
Die Pr\"amisse dieser Regel besagt, dass bei der Ausf\"uhrung von $P$ die Invariante $I$
wahr bleiben muss, wobei wir als zus\"atzliche Vorbedingung noch die Formel $B$ annehmen
d\"urfen, denn \texttt{P} wird  nur ausgef\"uhrt, wenn $B$ wahr ist.
Die Konklusion besagt, dass wenn vor der Ausf\"uhrung der Schleife die Invariante $I$ g\"ultig
ist, dann gilt sie hinterher immer noch.  Anschaulich ist das klar, denn jede einzelne
Ausf\"uhrung des Schleifen-Rumpfs \texttt{P} hat die Invariante $I$ ja erhalten.
Zus\"atzlich wissen wir noch, dass nach Beendigung der Schleife die Bedingung $\neg B$ gilt,
denn wenn $B$ gelten w\"urde, w\"urde die Schleife weiterlaufen.


\section{Der Euklid'sche Algorithmus}
Wir zeigen nun, wie die im letzten Abschnitt pr\"asentierten Regeln verwendet werden k\"onnen,
um die Korrektheit eines nicht-trivialen Programms zu zeigen.  Unser Ziel ist es, die
Korrektheit der in Abbildung \ref{fig:ggt.c} auf Seite \pageref{fig:ggt.c} gezeigten
\texttt{C}-Funktion nachzuweisen.  Diese Funktion implementiert den Euklid'schen
Algorithmus zur Berechnung des gr\"o{\ss}ten gemeinsamen Teilers zweier positiver nat\"urlicher
Zahlen.  Bevor wir f\"ur diesen Algorithmus den Nachweis der Korrektheit
erbringen, erinnern wir daran, dass wir in der Mathematik-Vorlesung gezeigt haben dass
\[ \texttt{ggt}(x + y, y) = \texttt{ggt}(x,y) \quad \mbox{f\"ur alle $x, y \in \mathbb{N}$} \]  
gilt.


\subsection{Nachweis der Korrektheit des Euklid'schen Algorithmus}
Wir haben nun alles Material zusammen, um die Korrektheit des Euklid'schen Algorithmus,
der in Abbildung
\ref{fig:ggt.c} gezeigt wird, nachweisen zu k\"onnen.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    ggt := procedure(x, y) {
        while (x != y) {
            if (x < y) {
                y := y - x;
            } else {
                x := x - y;
            }
        }
        return x;
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Der Euklid'sche Algorithmus zur Berechnung des gr\"o{\ss}ten gemeinsamen Teilers.}
\label{fig:ggt.c}
\end{figure}

Wir beginnen den Nachweis der Korrektheit damit, dass wir die Invariante formulieren, die
von der \texttt{while}-Schleife erhalten wird.  Wir definieren
\[ I := \bigl(x > 0 \wedge y > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b) \bigr).
\]
Hierbei haben wir die Startwerte von $x$ und $y$ mit $a$ und $b$ bezeichnet.
Um die Invariante $I$ zu Beginn sicherzustellen, ist zu fordern, dass die Funktion
\texttt{ggt} nur mit positiven ganzen Zahlen aufgerufen wird.  Bezeichnen wir diese Zahlen
mit $a$ und $b$, so gilt die Invariante offenbar zu Beginn, denn aus $x = a$ und $y = b$
folgt sofort $\texttt{ggt}(x,y) = \texttt{ggt}(a,b)$.

Um nachzuweisen, dass die Invariante $I$ in der Schleife erhalten bleibt, stellen wir f\"ur
die beiden Alternativen der \texttt{if}-Abfrage jeweils ein Hoare-Tripel auf.  F\"ur die
erste Alternative wissen wir, dass
\[
  \hoare{I \wedge x \not= y \wedge x < y}{y := y - x;}{(I \wedge x \not= y \wedge x < y)\sigma} 
  \quad \mathrm{mit} \quad \sigma = [y \mapsto y + x]
\]
gilt.  Die Bedingung $x \not= y$ ist dabei die Bedingung der \texttt{while}-Schleife
und die Bedingung $x < y$ ist die Bedingung der \texttt{if}-Abfrage.
Wir formen den Ausdruck $(I \wedge x \not= y \wedge x < y)\sigma$ um:
\begin{eqnarray*}
 &                 & \bigl(I \wedge x \not= y \wedge x < y\bigr)\sigma \\
 & \leftrightarrow & \bigl(I \wedge x < y\bigr)\sigma 
                     \qquad\qquad \mbox{denn aus $x < y$ folgt $x \not= y$} \\
 & \leftrightarrow & \bigl(x > 0 \wedge y > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b) \wedge 
                     x < y\bigr)[y \mapsto y + x] \\
 & \leftrightarrow & x > 0 \wedge y + x > 0 \wedge \texttt{ggt}(x,y+x) = \texttt{ggt}(a,b)
                     \wedge x < y + x \\
 & \leftrightarrow & x > 0 \wedge y + x > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b) \wedge 0 < y
\end{eqnarray*}
Dabei haben wir bei der letzten Umformung die im letzten Abschnitt bewiesene Gleichung
\[ \texttt{ggt}(x,y+x) = \texttt{ggt}(x,y) \]
benutzt und die Ungleichung $x < y + x$ zu $0 < y$ vereinfacht.
Aus der letzten Formel folgt offenbar
\[ x > 0 \wedge y > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b). \]
Das ist aber genau unsere Invariante $I$.  Damit haben wir gezeigt, dass
\begin{equation}
  \label{eq:if1}
  \hoare{I \wedge x \not= y \wedge x < y}{y := y - x;}{I}
\end{equation}
gilt.  Nun betrachten wir die zweite Alternative der \texttt{if}-Abfrage.  Offenbar gilt
\[
  \hoare{I \wedge x \not= y \wedge x \geq y}{x := x - y;}{(I \wedge x \not= y \wedge x \geq y)\sigma} 
  \quad \mathrm{mit} \quad \sigma = [x \mapsto x + y].
\]
Wir formen den Ausdruck $(I \wedge x \not= y \wedge x \geq y)\sigma$ um:
\begin{eqnarray*}
 &   & \bigl(I \wedge x \not= y \wedge x \geq y\bigr)\sigma \\
 & \leftrightarrow & \bigl(I \wedge x > y \bigr)\sigma \\
 & \leftrightarrow & \bigl(x > 0 \wedge y > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b) \wedge 
             x > y \bigr)[x \mapsto x + y] \\
 & \leftrightarrow & x + y > 0 \wedge y > 0 \wedge \texttt{ggt}(x+y,y) = \texttt{ggt}(a,b) 
       \wedge x + y > y  \\
 & \leftrightarrow & x + y > 0 \wedge y > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b) 
       \wedge x > 0 
\end{eqnarray*}
Aus der letzten Formel folgt nun
\[ x > 0 \wedge y > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b). \]
Das ist aber wieder unsere Invariante $I$.  Also haben wir insgesamt
\begin{equation}
  \label{eq:if2}
  \hoare{I \wedge x \not= y \wedge x \geq y}{x := x - y;}{I} 
\end{equation}
gezeigt.  Aus den beiden Hoare-Tripeln (\ref{eq:if1}) und (\ref{eq:if2})
folgt nun mit der Regel f\"ur Alternativen die G\"ultigkeit von
\[
  \hoare{I \wedge x \not= y}{if (x < y) \{ x := x - y; \} else \{ y := y - x;\}}{I}. 
\]
Mit der Verifikations-Regel f\"ur Schleifen folgt daraus
\\[0.2cm]
\hspace*{1.3cm} 
$\{ I \}$
\\[0.1cm]
\hspace*{2.2cm}
\texttt{while (x != y ) \{} \\[0.1cm]
\hspace*{3.2cm}
         \texttt{if (x < y) \{ x := x - y; \} else \{ y := y - x;\}}
\\[0.1cm]
\hspace*{2.2cm}
\texttt{\}} \quad 
\\[0.1cm]
\hspace*{1.3cm}
$\{ I \wedge x = y \}$. 
\\[0.2cm]
Schreiben wir die Formel $I \wedge x = y$ aus, so sehen wir, dass die Nachbedingung der
\texttt{while}-Schleife durch die Formel
\[ 
   x > 0 \wedge y > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b) \wedge x = y
\]
gegeben ist.  Daraus erschlie{\ss}en wir die Korrektheit des Euklid'schen Algorithmus wie folgt:
\begin{eqnarray*}
&             &  x > 0 \wedge y > 0 \wedge \texttt{ggt}(x,y) = \texttt{ggt}(a,b) \wedge x = y \\
& \Rightarrow & \texttt{ggt}(x,y) = \texttt{ggt}(a,b) \wedge x = y \\
& \Rightarrow & \texttt{ggt}(x,x) = \texttt{ggt}(a,b)  \\
& \Rightarrow & x = \texttt{ggt}(a,b) \qquad\qquad \mathrm{denn} \quad \texttt{ggt}(x,x) = x.
\end{eqnarray*}
Damit haben wir folgendes gezeigt:  Wenn die \texttt{while}-Schleife terminiert, dann
enth\"alt die Variable $x$ den gr\"o{\ss}ten gemeinsamen Teiler der Werte $a$ und $b$, mit denen
die Variablen $x$ und $y$ initialisiert wurden.  Um den Beweis der Korrektheit
abzuschlie{\ss}en, m\"ussen wir noch nachweisen, dass die \texttt{while}-Schleife tats\"achlich in
jedem Fall terminiert.  Zu diesem Zweck definieren wir die Variable $s$ als
\[ s := x + y. \]
Die Variablen $x$ und $y$ sind nat\"urliche Zahlen.  Damit ist dann auch $s$ eine nat\"urliche Zahl.
Bei jedem Schleifendurchlauf wird die Zahl $s$ verkleinert, denn entweder wird $x$ von $s$
abgezogen oder es wird $y$ von $s$ abgezogen und die Invariante $I$ zeigt uns, dass sowohl $x$ als auch $y$
positiv sind.  W\"urde die Schleife unendlich lange laufen, so m\"usste $s$ irgendwann negative
Werte annehmen.  Da wir dies ausschlie{\ss}en k\"onnen, muss die
Schleife abbrechen.  Damit ist die Korrektheit des Euklid'schen Algorithmus gezeigt.
\pagebreak


\noindent
\textbf{Aufgabe}:  Zeigen Sie, dass der Aufruf $\texttt{power}(x,y)$ der in Abbildung
\ref{fig:power.c} gezeigten Funktion $\texttt{power}(x,y)$ f\"ur gegebene nat\"urliche Zahlen $x$
und $y$ die Potenz $x^y$ berechnet.
\vspace*{0.3cm}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 1.3cm,
                  xrightmargin  = 1.3cm,
                ]
    power := procedure(x, y) {
        r := 1;
        while (y > 0) {
            if (y % 2 == 1) {
                r := r * x;
            }
            x := x * x;
            y := y / 2;
        }
        return r;
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{C}-Programm zur Berechnung der Potenz.}
\label{fig:power.c}
\end{figure}

\noindent
\textbf{Hinweise}: 
\begin{enumerate}
\item Bezeichnen wir die Start-Werte von $x$ und $y$ mit $a$ und $b$,
      so ist eine m\"ogliche Invariante f\"ur die \texttt{while}-Schleife durch die Formel 
      \\[0.2cm]
      \hspace*{1.3cm}
      $I := \bigl(r \cdot x^y = a^b\bigr)$
      \\[0.2cm]
      gegeben.  
\item Die Verifikations-Regel f\"ur die \emph{einarmige Alternative} lautet
      \\[0.2cm]
      \hspace*{1.3cm}
      $\bruch{\quad\hoare{F \wedge B}{P}{G}, \qquad F \wedge \neg B \rightarrow G\quad}{
                     \hoare{F}{if ($B$) \{ P \}}{G}}
      $
      \\[0.2cm]
      Diese Verifikations-Regel kann wie folgt interpretiert werden:
      \begin{enumerate}
      \item Falls $F$ und die Bedingung $B$ gilt, dann muss die Ausf\"uhrung von 
            dem Programm-Fragment $P$ bewirken, dass nachher $G$ gilt.
      \item Falls $F$ und die Bedingung $\neg B$ gilt, dann muss daraus
            die Bedingung $G$ folgen.
      \item Unter diesen Bedingungen folgt dann aus der Vorbedingung $F$
            nach Ausf\"uhrung von dem Programm-Fragment ``\texttt{if ($B$) \{ P \}}''
            die Nachbedingung $G$.
      \end{enumerate}
\end{enumerate}
\pagebreak


\noindent
\textbf{L\"osung}:
Wir untersuchen Zeile f\"ur Zeile die Wirkung des Programms.
\begin{enumerate}
\item Wir bezeichnen den Anfangswert von $x$ mit $a$ und den Anfangswert von $y$ mit $b$. 
      Damit lautet die Vorbedingung der Anweisung ``\texttt{r = 1;}'' 
      \\[0.1cm]
      \hspace*{1.3cm}
      $x = a \wedge y = b$
      \\[0.1cm]
      Damit finden wir f\"ur die erste Anweisung das Hoare-Tripel
      \\[0.2cm]
      \hspace*{1.3cm}
      $\hoare{x = a \wedge y = b}{r := 1;}{x = a \wedge y = b \wedge r = 1}$. 
\item Als n\"achstes m\"ussen wir zeigen, dass aus der Nachbedingung der ersten Anweisung
      die oben angegebene Invariante $I$ folgt.  Offenbar gilt
      \\[0.2cm]
      \hspace*{1.3cm}
      $x = a \wedge y = b \wedge r = 1 \rightarrow r \cdot x^y = a^b$.
\item Wir untersuchen nun die \texttt{if}-Abfrage.  Als Vorbedingung der
      \texttt{if}-Abfrage nehmen wir die Invariante $I$ zusammen mit der Bedingung 
      $y > 0$.  F\"ur die Zuweisung ``\texttt{r = r * x;}'' erhalten wir dann die 
      Bedingung $I \wedge y > 0 \wedge y \mod 2 = 1$.  Das liefert das Hoare-Tripel
      \\[0.2cm]
      \hspace*{1.3cm}
      $\{r \cdot x^y = a^b \wedge y > 0 \wedge y \mod 2 = 1\}$
      \\[0.2cm]
      \hspace*{2.3cm} \texttt{r := r * x;}
      \\[0.2cm]
      \hspace*{1.3cm}
      $\{\bigl(r \cdot x^y = a^b \wedge y > 0 \wedge y \mod 2 = 1\bigr)[r \mapsto r/x]\}$
      \\[0.2cm]
      Die Nachbedingung vereinfacht sich zu 
      \\[0.2cm]
      \hspace*{1.3cm}
      $r/x \cdot x^y = a^b \wedge y > 0 \wedge y \mod 2 = 1$ 
      \\[0.2cm]
      und das ist dasselbe wie
      \\[0.2cm]
      \hspace*{1.3cm}
      $r \cdot x^{y-1} = a^b \wedge y > 0 \wedge y \mod 2 = 1$.
      \\[0.2cm]
      Um dies weiter vereinfachen zu k\"onnen, schreiben wir
      \\[0.2cm]
      \hspace*{1.3cm}
      $y = 2 \cdot (y/2) + y \mod 2$.
      \\[0.2cm]
      Setzen wir diesen Wert von $y$ in der letzten Gleichung ein, so erhalten wir
      \\[0.2cm]
      \hspace*{1.3cm}
      $r \cdot x^{2 \cdot (y/2)} = a^b \wedge y > 0 \wedge y \mod 2 = 1$,
      \\[0.2cm]
      denn aus $y \mod 2 = 1$ folgt $y -1 = 2 \cdot (y/2)$.  Damit haben wir die
      G\"ultigkeit von
      \\[0.2cm]
      \hspace*{1.3cm}
      $\hoare{r \cdot x^y = a^b \wedge y > 0 \wedge y \mod 2 = 1}{r := r * x;}{
              r \cdot x^{2 \cdot (y/2)} = a^b}$
      \\[0.2cm]
      bewiesen.  Wir versuchen nun, unter der Bedingung $y \mod 2 = 0$ 
      die Invariante $I$ so umzuformen, dass sie mit der Nachbedingung dieses
      Hoare-Tripels  \"ubereinstimmt.  Es gilt 
      \\[0.2cm]
      \hspace*{1.3cm}
      $r \cdot x^y = a^b \wedge y > 0 \wedge y \mod 2 = 0 \rightarrow 
       r \cdot x^{2 \cdot (y/2)} = a^b$,
      \\[0.2cm]
      denn aus $y \mod 2 = 0$ folgt $y = 2 \cdot (y/2)$.  Damit haben wir
      insgesamt f\"ur die \texttt{if}-Abfrage das folgende Hoare-Tripel gefunden:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\{r \cdot x^y = a^b \wedge y > 0 \}$
      \\[0.2cm]
      \hspace*{2.3cm} \texttt{if (y \% 2) == 1 \{ r := r * x;\}}
      \\[0.2cm]
      \hspace*{1.3cm}
      $\{ r \cdot x^{2 \cdot (y/2)} = a^b\}$
\item Als n\"achstes untersuchen wir die Zuweisung ``\texttt{x := x * x;}''.
      Als Vorbedingung nehmen wir nat\"urlich die Nachbedingung der \texttt{if}-Abfrage.
      Wir erhalten das Hoare-Tripel
      \\[0.2cm]
      \hspace*{1.3cm}
      $\hoare{r \cdot x^{2 \cdot (y/2)} = a^b}{x := x * x;}{
              \bigl(r \cdot x^{2 \cdot (y/2)} = a^b\bigr)\bigl[x \mapsto x^{\frac{1}{2}}\bigr]}$
      \\[0.2cm]
      F\"uhren wir die Substitution aus, so vereinfacht sich die Nachbedingung zu 
      \\[0.2cm]
      \hspace*{1.3cm}
      $r \cdot (x^{\frac{1}{2}})^{2 \cdot (y/2)} = a^b$
      \\[0.2cm]
      und dies kann weiter vereinfacht werden zu 
      \\[0.2cm]
      \hspace*{1.3cm}
      $r \cdot x^{y/2} = a^b$
      \\[0.2cm]
      Damit haben wir also insgesamt das Hoare-Tripel
      \\[0.2cm]
      \hspace*{1.3cm}
      $\hoare{r \cdot x^{2 \cdot (y/2)} = a^b}{x := x * x;}{
              r \cdot x^{y/2} = a^b}$
      \\[0.2cm]
      gefunden.
\item Die letzte Zuweisung ``\texttt{y := y / 2;}'' liefert nun das Hoare-Tripel
      \\[0.2cm]
      \hspace*{1.3cm}
      $\hoare{r \cdot x^{y/2} = a^b}{y := y / 2;}{r \cdot x^{y} = a^b}$.
      \\[0.2cm]
      Hier haben wir die allgemeine Zuweisungs-Regel
      \\[0.2cm]
      \hspace*{1.3cm}
      $\hoare{F[y \mapsto t]}{y := t;}{F}$
      \\[0.2cm]
      benutzt, wobei wir f\"ur $F$ die Formel $r \cdot x^{y} = a^b$ und f\"ur $t$ den Term 
      $y / 2$ verwendet haben.

      \textbf{Bemerkung}:  Es ist hier nicht m\"oglich, die Zuweisungs-Regel
      \\[0.2cm]
      \hspace*{1.3cm}
      $\hoare{F}{x := h(x);}{F\sigma} \quad \mathrm{mit} \quad \sigma = \bigl[x \mapsto h^{-1}(x)\bigr]$
      \\[0.2cm]
      zu verwenden, denn die Funktion $y \mapsto y/2$ ist nicht umkehrbar, da
      sowohl $2/2 = 1$ als auch $3/2 = 1$ gilt.
\item Da  die Nachbedingung des letzten Hoare-Tripels  genau die Schleifen-Invariante $I$
      ist, haben wir insgesamt die Korrektheit des  folgenden Hoare-Tripels gezeigt: 
      \\[0.2cm]
      \hspace*{1.3cm} $\{ r \cdot x^y = a^b \}$                  \\[0.2cm]
      \hspace*{2.3cm} \texttt{while (y > 0) \{}                  \\
      \hspace*{2.8cm} \texttt{if (y \% 2 == 1) \{ r = r * x; \}}  \\
      \hspace*{2.8cm} \texttt{x = x * x;}                        \\
      \hspace*{2.8cm} \texttt{y = y / 2;}                        \\
      \hspace*{2.3cm} \texttt{\}}                                \\
      \hspace*{1.3cm} $\{ r \cdot x^y = a^b \wedge \neg y > 0\}$ \\[0.2cm]
      Da $y$ eine nat\"urlich Zahl sein muss, denn $y$ wird ja nur durch die
      Ganzzahl-Division 
      \\[0.2cm]
      \hspace*{1.3cm}
      $y = y / 2$
      \\[0.2cm]
      ver\"andert, folgt aus $\neg y > 0$, dass $y = 0$ gilt.  Damit lautet die Nachbedingung der
      \texttt{while}-Schleife also 
      \\[0.2cm]
      \hspace*{1.3cm} $r \cdot x^y = a^b \wedge y = 0$,
      \\[0.2cm]
      was sich wegen $x^0 = 1$ zu 
      \\[0.2cm]
      \hspace*{1.3cm}
      $r = a^b$,
      \\[0.2cm]
      vereinfacht.  Insgesamt haben wir also gezeigt, dass die Variable $r$ am Ende der
      \texttt{while}-Schleife den Wert $a^b$ hat.  
\end{enumerate}
Es bleibt noch zu zeigen, dass die \texttt{while}-Schleife immer terminiert.
Einerseits wird die Variable \texttt{y}  in jedem Schritt ganzzahlig durch zwei geteilt, andererseits
l\"auft die Schleife nur solange, wie die Variable \texttt{y} positiv ist.  Daher muss die
Schleife abbrechen.
\hspace*{\fill} $\Box$

\subsection{Maschinelle Programm-Verifikation}
Die manuelle Verifikation nicht-trivialer Programm mit Hilfe des Hoare-Kalk\"uls ist sehr
aufwendig.  Von Hand k\"onnen nur Programme verifiziert werden, die in derselben
Gr\"o{\ss}enordnung liegen, wie der oben behandelte Euklid'sche Algorithmus.  Es ist aber
m\"oglich, den Prozess der Programm-Verifikation zumindest partiell zu automatisieren.
Sogenannte VCGs (\emph{\underline{v}erification \underline{c}ondition
  \underline{g}enerators}) reduzieren die Verifikation eines Programms auf den Nachweis
bestimmter logischer Formeln, die als \emph{Verifikations-Bedingungen} bezeichnet werden.
Die Verifikations-Bedingungen k\"onnen dann mit der Unterst\"utzung automatischer Beweise
nachgewiesen werden.  Auch dieses Vorgehen ist nur f\"ur Programme mittlerer Komplexit\"at
praktikabel.  Im Internet finden Sie unter der Adresse
\\[0.2cm]
\hspace*{1.3cm}
\texttt{http://www.mathematik.uni-marburg.de/\symbol{126}gumm/NPPV/JavaProgramVerifierII.zip}
\\[0.2cm]
das System \textsc{Jpv} (\underline{J}ava \underline{p}rogram \underline{v}erifier), 
mit dessen Hilfe Programme verifiziert werden k\"onnen.  Das dort zur Verf\"ugung
gestellten Systeme ist nicht darauf ausgelegt, umfangreiche Programme zu verifizieren, es
reicht aber aus, um einen Eindruck in die Technik zu vermitteln.  Wir demonstrieren das
System am Beispiel der Verifikation des Programms zur Berechnung der Potenz.  Die
Benutzer-Eingabe hat in diesem Fall die in Abbildung \ref{fig:Power.ver} gezeigte Form.
\begin{enumerate}
\item Zeile 1 enth\"alt, eingefasst in den Zeichen ``\texttt{\#\#}'', die Vorbedingung
      des Programms. Hier wird ausgesagt, dass die Variablen $x$ und $y$ zu Beginn
      zwei Zahlen $a$ und $b$.  Beim Beweis werden wir hinterher davon ausgehen, dass
      es sich bei $a$ und $b$ um nat\"urliche Zahlen handelt.
\item Hinter der \texttt{while}-Schleife formulieren wir in Zeile 3 die Invariante der Schleife:
      \\[0.2cm]
      \hspace*{1.3cm}
      $r \cdot x^y = a^b$.
      \\[0.2cm]
      Da der Potenz-Operator in \textsc{Jpv} nicht zur Verf\"ugung steht, haben wir f\"ur
      $x^y$ den Ausdruck $\texttt{pow}(x,y)$ verwendet.
\item Die letzte Zeile enth\"alt die Nachbedingung des Programm-Fragments.  Hier wird
      ausgedr\"uckt, dass am Ende der Rechnung $r = a^b$ gilt.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    ## x == a & y == b & b > 0 ##
      r = 1;
      while(y > 0) ## r * pow(x,y) == pow(a,b) ##
      {
         if (y % 2 == 1) {
            r = r * x;  
         }
         x = x * x;
         y = y / 2;
      }
    ## r == pow(a,b) ##
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Verifikation der Berechnung der Potenz mit \textsc{Jpv}.}
\label{fig:Power.ver}
\end{figure}

Wir k\"onnen nun \textsc{Jpv} benutzen, um nachzuweisen, dass das oben gezeigte
Programm-Fragment die annotierte Spezifikation erf\"ullt.  Starten wir das System mit Hilfe
des Befehls
\\[0.2cm]
\hspace*{1.3cm}
\texttt{java -jar JPV.jar}
\\[0.2cm]
so werden die folgenden Verifi\-kations-Bedingungen erzeugt:
\begin{enumerate}
\item $x = a \wedge y = b \rightarrow 1 \cdot x^y = a^b$.
\item $r \cdot x^y = a^b \rightarrow r \cdot x^y = a^b$.
\item $y > 0 \wedge r \cdot x^y = a^b \wedge y \,\texttt{\%}\, 2 = 1 \rightarrow
        r \cdot x \cdot (x \cdot x)^{y / 2} = a^b$.
\item $y > 0 \wedge r \cdot x^y = a^b \wedge y \,\texttt{\%}\, 2 \not= 1    \rightarrow
        r \cdot (x \cdot x)^{y / 2} = a^b$.
\item $r \cdot (x \cdot x)^{y / 2} = a^b \rightarrow r \cdot (x \cdot x)^{y / 2} = a^b$.
\item $r \cdot x^{y / 2} = a^b    \rightarrow r \cdot x^{y / 2} = a^b$.
\item $r \cdot x^y = a^b \wedge y \leq 0    \rightarrow r = a^b$.
\end{enumerate}
Der in \textsc{Jpv} integrierte automatische Beweiser ist in der Lage, die 1., die 2., die
5. und die 6. dieser Verifikations-Bedingungen unmittelbar nachzuweisen.  Der Nachweis der
Korrektheit der restlichen Bedingungen ist dann vom Benutzer mit Papier und Bleistift zu erbringen.
Da wir die entsprechenden Beweise im Wesentlichen schon beim Nachweis der Korrektheit des in
Abbildung \ref{fig:power.c} gezeigten Programms gef\"uhrt haben, wiederholen wir sie hier
nicht noch einmal.


\section{Symbolische Programm-Ausf\"uhrung}
Wir haben im letzten Abschnitt gesehen, dass der Hoare-Kalk\"ul sehr schwerf\"allig ist.  Es
gibt noch eine weitere Methode, um die Korrektheit eines sequentiellen Programms
nachzuweisen.  Dies ist die Methode der \emph{symbolischen Programm-Ausf\"uhrung}.  Wir
demonstrieren diese Methode anhand des in Abbildung \ref{fig:power.c} gezeigten
Programms zur iterativen Berechnung der Potenz.


\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 1.3cm,
                  xrightmargin  = 1.3cm,
                  codes         = {\catcode`_=8\catcode`$=3},
                  commandchars  = \\\{\},
                ]
    power := procedure(x$_0$, y$_0$) \{
        r$_0$ := 1;
        while (y$_n$ > 0) \{
            if (y$_n$ % 2 == 1) \{
                r$_{n+1}$ := r$_n$ * x$_n$;
            \} 
            x$_{n+1}$ := x$_n$ * x$_n$;
            y$_{n+1}$ := y$_n$ / 2;            
        \} 
        return r$_N$;
    \};
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Das indizierte \texttt{C}-Programm zur Berechnung der Potenz.}
\label{fig:PowerIterative.iter}
\end{figure} % $


Der wesentliche Unterschied zwischen einer mathematischen Formel und einen Programm ist
der, dass alle Auftreten einer Variablen in einer mathematischen Formel den selben Wert
bezeichnen.  In einem Programm ist dies anders, denn die Werte einer Variablen \"andern sich
dynamisch.  Um diesem  Verhalten Rechnung zu tragen, m\"ussen wir die verschiedenen
Auftreten einer Formel unterscheiden k\"onnen.  Dies geht am einfachsten, wenn wir die
Variablen so indizieren, dass der Index der Variablen sich jedes Mal \"andert, wenn die
Variable einen neuen Wert zugewiesen bekommt. 
Dabei m\"ussen wir allerdings ber\"ucksichtigen, dass ein und dasselbe textuelle
Auftreten einer Variablen immer noch verschiedene Werte annehmen kann und zwar dann, wenn 
das Auftreten in einer Schleife liegt.  In diesem Fall m\"ussen wir die Variable so
indizieren, dass noch ein Z\"ahler f\"ur die Anzahl der Schleifen-Durchl\"aufe in dem Index
eingebaut ist.  Um die Diskussion nicht zu abstrakt werden zu lassen, betrachten wir das
Beispiel in Abbildung \ref{fig:PowerIterative.iter}.  Hier hat die Variable \texttt{r} auf
der rechten Seite der Zuweisung in Zeile 6 den Wert $\texttt{r}_n$, auf der linken Seite
hat sie dann anschlie{\ss}end den Wert $\texttt{r}_{n+1}$ und am Ende der Schleife in Zeile 11 hat die
Variable \texttt{r} den Wert $\texttt{r}_N$, wobei $N$ die Anzahl der Schleifen-Durchl\"aufe
angibt.

Wir beweisen nun die Korrektheit des abgebildeten Programms.  Wir definieren
\[ a := x_0, \quad b := y_0 \]
und zeigen, dass f\"ur die \texttt{while}-Schleife die Invariante
\begin{equation}
  \label{eq:powerInv}
   r_n \cdot x_n^{y_n} = a^b   
\end{equation}
gilt.  Diese Behauptung beweisen wir durch eine Induktion nach der Anzahl der
Schleifen-Durchl\"aufe.
\begin{enumerate}
\item[I.A.] $n=0$:  Wegen $r_0 = 1$ und $x_0 = a$ sowie $y_0 = b$ gilt f\"ur $n= 0$ 
            \\[0.2cm]
            \hspace*{1.3cm}
            $r_n \cdot x_n^{y_n} = r_0 \cdot x_0^{y_0} = 1 \cdot a^{b} = a^b$.
\item[I.S.] $n \mapsto n + 1$:  Wir f\"uhren eine Fallunterscheidung nach dem Wert von $y \mod 2$ durch:
            \begin{enumerate}
            \item $y_n \mod 2 = 1$.  Dann gilt $y_{n} = 2 \cdot (y_n/2) + 1$.
                  Damit finden wir
                  \begin{eqnarray*}
                      &   & r_{n+1} \cdot x_{n+1}^{y_{n+1}} \\[0.2cm] 
                      & = & (r_{n} \cdot x_n) \cdot (x_{n} \cdot x_{n})^{y_{n}/2} \\[0.2cm] 
                      & = & r_{n} \cdot x_n \cdot x_{n}^{y_{n}/2} \cdot x_{n}^{y_{n}/2} \\[0.2cm] 
                      & = & r_{n} \cdot x_n^{1 + y_{n}/2 + y_{n}/2} \\[0.2cm] 
                      & = & r_{n} \cdot x_n^{2 \cdot (y_{n}/2) + 1} \\[0.2cm] 
                      & = & r_{n} \cdot x_n^{y_n} \\
                      & \stackrel{IV}{=} & a^{b} 
                  \end{eqnarray*}
            \item $y_n \mod 2 = 0$.  Dann gilt $y_{n} = 2 \cdot (y_n/2)$.
                  Damit finden wir
                  \begin{eqnarray*}
                      &   & r_{n+1} \cdot x_{n+1}^{y_{n+1}} \\[0.2cm] 
                      & = & r_{n} \cdot (x_{n} \cdot x_{n})^{y_{n}/2} \\[0.2cm] 
                      & = & r_{n} \cdot x_{n}^{y_{n}/2} \cdot x_{n}^{y_{n}/2} \\[0.2cm] 
                      & = & r_{n} \cdot x_n^{y_{n}/2 + y_{n}/2} \\[0.2cm] 
                      & = & r_{n} \cdot x_n^{2 \cdot (y_{n} / 2)} \\[0.2cm] 
                      & = & r_{n} \cdot x_n^{y_n} \\
                      & \stackrel{IV}{=} & a^{b} 
                  \end{eqnarray*}
            \end{enumerate}
\end{enumerate}
Damit ist die Gleichung (\ref{eq:powerInv}) bewiesen.   Wenn die \texttt{while}-Schleife
abbricht, dann muss $y_N = 0$ gelten.  Gleichung (\ref{eq:powerInv}) liefert f\"ur $n=N$:
\[ r_N \cdot x_N^{y_N} = x_0^{y_0} 
  \leftrightarrow  r_N \cdot x_N^{0}   = a^b
  \leftrightarrow  r_N \cdot 1         = a^b
  \leftrightarrow  r_N                 = a^b
\]
Damit haben wir insgesamt $r_N = a^b$ bewiesen und da wir schon wissen, dass
die \texttt{while}-Schleife terminiert, ist damit gezeigt, dass der
Funktions-Aufruf $\texttt{power}(a,b)$ tats\"achlich den Wert $a^b$ berechnet.
\vspace*{0.3cm}
\pagebreak

\noindent
\textbf{Aufgabe}:  Weisen Sie mit der Methode der symbolischen Programm-Ausf\"uhrung die
Korrektheit der in Abbildung \ref{fig:gcd.c} gezeigten effizienteren Version des
Euklid'schen Algorithmus nach. 
Sie d\"urfen dabei benutzen, dass f\"ur positive nat\"urliche Zahlen $a$ und $b$ die Beziehung 
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{ggt}(a, b) = \mathtt{ggt}(a \,\texttt{\%}\, b, b)$
\\[0.2cm]
erf\"ullt ist.  

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    ggt := procedure(a, b) {
        while (b != 0) {
            r := a % b;
            a := b;
            b := r;
        }
        return a;
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Der Euklid'sche Algorithmus zur Berechnung des gr\"o{\ss}ten gemeinsamen Teilers.}
\label{fig:gcd.c}
\end{figure}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "logik"
%%% End: 
