\chapter{Abstrakte Daten-Typen und elementare Daten-Stukturen}
\"Ahnlich wie der Begriff des Algorithmus von bestimmten Details eines Programms
abstrahiert, abstrahiert der Begriff des \emph{abstrakten Daten-Typs} von bestimmten
Details konkreter Daten-Stukturen.  Durch die Verwendung dieses Begriffs wird es
m\"oglich, Algorithmen von den zugrunde liegenden Daten-Stukturen zu trennen.
Wir geben im n\"achsten Abschnitt eine Definition von abstrakten Daten-Typen und
illustrieren das Konzept im folgenden Abschnitt anhand von dem abstrakten Daten-Typ \textsl{Stack}.
Im zweiten Abschnitt zeigen wir, wie die Sprache \textsl{Java} die
Verwendung abstrakter Daten-Typen unterst\"utzt.  In den folgenden Abschnitten betrachten
wir verschiedene Implementierungen des abstrakten Daten-Typs \textsl{Stack}.
Anschlie{\ss}end zeigen wir, wie sich arithmetische Ausdr\"ucke mit Hilfe eines Stacks
auswerten lassen.
Im vorletzten Abschnitt diskutieren wir den Nutzen, den die Verwendung abstrakter
Daten-Typen hat. 

\section{Abstrakte Daten-Typen}
Formal definieren wir einen \emph{abstrakter Daten-Typ} als ein Tupel der Form
 $\langle T, P, Fz, Ts, Ax \rangle$.
Die einzelnen Komponenten dieses Tupels haben dabei die folgende Bedeutung.
\begin{enumerate}
\item $T$ ist der \emph{Name} des abstrakten Daten-Typs.
\item $P$ ist die Menge der verwendeten \emph{Typ-Parameter}.  Ein Typ-Parameter ist dabei
      einfach ein String.  Diesen String interpretieren wir als Typ-Variable,
      d.h.~wir k\"onnen sp\"ater f\"ur diesen String den Namen eines Daten-Typen einsetzen.
\item $\textsl{Fz}$ ist eine Menge von \emph{Funktions-Zeichen}.  Diese Funktions-Zeichen
      sind die Namen der Operationen, die der abstrakte Daten-Typ zur Vefr\"ugung stellt,
\item $\textsl{Ts}$ ist eine Menge von \emph{Typ-Spezifikation}, die zu jedem Funktions-Zeichen
      $f \in \textsl{Fz}$
      eine \emph{Typ-Spezifikation} der Form \\[0.1cm]
      \hspace*{1.3cm} 
      $f: T_1 \times \cdots \times T_n \rightarrow S$. \\[0.1cm]
      enth\"alt. Dabei sind $T_1$, $\cdots$, $T_n$ und $S$ Namen von 
      Daten-Typen.  Hier gibt es drei M\"oglichkeiten: 
      \begin{enumerate}
      \item Die Namen konkreter Daten-Typen, wie z.~B.~``\texttt{int}'' 
            oder ``\texttt{String}''.
      \item Die Namen abstrakter Daten-Typen.
      \item Ein Typ-Parameter aus der Menge $P$.
      \end{enumerate}
      Die Typ-Spezifikation $f: T_1 \times \cdots \times T_n \rightarrow S$ dr\"uckt aus, dass die
      Funktion $f$ in der Form \\[0.1cm] 
      \hspace*{1.3cm} $f(t_1,\cdots,t_n)$ \\[0.1cm]
      aufgerufen wird und dass f\"ur $i=1,\cdots,n$ das Argument $t_i$ vom Typ
      $T_i$ sein muss.  Au{\ss}erdem sagt die Typ-Spezifikation aus, dass das
      Ergebnis, das von der Funktion $f$ berechnet wird, immer vom Typ $S$ ist.

      Zus\"atzlich fordern wir, dass entweder $T_1 = T$ ist, oder aber $S = T$
      gilt.  Es soll also entweder das erste Argument der Funktion $f$ den Wert
      $T$ haben, oder der Typ des von $f$ berechneten Ergebnisses soll gleich
      $T$ sein. Falls $T_1 \not= T$ ist (und damit zwangsl\"aufig $S = T$ gilt),
      dann nennen wir die Funktion $f$ auch einen \emph{Konstruktor} des
      Daten-Typs $T$, andernfalls bezeichnen wir $f$ als \emph{Methode}.
\item $Ax$ ist eine Menge von pr\"adikaten-logischen Formeln, die das Verhalten 
      des abstrakten Daten-Typs beschreiben.  Diese Formeln bezeichnen wir auch
      als die \emph{Axiome} des Daten-Typs.
\end{enumerate}
Wir geben sofort ein einfaches Beispiel f\"ur einen abstrakten Daten-Typ: den
\emph{Keller} (engl. \emph{stack}).  Einen Keller kann man sich anschaulich als
einen Stapel von  Elementen eines bestimmten Typs vorstellen, die aufeinander
gelegt werden, \"ahnlich wie die Teller in der Essensausgabe einer Kantine.  Dort
werden Teller immer oben auf den Stapel gelegt und in umgekehrter Reihenfolge
wieder vom Stapel entfernt.  Insbesondere ist es nicht m\"oglich, einen Teller aus
der Mitte des Stapels zu entfernen.
Formal definieren wir den Daten-Typ des \emph{Kellers}
wie folgt:
\begin{enumerate}
\item Als Namen w\"ahlen wir \textsl{Stack}.
\item Die Menge der Typ-Parameter ist $\{ \textsl{Element} \}$.
\item Die Menge der Funktions-Zeichen ist \\[0.1cm]
      \hspace*{1.3cm} 
      $\bigl\{ \textsl{Stack}, \textsl{push}, \textsl{pop}, \textsl{top}, \textsl{isEmpty} \bigr\}$.
\item Die Typ-Spezifikationen der Funktions-Zeichen sind wie folgt:
      \begin{enumerate}
      \item $\textsl{Stack}: \textsl{Stack}$

            Links von dem Doppelpunkt steht hier die Funktion mit dem Namen
            \textsl{Stack}, rechts steht der Name des ADT.  In den g\"angigen
            Programmier-Sprachen (\textsl{Java}, \texttt{C++}, etc.) 
            werden bestimmte Funktionen mit demselben Namen bezeichnet wie der zugeh\"orige
            ADT.  Solche Funktionenen hei{\ss}en Konstruktoren.  Der R\"uckgabe-Wert eines
            Konstruktors hat immer den Typ des ADT.

            Der Konstruktor $\textsl{Stack}$ kommt ohne Eingabe-Argumente aus.  Ein
            solcher Konstruktor wird auch als der \emph{Default-Konstruktor} bezeichnet.
            
            Der Aufruf $\textsl{Stack}()$ erzeugt einen neuen, leeren Stack.
      \item $\textsl{push}: \textsl{Stack} \times \textsl{Element} \rightarrow \textsl{Stack}$

            Der Aufruf $\textsl{push}(S,x)$ legt das Element $x$ oben auf den Stack $S$.
            Wir werden im Folgenden eine Objekt-orientierte Schreibweise verwenden und
            den Aufruf  $\textsl{push}(S,x)$ als $S.\textsl{push}(x)$ schreiben.
      \item $\textsl{pop}: \textsl{Stack}  \rightarrow \textsl{Stack}$

            Der Aufruf $S.\textsl{pop}()$ entfernt das oberste Element von dem Stack $S$.
      \item $\textsl{top}: \textsl{Stack} \rightarrow \textsl{Element}$

            Der Aufruf $S.\textsl{top}()$ liefert das auf dem Stack $S$ zuoberst liegende Element. 
      \item $\textsl{isEmpty}: \textsl{Stack} \rightarrow \mathbb{B}$

            Der Aufruf $S.\textsl{isEmpty}()$ testet, ob der Stack $S$ leer ist.
      \end{enumerate}
\end{enumerate}
Die Anschauung, die dem  Begriff des Stacks zu Grunde liegt, wird durch die folgenden Axiome
erfasst:
\begin{enumerate}
\item $\textsl{Stack}().\textsl{top}() = \Omega$

      Hier bezeichnet $\Omega$ den undefinierten Wert.  Der Aufruf $\textsl{Stack}()$
      liefert zun\"achst einen leeren Stack.  Das Axiom dr\"uckt also aus,
      das ein leerer Stack kein oberstes Element hat.
\item $S.\textsl{push}(x).\textsl{top}() = x$

      Legen wir auf den Stack $S$ mit $S.\textsl{push}(x)$ ein Element $x$, so 
      ist $x$ das oberste Element, was auf dem neu erhaltenen Stack liegt.
\item $\textsl{Stack}().\textsl{pop}() = \Omega$

      Der Versuch, von einem leeren Stack das oberste Element zu entfernen,
      liefert ein undefiniertes Ergebnis.
\item $S.\textsl{push}(x).\textsl{pop}() = S$

      Wenn wir auf den Stack $S$
      ein Element legen, und anschlie{\ss}end von dem resultierenden Stack das
      oberste Element wieder herunter nehmen, dann erhalten wir den
      urspr\"unglichen Stack $S$, mit dem wir gestartet sind.
\item $\textsl{Stack}().\textsl{isEmpty}() = \mathtt{true}$

      Erzeugen wir mit $\textsl{Stack}()$ einen neuen Stack, so ist dieser
      zun\"achst leer.
\item $S.\textsl{push}(x).\textsl{isEmpty}() = \mathtt{false}$

      Legen wir ein Element $x$ auf einen Stack $S$, so kann der Stack $S$
      danach nicht leer sein.
\end{enumerate}
Beim Betrachten der Axiome l\"asst sich eine gewisse Systematik erkennen.
Bezeichnen wir die Funktionen \texttt{Stack} und \texttt{push} als Generatoren
so geben die Axiome das Verhalten der restlichen Funktionen auf den von den Generatoren
erzeugten Stacks an. 

Stacks spielen in vielen Bereichen der Informatik eine wichtige Rolle.  Es gibt
sogar Stack-basierte Programmier-Sprachen: Dort m\"ussen bei einem
Funktions-Aufruf alle Argumente zun\"achst auf einen Stack gelegt werden.  Die
aufrufende Funktion nimmt dann ihre Argumente vom Stack und legt das berechnete
Ergebnis wieder auf den Stack.  Die Sprache \textsl{PostScript} funktioniert
nach diesem Prinzip.  Die Sprache \textsl{Java} wird in einen \emph{Byte-Code}
\"ubersetzt, der von der \emph{Java Virtual Machine} (kurz JVM) interpretiert
wird.  Die JVM ist ebenfalls stack-basiert.

Wir werden sp\"ater noch sehen, wie  arithmetische Ausdr\"ucke mit Hilfe
eines Stacks ausgewertet werden k\"onnen. Vorher zeigen wir, wie sich der
abstrakte Daten-Typ des Stacks in der Programmier-Sprache \textsl{Java}
implementieren l\"asst.

\section{Darstellung abstrakter Daten-Typen in \textsl{Java}}
In \textsl{Java} k\"onnen abstrakte Daten-Typen entweder durch ein \emph{Interface} oder
durch eine \emph{abstrakte Klasse} repr\"asentiert werden.   F\"ur den Stack w\"ahlen wir die Darstellung
durch eine abstrakte Klasse, die in Abbildung \ref{fig:stack.java} auf Seite
\pageref{fig:stack.java} gezeigt wird.   Die Darstellung durch eine abstrakte Klasse ist
insofern flexibler, als wir hier die M\"oglichkeit haben, Methoden, die sich
bereits auf der Abstraktions-Ebene des ADT realisieren lassen, zu implementieren.

\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm
                ]
    public abstract class Stack<Element> implements Cloneable
    {
        public abstract void    push(Element e);
        public abstract void    pop();
        public abstract Element top();
        public abstract boolean isEmpty();
    
        public Stack<Element> clone() throws CloneNotSupportedException {    
            return (Stack<Element>) super.clone();
        }

        public final String toString() {
            Stack<Element> copy;
            try {
                copy = clone();
            } catch (CloneNotSupportedException e) {
                return "*** ERROR ***";
            }       
            String result = copy.convert();
            String dashes = "\n";
            for (int i = 0; i < result.length(); ++i) {
                dashes = dashes + "-";
            }
            return dashes + "\n" + result + dashes + "\n";
        }
    
        private String convert() {
            if (isEmpty()) {
                return "|";
            } else {
                Element top = top();
                pop();
                return convert() + " " + top + " |";
            }
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{darstellung des ADT-Stack in \textsl{Java}.}
  \label{fig:stack.java}
\end{figure} 

Wir diskutieren die Darstellung des ADT Stack in Java nun Zeile f\"ur Zeile.
\begin{enumerate}
\item In der ersten Zeile deklarieren wir die Klasse \texttt{Stack<Element>} als
      \emph{abstrakt}.  Das Schl\"usselwort \texttt{abstract} dr\"uckt dabei aus,
      das wir in dieser Klasse lediglich die Signaturen der Methoden angeben,
      die Implementierungen der Methoden werden in der abstrakten Klasse
      nicht angegeben.

      Der Name der Klasse ist \texttt{Stack<Element>}.  Die Typ-Parameter des ADT 
      sind hier in spitzen Klammern eingefasst.  Wenn es mehr als einen Typ-Parameter gibt,
      dann m\"ussen diese durch Kommata getrennt werden.
      
      Durch  ``\texttt{implements Cloneable}'' dr\"ucken wir aus, 
      dass Objekte der Klasse \texttt{Stack<Element>} geklont, d.h.~kopiert werden k\"onnen.
\item Zeile 3 enth\"alt die Typ-Spezifikationen der Method \texttt{push}.
      Oben hatten wir diese Typ-Spezifikation als \\[0.1cm]
      \hspace*{1.3cm} 
      $\mathtt{push}: \mathtt{Stack} \times \mathtt{Element} \rightarrow \mathtt{Stack}$
      \\[0.1cm]
      angegeben, in \textsl{Java} hat diese Typ-Spezifikation die Form \\[0.1cm]
      \hspace*{1.3cm} \texttt{void push(Element e);} \\[0.1cm]
      Hier fallen zwei Dinge auf:
      \begin{enumerate}
      \item In \textsl{Java} hat die Methode \texttt{push} ein Argument,
            w\"ahrend sie in der Definition des ADT zwei Argumente hat.

            In Java wird das erste Argument unterdr\"uckt, denn dieses Argument ist bei
            jeder Methode vorhanden und hat den Wert Stack.  Dieses Argument wird daher
            auch als \emph{implizites Argument} bezeichnet.  Diesem Umstand wird auch
            durch die Syntax eines Methoden-Aufrufs Rechnung getragen.  Wir schreiben \\[0.1cm]
            \hspace*{1.3cm} $s.\mathtt{push}(e)$ \\[0.1cm]
            an Stelle von $\mathtt{push}(s,e)$.
      \item Der R\"uckgabe-Typ von \texttt{push} ist als \texttt{void} deklariert und nicht
            als \texttt{Stack<Element>}.  Der Grund ist, dass ein Aufruf der Form \\[0.1cm]
            \hspace*{1.3cm} $s.\mathtt{push}(e)$
            \\[0.1cm]
            nicht einen neuen Stack berechnet, sondern den Stack $s$, der als als
            implizites erstes Argument der Methode verwendet wird, ver\"andert.
      \end{enumerate}
\item Die Zeilen 4 -- 6 enthalten die Typ-Spezifikationen der restlichen Methoden.
\item Die Zeilen 8 -- 10 enth\"alt die Definition einer Methode \texttt{clone()}.
      Diese Methode erm\"oglicht es, einen Klon (also eine Kopie) eines Objektes vom Typ
      \texttt{Stack} zu erzeugen.  Die Implementierung diskutieren wir sp\"ater.
\item In den Zeilen 12 -- 25 definieren wir die Methode \texttt{toString()}, mit der wir
      ein Objekt vom Daten-Typ \texttt{Stack} in einen String umwandeln k\"onnen.  Um die
      Implementierung dieser Methode zu verstehen, betrachten wir zun\"achst die Wirkung
      dieser Methode anhand des folgenden Beispiels: 
      \begin{verbatim}
      Stack<Element> stack = new Stack<Element>();
      stack.push(1);
      stack.push(2);
      stack.push(3);
      stack.toString();
      \end{verbatim}
      \vspace*{-0.5cm}

      Dann hat der Ausdruck \texttt{stack.toString()} den folgenden Wert:
      \begin{verbatim}
      -------------
      | 1 | 2 | 3 |
      -------------
      \end{verbatim}
      \vspace*{-0.5cm}
      Bei dieser Darstellung ist das oberste Element des Stacks also das Element, was am
      weitesten rechts liegt.

      Die Implementierung der Methode \texttt{toString} verl\"auft in drei Schritten.
      \begin{enumerate}
      \item Zun\"achst erzeugen wir mit Hilfe der Methode \texttt{clone()} eine Kopie des
            Stacks.  Das ist deswegen notwendig, weil wir mit der Methode \texttt{top()}
            ja immer nur das erste Element des Stacks anschauen k\"onnen.  Um das zweite
            Element zu bekommen, m\"ussen wir vorher das erste Element vom Stack herunter
            nehmen.  Das geht mit der Operation \texttt{pop()}.  Die Methode
            \texttt{toString()} soll aber den Stack selbst nicht ver\"andern.  Also kopieren
            wir vorher den Stack und \"andern dann die Kopie.

            Beim Ausf\"uhren der Methode \texttt{clone()} k\"onnte es Probleme geben, es
            k\"onnte eine \emph{Exception} (Ausnahme) ausgel\"ost werden.  Die Ausnahme
            fangen wir durch den \texttt{try}-\texttt{catch}-Block in den Zeilen 14 -- 18
            ab und geben in diesem Fall als Ergebnis eine Fehlermeldung zur\"uck.
      \item Die Hilfs-Methode \texttt{convert()} berechnet einen String der Form \\[0.1cm]
            \hspace*{1.3cm} \texttt{| 1 | 2 | 3 |}. \\[0.1cm]
            Hierzu wird mit der \texttt{if}-Abfrage in Zeile 28 eine Fallunterscheidung 
            durchgef\"uhrt: Falls der Stack leer ist, so ist das Ergebnis einfach nur der
            String ``\texttt{|}''.  Andernfalls fragen wir das oberste Element des Stacks
            mit dem Aufruf \texttt{top()} in 31 ab, entfernen es durch einen Aufruf von
            \texttt{pop()} vom Stack und rufen anschlie{\ss}end f\"ur den so verkleinerten Stack
            rekursiv die Methode \texttt{toString()} auf.  Das oberste Element des
            urspr\"unglichen Stacks wird dann hinten an das Ergebnis des rekursiven Aufrufs geh\"angt.
      \item Um zum Schluss noch die Linien dar\"uber und darunter zu zeichnen, erzeugen wir
            in der \texttt{for}-Schleife in Zeile 21 -- 23 eine Linie der erforderlichen
            L\"ange und verketten diese mit dem von \texttt{convert()} gelieferten String.
      \end{enumerate}
\end{enumerate}
Beachten Sie, dass wir f\"ur Stacks die Methode \texttt{toString()} implementieren konnten ohne etwas
dar\"uber zu wissen, wie die Stacks \"uberhaupt implementiert werden.  Dies ist der
wesentliche Vorteil des Konzeptes des ADT: Der Begriff des ADT abstrahiert von den Details der
Implementierung und bietet damit eine Schnittstelle zu Stacks, die einfacher zu bedienen
ist, als wenn wir uns mit allen Details auseinander setzen m\"ussten.  Ein weiterer
wesentlicher Vorteil ist die Austauschbarkeit konkreter Implementierungen des Stacks.  
Wir werden sp\"ater verschiedene konkrete
Implementierungen des ADT \texttt{Stack} entwickeln.  Da die Methode \texttt{toString} auf
der abstrakten Ebene entwickelt worden ist, ist sie von den Details einer solchen konkreten
Implementierung unabh\"angig!


\section{Implementierung eines Stacks mit Hilfe eines \emph{Arrays}}
Eine M\"oglichkeit, einen Stack zu implementieren, besteht darin,
die in einem Stack abgelegten Elemente in einem Feld abzuspeichern. 
Zus\"atzlich wird dann noch eine Zeiger ben\"otigt, der auf das oberste Element des Stacks 
zeigt. 
Abbildung \ref{fig:ArrayStack.java} auf Seite \pageref{fig:ArrayStack.java} zeigt eine solche
 Implementierung.

\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    public class ArrayStack<Element> extends Stack<Element>
    {
        Element[] mArray;  // abgespeicherte Elemente
        int       mIndex;  // Index der n\"achsten freien Stele in mArray
    
        public ArrayStack() {
            mArray = (Element[]) new Object[1];
            mIndex = 0;
        }        
        public void push(Element e) {
            int size = mArray.length;
            if (mIndex == size) {
                Element[] newArray = (Element[]) new Object[2 * size];
                for (int i = 0; i < size; ++i) {
                    newArray[i] = mArray[i];
                }
                mArray = newArray;
            }
            mArray[mIndex] = e;
            ++mIndex;
        }
        public void pop() {
            assert mIndex > 0 : "Stack underflow!";
            --mIndex;
        }    
        public Element top() {
            assert mIndex > 0 : "Stack is empty!";
            return (Element) mArray[mIndex - 1];
        }
        public boolean isEmpty() {
            return mIndex == 0;
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Array-basierte Implementierung eines Stacks.}
  \label{fig:ArrayStack.java}
\end{figure} 

\begin{enumerate}
\item Durch ``\texttt{extends Stack<Element>}'' deklarieren wir, dass die Klasse
      \texttt{ArrayStack<Element>} den abstrakten Daten-Typ \texttt{Stack<Element>}
      implementiert.
\item Die Daten-Struktur wird durch zwei Member-Variablen realisiert:
      \begin{enumerate}
      \item Die in Zeile 3 definierte Variable \texttt{mArray} bezeichnet das Feld,
            in dem die einzelnen Elemente, die auf den Stack geschoben werden,
            abgespeichert werden.
      \item Die in Zeile 4 definierte Variable \texttt{mIndex} gibt den Index in dem Feld
            \texttt{mArray} an, an dem das n\"achste Element abgelegt werden kann.
      \end{enumerate}
      Ich habe mir angew\"ohnt, jede Member-Variable mit dem Buchstaben \texttt{m}
      anfangen zu lassen.  Durch diese Konvention lassen sich Member-Variablen sp\"ater einfach von
      den lokalen Variablen einer Methode unterscheiden.
\item In dem Konstruktor legen wir in Zeile 7 das Feld \texttt{mArray} mit einer
      Gr\"o{\ss}e von 1 an und initialisieren die Variable \texttt{mIndex} mit 0, denn 
      0 ist der erste freie Index in diesem Feld.
\item Bei der Implementierung der Methode $\texttt{push}(e)$ \"uberpr\"ufen wir zun\"achst
      in Zeile 12, ob in dem Feld noch Platz vorhanden ist um
      ein weiteres Element abzuspeichern.  Falls dies nicht der Fall ist, 
      legen wir in Zeile 13  ein neues Feld an, das doppelt so gro{\ss} ist wie das alte Feld.
      Anschlie{\ss}end kopieren wir in der \texttt{for}-Schleife in den Zeilen 14 -- 16
      die Elemente aus dem alten Feld in das neue Feld und setzen dann die 
      Variable \texttt{mArray} auf das neue Feld.  Der \emph{Garbage-Collector} der 
      \textsl{Java Virtual Machine}  sorgt jetzt daf\"ur,
      dass der Speicher, der f\"ur das alte Feld allokiert worden war, 
      wieder verwendet werden kann.
      
      Anschlie{\ss}end speichern wir das Element $e$ an der durch \texttt{mIndex}
      angegebenen Stelle ab und erh\"ohen die Variable \texttt{mIndex}, so dass diese jetzt 
      wieder auf den n\"achsten freien Index in dem Array zeigt.
\item Die Funktion \texttt{pop()} k\"onnen wir dadurch implementieren, dass wir
      die Variable \texttt{mIndex} dekrementieren.  Vorher stellen wir durch den Aufruf 
      von \texttt{assert} in Zeile 23 sicher, dass der Stack nicht leer ist.
      Damit der \texttt{assert} zur Laufzeit auch tats\"achlich ausgef\"uhrt wird,
      m\"ussen wir das Programm hinter mit der Option ``\texttt{-ea}'' starten, wir werden das
      Programm also in der Form
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{java -ea StackTest}
      \\[0.2cm]
      ausf\"uhren.  Die Option ``\texttt{-ea}'' steht f\"ur 
      \emph{\underline{e}nable \underline{a}ssertions}.
\item Da der Stack-Pointer immer auf das n\"achste noch freie Feld zeigt,
      liefert der Ausdruck \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArray[mIndex-1]} \\[0.1cm]
      in Zeile 28 das Element, das als letztes im Stack abgespeichert wurde.
      Dieses Element wird von der Methode $\mathtt{top}()$ zur\"uck gegeben.
\item Die Prozedur \texttt{isEmpty()} \"uberpr\"uft in Zeile 31, ob der Index
      \texttt{mIndex} den Wert 0 hat, denn dann ist der Stack leer.
\end{enumerate}
Damit ist unsere Implementierung des Daten-Typs Stack vollst\"andig.  Es bleibt
ein Programm zu erstellen, mit dem wir diese Implementierung testen k\"onnen.
Abbildung \ref{fig:StackTest.java} auf Seite \pageref{fig:StackTest.java}
zeigt ein sehr einfaches Programm, in dem Stacks benutzt werden.  
Wir legen nacheinander die Zahlen $0, 1, \cdots, 32$
auf den Stack und geben jedes Mal den Stack aus.  Anschlie{\ss}end nehmen wir diese Zahlen der
Reihe nach vom Stack herunter.
Wir werden am Ende dieses Kapitels noch eine anspruchsvollere Anwendung von Stacks
pr\"asentieren, wenn wir Stacks zur Auswertung arithmetischer Ausdr\"ucke verwenden.


\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    import java.util.*;
    
    public class StackTest 
    {
        public static void main(String[] args) {
            Stack<Integer> stack = new ArrayStack<Integer>();
            for (int i = 0; i < 33; ++i) {
                stack.push(i);
                System.out.println(stack);
            }
            for (int i = 0; i < 33; ++i) {
                System.out.println(i + ":" + stack.top());
                stack.pop();
                System.out.println(stack);
            }
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Test der Stack-Implementierung.}
  \label{fig:StackTest.java}
\end{figure} 

\section{Eine Listen-basierte Implementierung von Stacks}
Als n\"achstes zeigen wir eine alternative Implementierung des abstrakten Daten-Typs
\textsl{Stack}, die auf einer verketteten Liste basiert.
Abbildung \ref{fig:ListStack.java} auf Seite \pageref{fig:ListStack.java} zeigt die
Implementierung.

\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm
                ]
    public class ListStack<Element> extends Stack<Element>
    {
        class DPP {
            Element mData;
            DPP     mNextPointer;

            DPP(Element data, DPP nextPointer) {
                mData        = data;
                mNextPointer = nextPointer;
            }            
            DPP recursiveCopy(DPP pointer) {
                if (pointer == null) {
                    return pointer;
                } else {
                    Element data        = pointer.mData;
                    DPP     nextPointer = recursiveCopy(pointer.mNextPointer);
                    return new DPP(data, nextPointer);
                }
            }
        }    

        DPP mPointer;
        
        public ListStack() {
            mPointer = null;
        }
        public void push(Element e) {
            mPointer = new DPP(e, mPointer);
        }        
        public void pop() {
            assert mPointer != null : "Stack underflow!";
            mPointer = mPointer.mNextPointer;
        }
        public Element top() {
            assert mPointer != null : "Stack is empty!";
            return mPointer.mData;
        }
        public boolean isEmpty() {
            return mPointer == null;
        }       
        public ListStack<Element> clone() throws CloneNotSupportedException {
            ListStack<Element> result = new ListStack<Element>();
            if (mPointer != null) {
                result.mPointer = mPointer.recursiveCopy(mPointer);
            }
            return result;
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Implementierung eines Stacks mit Hilfe einer Liste}
  \label{fig:ListStack.java}
\end{figure} 

Um eine verkette Liste darzustellen, brauchen wir eine Daten-Struktur die Paare darstellt.
Dabei ist die erste Komponente eines solchen Paares ein Element, das abgespeichert werden
soll, und die zweite Komponente ist eine Referenz auf das n\"achste Paar.
In der Klasse \texttt{ListStack<Element>} definieren wir daher zun\"achst 
eine \emph{innere} Klasse \texttt{DPP} (zu lesen als \emph{data pointer pair}),
die ein solches Paar darstellt.
\begin{enumerate}
\item Die Klasse enth\"alt ein Element, abgespeichert in der Variablen \texttt{mData}
      und eine Referenz auf das folgende Paar.  Die Referenz wird in der Variablen
      \texttt{mNextPointer} abgespeichert.
\item Der Konstruktor dieser Klasse bekommt als Argumente ein abzuspeicherndes Element
      und eine Referenz auf das n\"achste Paar.  Mit diesen Argumenten werden dann die
      Variablen \texttt{mData} und \texttt{mNextPointer} initialisiert.
\item Weierhin enth\"alt die Klasse noch die Methode \texttt{recursiveCopy()},
      die sp\"ater gebraucht wird um eine Liste zu klonen.  Diese Methode erzeugt ein neues
      Paar.  Die erste Komponente dieses Paars ist ist das Daten-Element, die zweite
      Komponente erhalten wir durch einen rekursiven Aufruf von
      $\texttt{recursiveCopy}()$.  
\item Die Klasse \texttt{ListStack<Element>} selber enth\"alt als einzige Member-Variable
      die Referenz \texttt{mPointer}.  Wenn der Stack leer ist, dann hat dieser Pointer
      den Wert \texttt{null}. Sonst verweist die Referenz auf ein Objekt vom Typ \texttt{DPP}.
      In diesem Objekt liegt dann das oberste Stack-Element.
\item Der Konstruktor erzeugt einen leeren Stack, indem die Variable \texttt{mPointer} mit
      dem Wert \texttt{null} initialisiert wird.
\item Um ein neues Element auf den Stack zu legen, erzeugen wir ein Paar, das als erste
      Komponente das neue Element und als zweite Komponente eine Referenz auf die Liste
      enth\"alt, die den bisherigen Stack repr\"asentierte.  Anschlie{\ss}end lassen wir
      \texttt{mPointer} auf dieses Paar zeigen.
\item Um die Funktion \texttt{pop()} zu implementieren, setzen wir \texttt{mPointer}
      auf die zweite Komponente des ersten Paares.
\item Die Funktion \texttt{top()} implementieren wir, indem wir die erste Komponente des
      Paares, auf das \texttt{mPointer} zeigt, zur\"uck geben.
\item Der Stack ist genau dann leer, wenn \texttt{mPointer} den Wert \texttt{null} hat.
\end{enumerate}
Um diese zweite Implementierung des ADT \textsl{Stack} zu testen, reicht es aus, die Zeile
6 in der Implementierung der Klasse \texttt{StackTest} in Abbildung \ref{fig:StackTest.java}
 zu \"andern.  Urspr\"unglich steht dort: \\[0.1cm]
\hspace*{1.3cm} \texttt{Stack<Integer> stack = new ArrayStack<Integer>();}
\\[0.2cm]
Wir ersetzen hier den Konstruktor-Aufruf \texttt{new ArrayStack<Integer>()} durch den
Aufruf des Konstruktors der  Klasse \texttt{ListStack} und erhalten dann:
\\[0.2cm]
\hspace*{1.3cm} \texttt{Stack<Integer> stack = new ListStack<Integer>();}
\\[0.2cm]
Vergleichen wir die beiden Implementierungen, so stellen wir fest, das die
Listen-basierte Implementierung mehr Speicherplatz als die Feld-basierte Implementierung
verwendet, weil wir jedes Element in einem Objekt der Klasse \texttt{DPP} verpacken
m\"ussen.  Auf der anderen Seite sind aber die Laufzeiten bei allen Methoden der
Listen-basierten Implementierung konstant, wohingegen die Operation $\mathtt{push}(x)$ bei der
Feld-basierten Implementierung unter Umst\"anden einen Aufwand erfordert, der proportional
zur Anzahl der im Stack gespeicherten Elemente ist.


\section{Auswertung arithmetischer Ausdr\"ucke}
Wir zeigen jetzt, wie Stacks zur Auswertung arithmetischer Ausdr\"ucke benutzt werden
k\"onnen.  Unter einem \emph{arithmetischen Ausdruck} verstehen wir in diesem Zusammenhang
einen String, der aus nat\"urlichen Zahlen und den Operator-Symbolen ``\texttt{+}'',
``\texttt{-}'', ``\texttt{*}'', ``\texttt{/}'', ``\texttt{\symbol{37}}'' und
``\texttt{\symbol{94}}'' aufgebaut ist.  Hierbei steht $x \;\mathtt{\symbol{37}}\; y$ f\"ur
den Rest, der bei der Division von $x$ durch $y$ \"ubrig bleibt und
$x\;\mathtt{\symbol{94}}\;y$ steht f\"ur die Potenz $x^y$.  Alternativ kann die Potenz $x^y$
auch als $x \;\mathtt{**}\; y$ geschrieben werden.
Au{\ss}erdem k\"onnen arithmetische
Ausdr\"ucke noch die beiden Klammer-Symbole ``\texttt{(}'' und ``\texttt{)}'' enthalten.  
Formal wird die Menge der arithmetische Ausdr\"ucke \textsl{ArithExpr} induktiv definiert:
\begin{enumerate}
\item Jede Zahl $n \in \mathbb{N}$ ist ein arithmetischer Ausdruck:
      \[ n \in \textsl{ArithExpr} \quad \mbox{f.a. $n \in \mathbb{N}$}. \]
\item Sind $s$ und $t$ arithmetische Ausdr\"ucke, so sind auch $s + t$, $s - t$, $s * t$, 
      $s / t$, $s \texttt{\symbol{37}} t$ und $s \texttt{\symbol{94}} t$
      arithmetische Ausdr\"ucke:
      \begin{enumerate}
      \item $s \in \textsl{ArithExpr} \wedge t \in \textsl{ArithExpr} \rightarrow s + t \in \textsl{ArithExpr}$,
      \item $s \in \textsl{ArithExpr} \wedge t \in \textsl{ArithExpr} \rightarrow s - t \in \textsl{ArithExpr}$,
      \item $s \in \textsl{ArithExpr} \wedge t \in \textsl{ArithExpr} \rightarrow s * t \in \textsl{ArithExpr}$,
      \item $s \in \textsl{ArithExpr} \wedge t \in \textsl{ArithExpr} \rightarrow s \mathop{/} t \in \textsl{ArithExpr}$,
      \item $s \in \textsl{ArithExpr} \wedge t \in \textsl{ArithExpr} \rightarrow s
        \mathop{\symbol{37}} t \in \textsl{ArithExpr}$,
      \item $s \in \textsl{ArithExpr} \wedge t \in \textsl{ArithExpr} \rightarrow s \mathop{\symbol{94}} t \in \textsl{ArithExpr}$,
      \item $s \in \textsl{ArithExpr} \rightarrow (\, s\,) \in \textsl{ArithExpr}$.
      \end{enumerate}
\end{enumerate}
Haben wir nun einen String gegeben, der einen arithmetischen Ausdruck repr\"asentiert, als
Beispiel betrachten wir den String
\[ 4 + 3 * 2 \mathop{\mathtt{\symbol{94}}} 2 \mathop{\mathtt{\symbol{94}}} 3, \]
so ist zun\"achst nicht klar, in welcher Reihenfolge die arithmetischen Operationen
ausgef\"uhrt werden sollen.   Um hier Klarheit zu schaffen m\"ussen wir festlegen, wie stark die
verschiedenen Operator-Symbol binden. Wir
vereinbaren, dass, wie in der Mathematik \"ublich, die Operatoren ``\texttt{*}'',
``\texttt{/}'' und ``\texttt{\symbol{37}}'' st\"arker binden als die
Operatoren ``\texttt{+}'' und ``\texttt{-}''.  Der Operator ``\texttt{\symbol{94}}''
bindet st\"arker als alle anderen Operatoren.
Au{\ss}erdem sind die Operatoren ``\texttt{+}'', ``\texttt{-}'', ``\texttt{*}'',
``\texttt{/}'', ``\texttt{\symbol{37}}'' alle \emph{links-assoziativ}:  Ein Ausdruck der
Form \\[0.1cm]
\hspace*{1.3cm} \texttt{1 - 2 - 3} \quad wird  wie der Ausdruck \quad \texttt{(1 - 2) - 3} \\[0.1cm]
gelesen.  Der Operator ``\texttt{\symbol{94}}'' ist hingegen \emph{rechts-assoziativ}: Ein
arithmetischer Ausdruck der Form \\[0.1cm]
\hspace*{1.3cm} \texttt{2 \symbol{94} 3 \symbol{94} 2} \quad wird  wie der Ausdruck \quad 
\texttt{2 \symbol{94} (3 \symbol{94} 2)} \\[0.1cm]
interpretiert.  Unser Ziel ist es, ein Programm zu erstellen, dass einen String, der
einen arithmetischen Ausdruck darstellt, auswertet.  Dieses Programm wird ganz wesentlich
mit dem abstrakten Daten-Typ \textsl{Stack} arbeiten.

\subsection{Ein einf\"uhrendes Beispiel}
Wir demonstrieren das Verfahren, mit dem wir arithmetische Ausdr\"ucke auswerten, zun\"achst
anhand eines Beispiels.
Wir betrachten den arithmetischen Ausdruck \\[0.1cm]
\hspace*{1.3cm} \texttt{1 + 2 * 3 - 4}. \\[0.1cm]
Wir verarbeiten einen solchen Ausdruck von links nach rechts, Token f\"ur Token.  Ein
\emph{Token} ist dabei entweder eine Zahl, eines der Operator-Symbole oder ein Klammer-Symbol.
Bei der Verarbeitung benutzen wir drei Stacks:
\begin{enumerate}
\item Der \emph{Token-Stack} enth\"alt die eingegebenen Token.  Dieser Stack enth\"alt also
      sowohl Zahlen als auch Operator-Symbole und Klammer-Symbole.
\item Der \emph{Argument-Stack} enth\"alt  Zahlen.
\item Der \emph{Operator-Stack} enth\"alt Operator-Symbole und 
      Klammer-Symbole der Form ``\texttt{(}''.
\end{enumerate}
Die Auswertung von \texttt{1 + 2 * 3 - 4} verl\"auft wie folgt:
\begin{enumerate}
\item Zu Beginn des Algorithmus enth\"alt der Token-Stack die eingegebenen Tokens und die
      anderen beiden Stacks sind leer: \\[0.1cm]
      \hspace*{1.3cm} 
      \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34}, 3,
        \symbol{34}*\symbol{34}, 2, \symbol{34}+\symbol{34}, 1 ]}, 
      \\[0.1cm]
      Beachten Sie, dass bei der horizontalen Darstellung des Stacks das Token, was als
      n\"achstes von der Methode $\textsl{top}()$ zur\"uck gegeben w\"urde, am rechten Ende der
      Liste liegt.  \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = []}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = []}. 
\item Wir nehmen die Zahl \texttt{1} vom Token-Stack und legen sie auf den Argument-Stack.  
      Die Werte der Stacks sind jetzt \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34}, 3, \symbol{34}*\symbol{34}, 2, \symbol{34}+\symbol{34} ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = []}. 
\item Wir nehmen den Operator \texttt{\symbol{34}+\symbol{34}} vom Token-Stack und legen ihn auf den Operator-Stack.
      Dann gilt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34}, 3, \symbol{34}*\symbol{34}, 2 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1 ]} \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}+\symbol{34} ]}. 
\item Wir nehmen die Zahl \texttt{2} vom Token-Stack und legen sie auf den Argument-Stack.
      Dann gilt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34}, 3, \symbol{34}*\symbol{34} ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1, 2 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}+\symbol{34} ]}. 
\item Wir nehmen den Operator \texttt{\symbol{34}*\symbol{34}} vom Token-Stack und vergleichen diesen Operator mit
      dem Operator \texttt{\symbol{34}+\symbol{34}}, der oben auf dem Operator-Stack liegt.
      Da der Operator \texttt{\symbol{34}*\symbol{34}} st\"arker bindet als der Operator \texttt{\symbol{34}+\symbol{34}}
      legen wir den Operator \texttt{\symbol{34}*\symbol{34}} ebenfalls auf den Operator-Stack, denn wir 
      m\"ussen diesen Operator auswerten, bevor wir den Operator \texttt{\symbol{34}+\symbol{34}} auswerten
      k\"onnen.
      Dann gilt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34}, 3 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1, 2 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}+\symbol{34}, \symbol{34}*\symbol{34}]}. 
\item Wir nehmen  die Zahl \texttt{3} vom Token-Stack und legen sie auf den Argument-Stack.
      Dann gilt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34} ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1, 2, 3 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}+\symbol{34}, \symbol{34}*\symbol{34} ]}. 
\item Wir nehmen den Operator \texttt{\symbol{34}-\symbol{34}} vom Token-Stack und vergleichen diesen Operator mit dem
      Operator \texttt{\symbol{34}*\symbol{34}}, der jetzt oben auf dem Stack liegt.  Da der Operator
      \texttt{\symbol{34}*\symbol{34}} st\"arker bindet als der Operator \texttt{\symbol{34}-\symbol{34}},
      werten wir jetzt den Operator \texttt{\symbol{34}*\symbol{34}} aus:  Dazu      
      nehmen wir die  beiden Argumente 3 und 2 vom Argument-Stack, nehmen den Operator
      \texttt{\symbol{34}*\symbol{34}} vom Operator-Stack und berechnen, wie vom Operator \texttt{\symbol{34}*\symbol{34}}
      gefordert, das Produkt der beiden Argumente. Dieses Produkt legen wir dann wieder auf
      den Argument-Stack.  Den Operator \texttt{\symbol{34}-\symbol{34}} legen wir wieder
      auf den Token-Stack zur\"uck, denn wir haben die entsprechende Operation ja noch nicht
      ausgef\"uhrt.   
      Dann haben unsere Stacks die folgende Gestalt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34} ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1, 6 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}+\symbol{34} ]}. 
\item Wir nehmen den Operator \texttt{\symbol{34}-\symbol{34}} vom Token-Stack und
      vergleichen diesen Operator mit dem Operator \texttt{\symbol{34}+\symbol{34}} der nun zuoberst auf dem Operator-Stack liegt.
      Da beide Operatoren gleich stark binden und verschieden sind, werten wir jetzt den Operator
      \texttt{\symbol{34}+\symbol{34}} aus:  Dazu nehmen wir die letzten beiden Argumente vom Argument-Stack, nehmen den Operator
      \texttt{\symbol{34}+\symbol{34}} vom Operator-Stack und berechnen die Summe der beiden Argumente.
      Diese Summe legen wir dann auf den Argument-Stack.  Au{\ss}erdem legen wir den Operator
      \texttt{\symbol{34}-\symbol{34}} wieder auf den Token-Stack zur\"uck.      
      Dann gilt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34} ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 7 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = []}. 
\item Wir nehmen  den Operator \texttt{\symbol{34}-\symbol{34}} vom Token-Stack und legen
      ihn auf den Operator-Stack.
      Dann gilt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 7 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}-\symbol{34} ]}. 
\item Wir nehmen die Zahl \texttt{4} vom Token-Stack und legen sie auf den Argument-Stack.
      Dann gilt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = []}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 7, 4 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}-\symbol{34} ]}. 
\item Der Input ist nun vollst\"andig gelesen.
      Wir nehmen daher nun den Operator \texttt{\symbol{34}-\symbol{34}} vom Operator-Stack, der damit leer wird.
      Anschlie{\ss}end nehmen wir die beiden Argumente vom Argument-Stack, bilden die
      Differenz und legen diese auf den Argument-Stack.
      Damit gilt: \\[0.1cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = []}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 3 ]}, \\[0.1cm]
      \hspace*{1.3cm} \texttt{mOperators = []}. \\[0.1cm]
      Das Ergebnis unserer Rechnung ist jetzt die noch auf dem Argument-Stack verbliebene
      Zahl 3.
\end{enumerate}

\subsection{Ein Algorithmus zur Auswertung arithmetischer Ausdr\"ucke \label{algo-arith}}
Nach dem einf\"uhrenden Beispiel entwickeln wir nun einen Algorithmus zur Auswertung
arithmetischer Ausdr\"ucke.  Zun\"achst legen wir fest, welche Daten-Stukturen wir benutzen
wollen.
\begin{enumerate}
\item \texttt{mTokens} ist ein Stack von Eingabe-Token.  Wenn es sich bei den Token um Operatoren oder
      Klammer-Symbole handelt, dann haben diese Token den Typ \texttt{String}.
      Andernfalls stellen die Token Zahlen dar und haben den Typ \texttt{BigInteger}.
      Die gemeinsame Oberklasse der Klassen \texttt{String} und \texttt{BigInteger}
      ist \texttt{Object}.  Daher deklarieren wir die Variable \texttt{mTokens}
      in der zu entwickelnden Klasse \texttt{Calculator} als: \\[0.1cm]
      \hspace*{1.3cm} \texttt{Stack<Object> mTokenStack;}
\item \texttt{mArguments} ist ein Stack von ganzen Zahlen.  Wir deklarieren diesen Stack
      als \\[0.1cm]
      \hspace*{1.3cm} \texttt{Stack<BigInteger> mArguments;}
\item \texttt{mOperators} ist ein Stack, der die Operatoren und eventuell \"offnende
      Klammern enth\"alt.  Da wir Operatoren
      durch Strings darstellen, deklarieren wir diesen Stack als \\[0.1cm]
      \hspace*{1.3cm} \texttt{Stack<String> mOperators;}
\end{enumerate}
Wenn wir das einf\"uhrende Beispiel betrachten und verallgemeinern, dann stellen wir fest,
dass wir Zahlen immer auf 
den Argument-Stack legen m\"ussen, w\"ahrend bei Behandlung der Operatoren
zwei F\"alle auftreten k\"onnen:
\begin{enumerate}
\item Der Operator wird auf den Operator-Stack gelegt, falls einer der folgenden F\"alle
      vorliegt:
      \begin{enumerate}
      \item Der Operator-Stack ist leer.
      \item Es liegt eine \"offnende Klammer \texttt{\symbol{34}(\symbol{34}}
            auf dem Operator-Stack.
      \item Der neue Operator bindet st\"arker als der Operator, der bereits oben auf dem Operator-Stack liegt.
      \item Der neue Operator ist identisch mit dem Operator, der bereits oben auf dem Operator-Stack
            liegt und dieser Operator-Stack ist au{\ss}erdem rechts-assoziativ.
        
      \end{enumerate}
\item Andernfalls wird der Operator wieder auf den Token-Stack zur\"uck gelegt.
      Dann wird der oberste Operator, der auf dem Operator-Stack liegt,
      vom Operator-Stack heruntergenommen, die Argumente  dieses Operators werden vom
      Argument-Stack genommen, der Operator wird ausgewertet
      und das Ergebnis wird auf den Argument-Stack gelegt.
\end{enumerate}

\begin{figure}[!b]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    import java.util.*; 
    import java.math.*;
    
    public class Calculator {
        Stack<BigInteger> mArguments;
        Stack<String>     mOperators;
        Stack<Object>     mTokenStack;
        
        static boolean evalBefore(String op1, String op2) {
            if (op1.equals("(")) {
                return false;
            }
            if (precedence(op1) > precedence(op2)) {
                return true;
            } else if (precedence(op1) == precedence(op2)) {
                return op1.equals(op2) ? isLeftAssociative(op1) : true;
            } else {
                return false;
            }
        }       
        static int precedence(String operator) {
            if (operator.equals("+") || operator.equals("-")) {
                return 1;
            } else if ( operator.equals("*") || operator.equals("/") || 
                        operator.equals("%")) {
                return 2;
            } else if (operator.equals("**") || operator.equals("^")) {
                return 3;
            } else {
                System.out.println("ERROR: *** unkown operator *** ");
            }
            System.exit(1);
            return 0;
        }    
        static boolean isLeftAssociative(String operator) {
            if (operator.equals("+") || operator.equals("-") ||
                operator.equals("*") || operator.equals("/") || 
                operator.equals("%")) {
                return true;
            } else if (operator.equals("**") || operator.equals("^")) {
                return false;
            } else {
                System.out.println("ERROR: *** unkown operator *** ");
            }
            System.exit(1);
            return false;
        }
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Die Klasse \texttt{Calculator}}
  \label{fig:calculator.java}
\end{figure} 

\noindent
Die Abbildungen \ref{fig:calculator.java}, \ref{fig:calculator2.java} und
\ref{fig:calculator3.java}
auf den Seiten \pageref{fig:calculator.java}, \pageref{fig:calculator2.java} und
\pageref{fig:calculator3.java} zeigen  eine Implementierung des Algorithmus
zur Auswertung arithmetischer Ausdr\"ucke in \textsl{Java}.
Wir diskutieren zun\"achst die Implementierung der statischen Methode \\[0.1cm]
\hspace*{1.3cm} \texttt{static boolean evalBefore(String op1, String op2)}.\\[0.1cm]
Diese Methode vergleicht die Operatoren \texttt{op1} und \texttt{op2} und entscheidet, ob
der Operator \texttt{op1} vor dem Operator \texttt{op2} ausgewertet werden muss.
Beim Aufruf dieser Methode
ist der Operator \texttt{op1} der Operator, der oben auf dem Operator-Stack liegt
und der Operator \texttt{op2} ist der Operator, der als letztes von dem Token-Stack
genommen worden ist.
Um entscheiden zu k\"onnen, ob der Operator \texttt{op1}
vor dem Operator \texttt{op2} auszuwerten ist, ordnen wir jedem
Operator eine \emph{Pr\"azedenz} zu.  Dies ist eine nat\"urliche Zahl, die angibt, wie stark
der Operator bindet. Tabelle \ref{tab:predence} zeigt die Pr\"azedenzen der von uns
verwendeten Operatoren.

\begin{table}[!h]
  \centering
\framebox{
  \begin{tabular}{|l|l|}
\hline
   Operator             & Pr\"azedenz  \\
\hline
\hline
   \texttt{\symbol{34}+\symbol{34}}, \texttt{\symbol{34}-\symbol{34}}  & 1   \\
\hline
   \texttt{\symbol{34}*\symbol{34}}, \texttt{/}, \texttt{\symbol{37}}  & 2   \\
\hline
   \texttt{\symbol{94}}, \texttt{**}  & 3   \\
\hline
  \end{tabular}}
  \caption{Pr\"azedenzen der Operatoren.}
  \label{tab:predence}
\end{table}

Ist die Pr\"azedenz des Operators \texttt{op1} h\"oher als die Pr\"azedenz des Operators \texttt{op2}, so
bindet \texttt{op1} st\"arker als \texttt{op2} und wird daher vor diesem ausgewertet.
Ist die Pr\"azedenz des Operators \texttt{op1} kleiner als die Pr\"azedenz des Operators \texttt{op2}, so
wird der Operator \texttt{op2} auf den Operator-Stack gelegt.
In dem Fall, dass die Pr\"azedenzen von \texttt{op1} und \texttt{op2} gleich sind, gibt es zwei F\"alle:
\begin{enumerate}
\item $\mathtt{op1} \not= \mathtt{op2}$.

      Betrachten wir eine Beispiel: Der arithmetischer Ausdruck \\[0.1cm]
      \hspace*{1.3cm} \texttt{2 + 3 - 4} \quad wird implizit links geklammert: \quad \texttt{(2 + 3) - 4}. \\[0.1cm]
      Also wird in diesem Fall zun\"achst \texttt{op1} ausgewertet.  
\item $\mathtt{op1} = \mathtt{op2}$.

      In diesem Fall  spielt die \emph{Assoziativit\"at} des Operators eine Rolle.
      Betrachten wir dazu zwei Beispiele: \\[0.1cm]
      \hspace*{1.3cm} \texttt{2 + 3 + 4} \quad wird interpretiert wie \quad \texttt{(2 + 3) + 4}, \\[0.1cm]
      denn wir sagen, dass der Operator ``\texttt{\symbol{34}+\symbol{34}}'' \emph{links-assoziativ}
      ist. Andererseits wird \\[0.1cm]
      \hspace*{1.3cm} \texttt{2 \symbol{94} 3 \symbol{94} 4}  \quad interpretiert als \quad \texttt{2 \symbol{94} (3 \symbol{94} 4)}, \\[0.1cm]
      denn wir sagen, dass der Operator ``\texttt{\symbol{94}}'' \emph{rechts-assoziativ} ist.

      Die Operatoren ``\texttt{\symbol{34}+\symbol{34}}'', ``\texttt{\symbol{34}-\symbol{34}}'', ``\texttt{\symbol{34}*\symbol{34}}'', ``\texttt{/}'' und 
      ``\texttt{\symbol{37}}'' sind alle links-assoziativ.  Hier wird als zun\"achst \texttt{op1} ausgewertet.
      Der Operator  ``\texttt{\symbol{94}}'' ist rechts-assoziativ.  Ist der oberste
      Operator auf dem Operator-Stack also ``\texttt{\symbol{94}}'' und wird dann nochmal
      der Operator ``\texttt{\symbol{94}}'' gelesen, so wird auch die neue Instanz dieses
      Operators auf den Stack gelegt.
\end{enumerate}
Mit diesem Vor\"uberlegung k\"onnen wir nun die Implementierung von
$\texttt{evalBefore}(\mathtt{op1},\mathtt{op2})$ in  Abbildung \ref{fig:calculator.java}  verstehen.
\begin{enumerate}
\item Falls \texttt{op1} der String \texttt{\symbol{34}(\symbol{34}} ist, so legen wir
      \texttt{op2} auf jeden Fall auf den Stack, denn \texttt{\symbol{34}(\symbol{34}}
      ist ja gar kein Operator, denn wir auswerten k\"onnten.
      Daher geben wir in Zeile 11 den Wert \texttt{false} zur\"uck.
\item Falls die Pr\"azedenz des Operators \texttt{op1} h\"oher ist als die Pr\"azedenz des
      Operators \texttt{op2}, so liefert $\texttt{evalBefore}(\mathtt{op1},\mathtt{op2})$
      in Zeile 14 den Wert \texttt{true}.
\item Falls die Pr\"azedenzen der Operatoren \texttt{op1} und \texttt{op2} identisch sind,
      so gibt es zwei F\"alle:
      \begin{enumerate}
      \item Sind die beiden Operatoren gleich, so ist das Ergebnis von
            \texttt{evalBefore(op1,op2)} genau dann \texttt{true}, wenn der Operator
            links-assoziativ ist.
      \item Falls die beiden Operatoren verschieden sind, hat das Ergebnis von
            \texttt{evalBefore(op1,op2)} den Wert \texttt{true}. 
      \end{enumerate}
      Diese beiden F\"alle werden in Zeile 16 behandelt.
\item Ist die Pr\"azedenz  des Operators \texttt{op1} kleiner als die Pr\"azedenz des
      Operators \texttt{op2}, so liefert $\texttt{evalBefore}(\mathtt{op1},\mathtt{op2})$
      in Zeile 18 den Wert \texttt{false}.
\end{enumerate}
Die Implementierung der Methode \texttt{predence()} in den Zeilen 21 -- 34 ergibt sich
unmittelbar aus der Tabelle \ref{tab:predence} auf Seite \pageref{tab:predence}.
Die Implementierung der Methode \texttt{isLeftAssociative()} in den Zeilen 35 -- 47
legt fest, dass die Operatoren \texttt{\symbol{34}+\symbol{34}},
\texttt{\symbol{34}-\symbol{34}}, \texttt{\symbol{34}*\symbol{34}},
\texttt{\symbol{34}/\symbol{34}} und 
\texttt{\symbol{34}\symbol{37}\symbol{34}} links-assoziativ sind, w\"ahrend die Operatoren
\texttt{\symbol{34}**\symbol{34}} und \texttt{\symbol{34}\symbol{94}\symbol{34}}
rechts-assoziativ sind.

Abbildung \ref{fig:calculator2.java} auf Seite \pageref{fig:calculator2.java} zeigt die
Implementierung der Methode \texttt{popAndEvaluate()}.
Aufgabe dieser Methode ist es, 
\begin{enumerate}
\item einen Operator vom Operator-Stack zu nehmen (Zeile 49 -- 50), 
\item dessen Argumente vom Argument-Stack zu holen, (Zeile 51 -- 54),
\item den Operator auszuwerten (Zeile 55 -- 69) und
\item das Ergebnis wieder auf dem Argument-Stack abzulegen (Zeile 70).
\end{enumerate}
\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = last,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
        void popAndEvaluate() {
            String operator = mOperators.top();
            mOperators.pop();
            BigInteger rhs = mArguments.top();
            mArguments.pop();
            BigInteger lhs = mArguments.top();
            mArguments.pop();
            BigInteger result = null;
            if (operator.equals("+")) {
                result = lhs.add(rhs);
            } else if (operator.equals("-")) {
                result = lhs.subtract(rhs);
            } else if (operator.equals("*")) {
                result = lhs.multiply(rhs);
            } else if (operator.equals("/")) {
                result = lhs.divide(rhs);
            } else if (operator.equals("**") || operator.equals("^")) {
                result = lhs.pow(rhs.intValue());       
            } else {
                System.out.println("ERROR: *** Unknown Operator ***");
                System.exit(1);
            }
            mArguments.push(result);
        }
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Die Klasse \texttt{Calculator}}
  \label{fig:calculator2.java}
\end{figure}

\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = last,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
        public Calculator() {
            MyScanner scanner = new MyScanner(System.in);
            mTokenStack = scanner.getTokenStack();
            mArguments  = new ArrayStack<BigInteger>();
            mOperators  = new ArrayStack<String>();
            while (!mTokenStack.isEmpty()) {
                if (mTokenStack.top() instanceof BigInteger) {
                    BigInteger number = (BigInteger) mTokenStack.top();
                    mTokenStack.pop();
                    mArguments.push(number);
                    continue;
                } 
                String nextOp = (String) mTokenStack.top();
                mTokenStack.pop();
                if (mOperators.isEmpty() || nextOp.equals("(")) {
                    mOperators.push(nextOp);
                    continue;
                }
                String stackOp = mOperators.top();
                if (stackOp.equals("(") && nextOp.equals(")") ) {
                    mOperators.pop();
                } else if (nextOp.equals(")")) {
                    popAndEvaluate();
                    mTokenStack.push(nextOp);
                } else if (evalBefore(stackOp, nextOp)) {
                    popAndEvaluate();
                    mTokenStack.push(nextOp);
                } else {
                    mOperators.push(nextOp);
                }
            }
            while (!mOperators.isEmpty()) { 
                popAndEvaluate(); 
            }
            BigInteger result = mArguments.top();
            System.out.println("The result is: " + result);
        }    
        public static void main(String[] args) {
            Calculator calc = new Calculator();
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Der Konstruktor der  Klasse \texttt{Calculator}.}
  \label{fig:calculator3.java}
\end{figure}
\noindent
Damit k\"onnen wir die in Abbildung \ref{fig:calculator3.java} gezeigte
Implementierung des Konstruktors der Klasse \texttt{Calculator}
diskutieren.  
\begin{enumerate}
\item Zun\"achst erzeugen wir in Zeile 73 ein Objekt der Klasse \texttt{MyScanner}.
      Dieser Scanner liest einen String ein und zerlegt diesen in Token.
      Wir erhalten in Zeile 74 einen Stack zur\"uck, der die Token in der Reihenfolge
      enth\"alt, in der sie eingelesen worden sind.  Geben wir beispielsweise den String \\[0.1cm]
      \hspace*{1.3cm} ``\texttt{1 + 2 * 3 - 4}'' \\[0.1cm]
      ein, so bekommt die Variable \texttt{mTokenStack} in Zeile 74 den Wert \\[0.1cm]
      \hspace*{1.3cm} [ 4, \symbol{34}-\symbol{34}, 3, \symbol{34}*\symbol{34}, 2, \symbol{34}+\symbol{34}, 1 ]
      \\[0.1cm]
      zugewiesen.
      Au{\ss}erdem initialisieren wir den Argument-Stack und den Operator-Stack in Zeile 75 und 76.      
\item In der n\"achsten Phase verarbeiten wir die einzelnen Tokens des Token-Stacks
      und verteilen
      diese Tokens auf Argument-Stack und Operator-Stack wie folgt:
      \begin{enumerate}
      \item Ist das gelesene Token eine Zahl, so legen wir diese auf den Argument-Stack
            und lesen das n\"achste Token.
        
            Im folgenden k\"onnen wir immer davon ausgehen, dass das gelesene Token ein
            Operator oder eine der beiden Klammern \texttt{\symbol{34}(\symbol{34}} oder
            \texttt{\symbol{34})\symbol{34}} ist. 
      \item Falls der Operator-Stack leer ist oder wenn das gelesene Token eine \"offnende Klammer
            \texttt{\symbol{34}(\symbol{34}} ist, legen wir den Operator oder die Klammer auf den Operator-Stack.
      \item Falls das  Token eine schlie{\ss}ende Klammer \texttt{\symbol{34})\symbol{34}} ist und wenn zus\"atzlich
            der Operator auf dem Operator-Stack eine \"offnende Klammer \texttt{\symbol{34}(\symbol{34}} ist, so 
            entfernen wir diese Klammer vom Operator-Stack.
      \item Falls jetzt das Token aus dem Token-Stacks eine schlie{\ss}ende Klammer
            \texttt{\symbol{34})\symbol{34}} 
            ist, so wissen wir, dass das Token auf dem Operator-Stack keine \"offnende
            Klammer sein kann, sondern ein echter Operator ist. 
            Diesen Operator evaluieren wir mit Hilfe der Methode \texttt{popAndEvaluate()}.
            Gleichzeitig schieben wir die schlie{\ss}ende Klammer, die wir vom Token-Stack genommen
            haben, wieder auf den Token-Stack zur\"uck, denn wir haben die dazu geh\"orige
            \"offnende Klammer ja noch nicht gefunden.

            Da wir danach wieder zum Beginn der Schleife zur\"uck kehren, werden wir in
            diesem Fall solange Operatoren vom Operator-Stack nehmen und auswerten bis wir
            im Operator-Stack auf eine \"offnende Klammer treffen.

            Im folgenden k\"onnen wir davon ausgehen, dass weder das oberste Zeichen auf dem
            Operator-Stack, noch das oberste Token auf dem Token-Stack eine Klammer ist.
      \item Falls der oberste Operator auf dem Operator-Stack eine h\"ohere Pr\"azedenz hat
            als der zuletzt gelesene
            Operator,  evaluieren wir den obersten Operator auf dem
            Operator-Stack mit Hilfe der Methode \texttt{popAndEvaluate()}.

            Gleichzeitig schieben wir den Operator, den wir vom Token-Stack genommen
            haben, wieder auf den Token-Stack zur\"uck, denn wir haben diesen Operator ja
            noch nicht weiter behandelt.
      \item Andernfalls legen wir den zuletzt gelesenen Operator auf den Operator-Stack.
      \end{enumerate}
      Diese Phase endet sobald der Token-Stack leer ist.
\item Zum Abschluss evaluieren wir alle noch auf dem Operator-Stack verbliebenen Operatoren
      mit Hilfe der Methode \texttt{popAndEvaluate()}.
      Wenn die Eingabe ein syntaktisch korrekter arithmetischer Ausdruck war,
      dann sollte am Ende der Rechnung noch genau eine Zahl auf  dem Argument-Stack
      liegen.  Diese Zahl ist dann unser Ergebnis, das wir ausgeben.
\end{enumerate}
Aus Gr\"unden der Vollst\"andigkeit zeigen wir in Abbildung \ref{fig:myscanner.java}
noch die Implementierung der Klasse \texttt{MyScanner}.  Wir benutzen die Klasse
\texttt{Scanner} aus dem Paket \texttt{java.io}.  Diese Klasse stellt unter anderem die
Methoden $\textsl{hasNext}()$ und $\textsl{hasNextBigInteger}()$ mit denen wir \"uberpr\"ufen
k\"onnen, ob die Eingabe noch ungelesene Zeichen enth\"alt und ob diese ungelesenen Zeichen
als ganze Zahl interpretiert werden k\"onnen.  Die Methode $\textsl{nextBigInteger}()$ gibt
dann diese Zahl zur\"uck.  Ein Aufruf von $\textsl{next}()$ liefert als Ergebnis den
n\"achsten String, der durch Leerzeichen, Tabulatoren oder Zeilenumbr\"uche begrenzt wird.
Um das Programm sp\"ater laufen lassen zu k\"onnen, m\"ussen also alle arithmetischen Operatoren
von Leerzeichen begrenzt werden.  Au{\ss}erdem ist beim Aufruf zu beachten, dass die Eingabe mit einem
\emph{End-Of-File}-Zeichen abgeschlossen werden muss.  Unter Unix ist dies Ctrl-D, unter
Windows wird hierf\"ur Ctrl-Z verwendet.

\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = last,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    import java.math.*;
    import java.io.*;
    import java.util.*;
    
    public class MyScanner {
        private ArrayStack<Object> mTokenStack;
    
        public MyScanner(InputStream stream) {
            ArrayList<Object> tokenList = new ArrayList<Object>();
            System.out.println( "Enter arithmetic expression. " + 
                                "Separate Operators with white space:");
            Scanner scanner = new Scanner(stream);
            while (scanner.hasNext()) {
                if (scanner.hasNextBigInteger()) {
                    tokenList.add(scanner.nextBigInteger());
                } else {
                    tokenList.add(scanner.next());
                }
            }
            mTokenStack = new ArrayStack<Object>();
            for (int i = tokenList.size() - 1; i >= 0; --i) {
                mTokenStack.push(tokenList.get(i));
            }
        }
        public ArrayStack<Object> getTokenStack() {
            return mTokenStack;
        }
    }               
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Die Klasse \texttt{MyScanner}}
  \label{fig:myscanner.java}
\end{figure}






\section{Nutzen abstrakter Daten-Typen}
Wir sind nun in der Lage den Nutzen, den die Verwendung abstrakter Daten-Typen hat, zu
erkennen. 
\begin{enumerate}
\item Abstrakte Daten-Typen machen die Implementierung eines Algorithmus von der
      Implementierung der Daten-Typen unabh\"angig.

      Bei der Implementierung des Algorithmus zur Auswertung arithmetischer Ausdr\"ucke
      mussten wir uns um die zugrunde liegenden Daten-Strukturen nicht weiter k\"ummern. 
      Es reichte aus, zwei Dinge zu wissen: 
      \begin{enumerate}
      \item Die Typ-Spezifikationen der verwendeten Funktionen.
      \item Die Axiome, die das Verhalten dieser Funktionen beschreiben.
      \end{enumerate}
      Der abstrakte Daten-Typ ist damit eine \emph{Schnittstelle} zwischen dem Algorithmus
      einerseits und der Daten-Struktur andererseits.  Dadurch ist es m\"oglich, Algorithmus
      und Daten-Struktur von unterschiedlichen Personen entwickeln zu lassen.
\item Abstrakte Daten-Typen sind \emph{wiederverwendbar}.

      Die Definition des abstrakten Daten-Typs \emph{Stack} ist sehr allgemein. Dadurch
      ist dieser Daten-Typ vielseitig einsetzbar:  Wir werden sp\"ater noch sehen, wie der
      ADT \emph{Stack} bei der Traversierung gerichteter Graphen eingesetzt werden kann.
\item Abstrakte Daten-Typen sind \emph{austauschbar}.

      Bei der Auswertung arithmetischer Ausdr\"ucke k\"onnen wir die
      Feld-basierte Implementierung des ADT \emph{Stack} mit minimalen Aufwand durch 
      eine Listen-basierte Implementierung ersetzen.  Dazu ist lediglich an drei Stellen
      der Aufruf eines Konstruktors abzu\"andern.
      Dadurch wird bei der
      Programm-Entwicklung das folgende Vorgehen m\"oglich: Wir entwerfen den ben\"otigten
      Algorithmus auf der Basis abstrakter Daten-Typen.  F\"ur diese geben wir zun\"achst sehr
      einfache Implementierungen an, deren Effizienz eventuell noch zu w\"unschen \"ubrig
      l\"asst.  In einem sp\"ateren Schritt wird evaluiert wo der Schuh am meisten dr\"uckt.
      Die ADTs, die bei dieser Evaluierung als performance-kritisch erkannt werden, k\"onnen
      anschlie{\ss}end mit dem Ziel der Effizienz-Steigerung reimplementiert werden.
\end{enumerate}
\pagebreak

%\section{Abstrakte Daten-Typen in \textsc{Setl2}}
%Das Konzept abstrakter Daten-Typen kann in jeder Programmier-Sprache verwendet werden. 
%Einige Programmier-Sprachen bieten zus\"atzliche Unterst\"utzung f\"ur dieses Konzept.
%Als objekt-orientierte Sprache unterst\"utzt  \textsc{Setl2} abstrakte Daten-Typen 
%durch die Definition von Klassen.
%Wir demonstrieren die Verwendung von Klassen in \textsc{Setl2} am  Beispiel des abstrakten
%Daten-Typs \textsl{Stack}.

%\subsection{Stacks in \textsc{Setl2}}
%\begin{figure}[!h]
%  \centering
%\begin{Verbatim}[ frame         = lines, 
%                  framesep      = 0.3cm, 
%                  labelposition = bottomline,
%                  numbers       = left,
%                  numbersep     = -0.2cm,
%                  commandchars  = \\\{\},
%                  xleftmargin   = 0.8cm,
%                  xrightmargin  = 0.8cm
%                ]
%    \underline{class} Stack;
%        p\underline{rocedure} \underline{create}(); 
%        p\underline{rocedure} push(x);
%        p\underline{rocedure} pop();
%        p\underline{rocedure} top();
%        p\underline{rocedure} isEmpty();
%    \underline{end} Stack;
            
%    \underline{class} \underline{bod}y Stack;
%        \underline{var} list;
        
%        p\underline{rocedure} \underline{create}();
%            list := [];
%        \underline{end} \underline{create};
        
%        p\underline{rocedure} push(x);
%            list := list + [x];
%        \underline{end} push;
    
%        p\underline{rocedure} pop();
%            list := list(1 .. #list-1);
%        \underline{end} pop;
    
%        p\underline{rocedure} top();
%            \underline{return} list(#list);
%        \underline{end} top;
    
%        p\underline{rocedure} isEmpty();
%            \underline{return} list = [];
%        \underline{end} isEmpty;
    
%        p\underline{rocedure} \underline{selfstr}();
%            \underline{return} \underline{str}(list);
%        \underline{end} selfstr;
%    \underline{end} \underline{Stack};
%\end{Verbatim}
%\vspace*{-0.3cm}
%  \caption{Implementierung eines Stacks in \textsc{Setl2}}
%  \label{fig:stack-setl}
%\end{figure} 

%\noindent
%Abbildung \ref{fig:stack-setl} auf Seite \pageref{fig:stack-setl} zeigt, wie der ADT
%\emph{Stack} sich in \textsc{Setl2} mit Hilfe einer Klasse implementieren l\"asst.  Alle
%Schl\"usselw\"orter der Sprache \textsc{Setl2} sind in der Abbildung unterstrichen worden.
%\begin{enumerate}
%\item In \textsc{Setl2} besteht ein ADT aus zwei Teilen, einer \emph{Klassen-Deklaration}
%      und einer \emph{Klassen-Definition}.
%\item Die Klassen-Deklaration hat die Form \\[0.1cm]
%      \hspace*{1.3cm} \texttt{class} \textsl{name}\texttt{;} \\[0.1cm]
%      \hspace*{2.3cm} \texttt{procedure} \texttt{create($\cdots$)}\texttt{;}  \\[0.1cm]
%      \hspace*{2.3cm} \emph{procedure-declaration}\texttt{;}  \\[0.1cm]
%      \hspace*{3.3cm} $\vdots$  \\[0.1cm]
%      \hspace*{2.3cm} \emph{procedure-declaration}\texttt{;} \\[0.1cm]
%      \hspace*{1.3cm} \texttt{end} \textsl{name}\texttt{;} \\[0.1cm]
%      Hierbei ist \textsl{name} der Name der Klasse.  Innerhalb der Klasse stehen
%      dann die Deklarationen der verschiedenen Prozeduren, die die Klasse nach au{\ss}en zur
%      Verf\"ugung stellt. Dabei hat die erste Prozedur-Deklaration eine besondere Form:
%      Die dort deklarierte Funktion hat immer den Namen \texttt{create()}.
%      Bei dieser Funktion handelt es sich um den \emph{Konstruktor} der Klasse.

%      Abbildung \ref{fig:stack-setl} zeigt in den Zeilen 1 -- 7 die Deklaration der Klasse
%      \texttt{Stack}.
%\item Die \emph{Klassen-Definition} hat die Form \\[0.1cm]
%      \hspace*{1.3cm} \texttt{class} \texttt{body} \textsl{name}\texttt{;} \\[0.1cm]
%      \hspace*{2.3cm} \emph{var-declaration}\texttt{;}  \\[0.1cm]
%      \hspace*{2.3cm} \emph{procedure-definition}\texttt{;}  \\[0.1cm]
%      \hspace*{3.3cm} $\vdots$  \\[0.1cm]
%      \hspace*{2.3cm} \emph{procedure-definition}\texttt{;} \\[0.1cm]
%      \hspace*{1.3cm} \texttt{end} \textsl{name}\texttt{;} \\[0.1cm]
%      Die einzelnen Komponenten haben die folgende Bedeutung:
%      \begin{enumerate}
%      \item \emph{var-declaration} listet die Variablen auf, die in einem Objekt
%            des ADT vorhanden sind.  Dadurch werden die internen Daten-Strukturen, durch
%            die Klasse realisiert wird, festgelegt.

%            In Abbildung \ref{fig:stack-setl} wird in Zeile 10 festgelegt, dass ein Stack
%            intern durch den Wert der Variablen \texttt{list} dargestellt wird.
%      \item Danach folgen die Definitionen der in der Klassen-Deklaration aufgelisteten 
%            Prozeduren.  Diese Prozedur-Definitionen unterscheiden sich nicht von den
%            Definitionen gew\"ohnlicher Prozeduren.

%      \item Zus\"atzlich k\"onnen weiter Prozeduren definiert werden, die in der
%            Klassen-Deklaration nicht genannt werden.  Solche Hilfs-Prozeduren sind dann
%            au{\ss}erhalb der Klasse nicht sichtbar und k\"onnen nur innerhalb der Klasse
%            verwendet werden, also nur innerhalb der Prozedur-Definitionen in der
%            Klassen-Definition. 
%      \item Die Prozedur \texttt{selfstr()} hat eine besondere Funktion:
%            Sie wandelt ein Objekt des ADT in einen String um.  Dadurch k\"onnen Objekte des
%            ADTs dann mit \texttt{print()} ausgedruckt werden.

%            In Abbildung \ref{fig:stack-setl} wird \texttt{selfstr()} mit Hilfe der
%            eingebauten Funktion \texttt{str()} realisiert: Diese Funktion kann alle
%            \texttt{Setl2}-Datenstrukturen in einen String umwandeln.
%      \end{enumerate}
%\end{enumerate}

%\begin{figure}[!ht]
%  \centering
%\begin{Verbatim}[ frame         = lines, 
%                  framesep      = 0.3cm, 
%                  labelposition = bottomline,
%                  numbers       = left,
%                  numbersep     = -0.2cm,
%                  xleftmargin   = 0.8cm,
%                  xrightmargin  = 0.8cm
%                ]
%    program main;
%        use Stack;
            
%        S := Stack();
%        print("S = ", S);
    
%        for i in {1..12} loop
%            S.push(i);
%            print("S = ", S);
%        end loop;    
    
%        for i in {1..12} loop
%            S.pop();
%            print("S = ", S);
%        end loop;    
%    end main;
%\end{Verbatim}
%\vspace*{-0.3cm}
%  \caption{Benutzung eines Stacks in \textsc{Setl2}}
%  \label{fig:stack-setl-use}
%\end{figure} 

%\noindent
%Werden die obige Klassen-Deklaration und die Klassen-Definition \"ubersetzt, so wird der ADT
%\texttt{Stack} mit seinen Funktionen in der \textsc{Setl2}-Bibliothek \texttt{setl2.lib}
%abgespeichert.  Um diesen Daten-Typ auch nutzen zu k\"onnen, muss ein Programm die Direktive \\[0.1cm]
%\hspace*{1.3cm} \texttt{use Stack;} \\[0.1cm]
%enthalten.  Abbildung \ref{fig:stack-setl-use} zeigt ein solches Programm mit der
%Direktive in Zeile 2.  Ein Stack kann nun mit Hilfe der Funktion \texttt{Stack()}  erzeugt
%werden.  Ein solcher Aufruf ruft intern den \emph{Konstruktor} der Klasse \texttt{Stack}
%auf.  Der Konstruktor war die Prozedur, die den Namen \texttt{create()} hat.  Aufgabe dieser
%Prozedur ist es, die internen Daten-Strukturen zu initialisieren, die den ADT repr\"asentieren.
%Im Falle des Stacks wurde einfach die Variable \texttt{list} auf die leere Liste \texttt{[]} gesetzt.

%Die Prozeduren, die der Daten-Typ Stack zur Verf\"ugung stellt, werden nun in der Form \\[0.1cm]
%\hspace*{1.3cm} $S$\texttt{.}\textsl{function}($\cdots$) \\[0.1cm]
%aufgerufen. Hierbei muss $S$ ein Objekt sein, dass mit dem Konstruktor des Daten-Typs
%Stack erzeugt wurde. Zeile 8 und Zeile 13 zeigen, wie die Prozeduren \texttt{push()} und
%\texttt{pop()} aufgerufen werden.

%\subsection{Realisierung von komplexen Zahlen in \textsc{Setl2}}
%Wir geben ein weiteres Beispiel f\"ur die Implementierung eines abstrakten Daten-Typs in
%\textsc{Setl2}, an dem wir das Konzept des \emph{berladens von Operatoren} demonstrieren
%k\"onnen:
%Die Sprache \textsc{Setl2} selbst kennt keine komplexen Zahlen.  Es ist aber einfach,
%komplexe Zahlen als ADT in \textsc{Setl2} zu realisieren.
%Abbildung \ref{fig:complex-setl} auf Seite \pageref{fig:complex-setl}
%zeigt eine Implementierung des ADT \texttt{Complex}.

%\begin{figure}[!h]
%  \centering
%\begin{Verbatim}[ frame         = lines, 
%                  framesep      = 0.3cm, 
%                  labelposition = bottomline,
%                  numbers       = left,
%                  numbersep     = -0.2cm,
%                  xleftmargin   = 0.8cm,
%                  xrightmargin  = 0.8cm,
%                  commandchars  = \\\{\}
%                ]
%    class Complex;
%        procedure create(x, y);
%    end Complex;

%    class body Complex;
%        var real, imag;
    
%        procedure create(x,y);
%            real := x;
%            imag := y;
%        end create;
    
%        procedure \underline{self} + z;
%            return Complex(real + z.real, imag + z.imag);
%        end;
    
%        procedure \underline{self} - z;
%            return Complex(real - z.real, imag - z.imag);
%        end;
    
%        procedure \underline{self} * z;
%            resultReal := real * z.real - imag * z.imag;
%            resultImag := real * z.imag + imag * z.real;
%            return Complex(resultReal, resultImag);
%        end;
    
%        procedure \underline{self} / z;
%            denominator := z.real ** 2 + z.imag ** 2;
%            resultReal := (real * z.real + imag * z.imag) / denominator;
%            resultImag := (imag * z.real - real * z.imag) / denominator;
%            return Complex(resultReal, resultImag);
%        end;
    
%        procedure \underline{selfstr}();
%            return \underline{str}(real) + " + " + \underline{str}(imag) + " * i";
%        end \underline{selfstr};
%    end Complex;
%\end{Verbatim}
%\vspace*{-0.3cm}
%  \caption{Komplexe Zahlen in  \textsc{Setl2}}
%  \label{fig:complex-setl}
%\end{figure} 

%\begin{enumerate}
%\item Die Klassen-Deklaration deklariert nur den Konstruktor.
%      Dieser bekommt als Argumente den Real- und Imagin\"ar-Teil der komplexen Zahl.
%\item Die Klassen-Definition legt in Zeile 6 zun\"achst fest, dass eine komplexe Zahl intern
%      durch die beiden Variablen \texttt{real} und \texttt{imag} repr\"asentiert wird,
%      die respektive den Real- und Imagin\"ar-Teil der Zahl enthalten.
%      Im Konstruktor werden diese beiden Variablen mit den Argumenten \texttt{x} und
%      \texttt{y} initialisiert.
%\item Zus\"atzlich enth\"alt die Klassen-Definition die Definition der Rechen-Operationen.
%      Diese Definitionen erfolgen mit einer speziellen Syntax: \\[0.1cm]
%      \hspace*{1.3cm} \texttt{procedure self} \textsl{op} \textsl{arg}\texttt{;} \\[0.1cm]
%      \hspace*{2.3cm} \textsl{body} \\[0.1cm]
%      \hspace*{1.3cm} \texttt{end;} \\[0.1cm]
%      Hier ist \textsl{op} der Name des zu definierenden Operators, also
%      z.B.~``\texttt{\symbol{34}+\symbol{34}}'' oder ``\texttt{\symbol{34}*\symbol{34}}'' und \textsl{arg} steht f\"ur das zweite
%      Argument dieses Operators.  \textsl{body} steht f\"ur den Rumpf der Prozedur.
%      Innerhalb des Rumpfes kann auf Real- und Imagin\"ar-Teil des Arguments \textsl{arg} 
%      mit Hilfe der Notation \textsl{arg}\texttt{.real} und \textsl{arg}\texttt{.imag}
%      zur\"uck gegriffen werden.
%\end{enumerate}
%Das Programm in Abbildung \ref{fig:complex-test.setl} zeigt, dass mit Hilfe der so
%eingef\"uhrten Klasse \texttt{Complex} in \textsc{Setl2} so mit komplexen Zahlen gerechnet werden kann, als ob
%diese ein Teil der Sprache \textsc{Setl2} w\"aren.  In \textsl{Java} ist soetwas nicht
%m\"oglich, dort k\"onnen Operatoren nicht \"uberladen werden.  Im Gegensatz dazu bietet die
%Sprache \texttt{C++} ebenfalls die M\"oglichkeit, Operatoren zu  
%\"uberladen.

%\begin{figure}[!h]
%  \centering
%\begin{Verbatim}[ frame         = lines, 
%                  framesep      = 0.3cm, 
%                  labelposition = bottomline,
%                  numbers       = left,
%                  numbersep     = -0.2cm,
%                  xleftmargin   = 0.8cm,
%                  xrightmargin  = 0.8cm
%                ]
%    program main;
%        use Complex;
    
%        z1 := Complex(1,  1);
%        z2 := Complex(1, -1);
%        print(z1, " + ", z2, " = ", z1 + z2);
%        print(z1, " - ", z2, " = ", z1 - z2);
%        print("(", z1, ") * (", z2, ") = ", z1 * z2);
%        print("(", z1, ") / (", z2, ") = ", z1 / z2);
%    end main;
%\end{Verbatim}
%\vspace*{-0.3cm}
%  \caption{Komplexe Zahlen in  \textsc{Setl2}}
%  \label{fig:complex-test.setl}
%\end{figure} 




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "algorithmen"
%%% End: 
