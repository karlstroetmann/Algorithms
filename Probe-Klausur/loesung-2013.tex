\documentclass{article}
\usepackage{german}
\usepackage[latin1]{inputenc}
\usepackage{fancyvrb}
\usepackage{a4wide}
\usepackage{amssymb}
\usepackage{epsfig}

\setlength{\textwidth}{15cm}

\newcommand{\bruch}[2]{\frac{\displaystyle \raisebox{1pt}[0pt][-0pt]{$\,#1\,$}}{\displaystyle \raisebox{0pt}[9pt]{$\,#2\,$}}}
\newcommand{\cq}{\symbol{34}}
\newcommand{\Ll}{{\cal L}}
\newcommand{\Rl}{{\cal R}}
\newcommand{\NS}{{\cal N\!S}}
\newcommand{\cl}[1]{{\cal #1}}
\renewcommand{\labelenumi}{(\alph{enumi})}
\renewcommand{\labelenumii}{\arabic{enumii}.}

\newcounter{aufgabe}

\newcommand{\exercise}{\vspace*{0.2cm}
\stepcounter{aufgabe}

\noindent
\textbf{Aufgabe \arabic{aufgabe}}: }

\newcommand{\solution}{\vspace*{0.2cm}

\noindent
\textbf{Lösung}: }

\begin{document}

\noindent
{\large Aufgaben mit Lösung zur Vorlesung  ``{\sl Algorithmen und Datenstrukturen}''}
\vspace{0.5cm}


\exercise
\begin{enumerate}
\item Lösen Sie die Rekurrenz-Gleichung \\[0.2cm]
      \hspace*{1.3cm} $a_{n+2} = a_n + 2$ \\[0.2cm]
      für die Anfangs-Bedingungen $a_0 = 2$ und $a_1 = 1$.
      \hspace*{\fill} (10 Punkte)
\item Lösen Sie die Rekurrenz-Gleichung \\[0.2cm]
      \hspace*{1.3cm} $a_{n+2} = 2 \cdot a_n - a_{n+1}$ \\[0.2cm]
      für die Anfangs-Bedingungen $a_0 = 0$ und $a_1 = 3$.
      \hspace*{\fill} (10 Punkte)
\end{enumerate}
\vspace{0.1cm}

\noindent
\textbf{Lösung}:
\begin{enumerate}
\item Es handelt sich um eine lineare, inhomogene Rekurrenz-Gleichung der Ordnung 2.
      Die zugehörige homogene Rekurrenz-Gleichung lautet
      \\[0.2cm]
      \hspace*{1.3cm}
      $a_{n+2} = a_n$
      \\[0.2cm]
      Zur Lösung machen wir den Ansatz $a_n = \lambda^n$.  Das führt auf die Gleichung
      \\[0.2cm]
      \hspace*{1.3cm}
      $\lambda^{n+2} = \lambda^n$.
      \\[0.2cm]
      Division durch $\lambda^n$ liefert (nach Umstellen) die Gleichung
      \\[0.2cm]
      \hspace*{1.3cm}
      $\lambda^2 - 1 = 0$.
      \\[0.2cm]
      Wegen $\lambda^2 - 1 = (\lambda - 1) \cdot (\lambda + 1)$ ist diese Gleichung äquivalent zu
      \\[0.2cm]
      \hspace*{1.3cm}
      $(\lambda - 1) \cdot (\lambda + 1) = 0$
      \\[0.2cm]
      und daraus folgt
      \\[0.2cm]
      \hspace*{1.3cm}
      $\lambda = 1 \vee \lambda = - 1$.
      \\[0.2cm]
      Um eine spezielle Lösung der inhomogenen Rekurrenz-Gleichung $a_{n+2} = a_n +2$ zu erhalten,
      versuchen wir zunächst den Ansatz $a_n = c$.  Dieser Ansatz führt auf die Gleichung
      \\[0.2cm]
      \hspace*{1.3cm}
      $c = c + 2$ \quad aus der sofort die offensichtlich falsche Gleichung \quad $0 = 2$
      \\[0.2cm]
      folgen würde.  Daher führt dieser Ansatz nicht zum Ziel und wir versuchen statt dessen den Ansatz
      \\[0.2cm]
      \hspace*{1.3cm}
      $a_n = c \cdot n$.
      \\[0.2cm]
      Damit erhalten wir
      \\[0.2cm]
      \hspace*{1.3cm}
      $c \cdot (n+2) = c \cdot n + 2$.
      \\[0.2cm]
      Die Lösung dieser Gleichung ist offenbar $c = 1$.
      Damit lautet  die allgemeine Lösung der Rekurrenz-Gleichung
      \\[0.2cm]
      \hspace*{1.3cm} $a_{n} = \alpha \cdot  1^n + \beta \cdot  (-1)^n + n$.
      \\[0.2cm]
      Die Koeffizienten $\alpha$ und $\beta$ bestimmen wir durch Einsetzen der
      Anfangsbedingungen. Das führt auf das Gleichungs-System 
      \\[0.2cm]
      \hspace*{1.3cm}
      $
      \left\{\begin{array}[c]{lcl}
        2 = \alpha + \beta \\
        1 = \alpha - \beta + 1 \\
      \end{array}\right\} \quad \Leftrightarrow\quad
      \left\{\begin{array}[c]{lcl}
        3 = 2\cdot \alpha + 1 \\
        1 = 2\cdot \beta  - 1 \\
      \end{array}\right\} \quad \Leftrightarrow\quad
      \left\{\begin{array}[c]{lcl}
        1 = \alpha  \\
        1 = \beta \\
      \end{array}\right\} 
      $
      \\[0.2cm]
      Damit haben wir folgende Lösung der gegebenen Rekurrenz-Gleichung gefunden: 
      \\[0.2cm]
      \hspace*{1.3cm} $a_n = (-1)^n + n + 1$.
\item Wir machen den Ansatz $a_n = \lambda^n$ und erhalten die Gleichung
      \\[0.2cm]
      \hspace*{1.3cm}
      $\lambda^{n+2} = 2 \cdot \lambda^n - \lambda^{n+1}$.
      \\[0.2cm]
      Division durch $\lambda^n$ und anschließendes Umstellen liefert
      \\[0.2cm]
      \hspace*{1.3cm}
      $\lambda^2 + \lambda - 2 = 0 \quad \Leftrightarrow\quad (\lambda - 1) \cdot (\lambda + 2) = 0$.
      \\[0.2cm]
      Damit gilt also
      \\[0.2cm]
      \hspace*{1.3cm}
      $\lambda = 1 \vee \lambda = - 2$
      \\[0.2cm]
      und die allgemeine Lösung lautet
      \\[0.2cm]
      \hspace*{1.3cm} $a_n = \alpha \cdot  1^n + \beta \cdot  (-2)^n$. \\[0.2cm]
      Wir bestimmen die Konstanten $\alpha$ und $\beta$ durch Einsetzen
      der Anfangsbedingungen: 
      \\[0.2cm]
      \hspace*{1.3cm}
       $
      \left\{\begin{array}[c]{lcl}
        0 = \alpha + \beta \\
        3 = \alpha - 2\cdot \beta \\
      \end{array}\right\} \quad \Leftrightarrow\quad
      \left\{\begin{array}[c]{lcl}
        \alpha = -\beta \\
        3 = -3\cdot \beta  \\
      \end{array}\right\} \quad \Leftrightarrow\quad
      \left\{\begin{array}[c]{lcl}
        -1 = \beta  \\
        1 = \alpha \\
      \end{array}\right\} 
      $
      \\[0.2cm]
      Damit erhalten wir die Lösung 
      \\[0.2cm]
      \hspace*{1.3cm} $a_n = 1 - (-2)^n$.
\end{enumerate}


\textbf{Hinweis}: Bei der Lösung der folgenden Aufgabe sind selbstverständlich
die in der Vorlesung vorgestellten Algorithmen zu verwenden.
\vspace{0.3cm}


\exercise
 Der AVL-Baum $t$ sei durch den folgenden Term gegeben,
wobei zur Vereinfachung auf die Angabe der Werte, die mit den Schlüsseln
assoziiert sind, verzichtet wurde.
\\[0.2cm]
\hspace*{1.3cm}
$t = \textsl{node}(17, 
           \textsl{node}(8, 
               \textsl{node}(2, \textsl{nil}, \textsl{nil}),
               \textsl{node}(10, \textsl{nil}, \textsl{nil})), 
           \textsl{node}(23,\textsl{nil},\textsl{nil}))$
%\epsfig{file=avl1,scale=0.5}
\begin{enumerate}
\item Fügen Sie  in diesem Baum den Schlüssel \texttt{13} ein und geben Sie den
      resultierenden Baum an.   \\[0.2cm]
      \hspace*{\fill} (6 Punkte)
\item Fügen Sie in dem Baum aus Teil (b) den Schlüssel \texttt{15} ein und geben Sie den
      resultierenden Baum an.
      \hspace*{\fill} (3 Punkte)
\item Entfernen Sie den Schlüssel 2 aus dem unter Teil (b) berechneten Baum und geben Sie
      den resultierenden Baum an.
      \hspace*{\fill} (4 Punkte)
\end{enumerate}

\solution
Die folgende Lösung ist sehr ausführlich.  In der Klausur reicht es aus, die entsprechenden Bäume anzugeben. 

Das Einfügen und Löschen in einem AVL-Baum unterscheidet sich von dem Einfügen und Löschen
in einem binären Baum durch die zusätzliche Anwendung der Funktion $\textsl{restore}()$.
Diese Funktion ist durch die folgenden Gleichungen spezifiziert:
\begin{enumerate}
\renewcommand{\labelenumi}{\arabic{enumi}.}
\item $\textsl{nil}.\textsl{restore}() = \textsl{nil}$,
\item $|l.\textsl{height}() - r.\textsl{height}()| \leq 1 \rightarrow \textsl{node}(k,v,l,r).\textsl{restore}() = \textsl{node}(k,v,l,r)$,
\item $\begin{array}[t]{cl}
              & l_1.\textsl{height}() = r_1.\textsl{height}() + 2    \\ 
       \wedge & l_1 = \textsl{node}(k_2,v_2,l_2,r_2)               \\
       \wedge & l_2.\textsl{height}() \geq r_2.\textsl{height}()     \\[0.2cm]
       \rightarrow & \textsl{node}(k_1,v_1,l_1,r_1).\textsl{restore}() = 
                     \textsl{node}\bigl(k_2,v_2,l_2,\textsl{node}(k_1,v_1,r_2,r_1)\bigr)
       \end{array}
      $
\item $\begin{array}[t]{cl}
               & l_1.\textsl{height}() = r_1.\textsl{height}() + 2    \\ 
        \wedge & l_1 = \textsl{node}(k_2,v_2,l_2,r_2)               \\
        \wedge & l_2.\textsl{height}() < r_2.\textsl{height}()     \\
        \wedge & r_2 = \textsl{node}(k_3,v_3,l_3,r_3)               \\
        \rightarrow & \textsl{node}(k_1,v_1,l_1,r_1).\textsl{restore}() = 
                      \textsl{node}\bigl(k_3,v_3,\textsl{node}(k_2,v_2,l_2,l_3),\textsl{node}(k_1,v_1,r_3,r_1) \bigr)
        \end{array}
       $
\item $\begin{array}[t]{cl}
              & r_1.\textsl{height}() = l_1.\textsl{height}() + 2    \\ 
       \wedge & r_1 = \textsl{node}(k_2,v_2,l_2,r_2)               \\
       \wedge & r_2.\textsl{height}() \geq l_2.\textsl{height}()     \\[0.2cm]
       \rightarrow & \textsl{node}(k_1,v_1,l_1,r_1).\textsl{restore}() = 
                     \textsl{node}\bigl(k_2,v_2,\textsl{node}(k_1,v_1,l_1,l_2),r_2\bigr)
       \end{array}
      $
\item $\begin{array}[t]{cl}
               & r_1.\textsl{height}() = l_1.\textsl{height}() + 2    \\ 
        \wedge & r_1 = \textsl{node}(k_2,v_2,l_2,r_2)               \\
        \wedge & r_2.\textsl{height}() < l_2.\textsl{height}()     \\
        \wedge & l_2 = \textsl{node}(k_3,v_3,l_3,r_3)               \\
        \rightarrow & \textsl{restore}\bigl(\textsl{node}(k_1,v_1,l_1,r_1)\bigr) = 
                      \textsl{node}\bigl(k_3,v_3,\textsl{node}(k_1,v_1,l_1,l_3),\textsl{node}(k_2,v_2,r_3,r_2) \bigr)
        \end{array}
       $
\end{enumerate}
Damit lautet die Lösung der Aufgaben:
\begin{enumerate}
\item Zunächst fügen wir den Schlüssel 13 ein, ohne auf die Balancierungs-Bedingung zu
      achten.  Wir erhalten den folgenden Term, wobei wir die Knoten noch mit ihren Höhen
      annotieren, um später die Balancierungs-Bedingung überprüfen zu können:
      \\[0.2cm]
      \hspace*{1.3cm}
      $t = n(17, n(8, n(2, *, *):1,
                    n(10, n(13, *, *):1, *):2):3,$ \\
      \hspace*{2.75cm} $
                n(23,*,*):1):4$
      \\[0.2cm]
      Damit sehen wir, dass die Balancierungs-Bedingung an der Wurzel dieses
      Knotens verletzt ist, denn der linke Teilbaum hat eine Tiefe von drei, während der
      rechte Teilbaum eine Tiefe von 1 hat.  Da der rechte Teilbaum des linken Teilbaums
      eine größere Tiefe hat als der linke Teilbaum, liegt die in Gleichung 4 beschriebene
      Situation vor.  Im einzelnen gilt:
      \begin{enumerate}
      \item $k_1 = 17$,
      \item $l_1 = n(8, n(2, *, *), n(10, n(13, *, *), *))$,
      \item $k_2 = 8$,
      \item $l_2 = n(2, *, *)$,
      \item $r_2 = n(10, n(13, *, *), *))$,
      \item $k_3 = 10$,
      \item $l_3 = n(13, *, *)$,
      \item $r_3 = *$,
      \item $r_1 = n(23,*,*))$.
      \end{enumerate}
      Damit erhalten wir den AVL-Baum
      \\[0.2cm]
      \hspace*{1.3cm}
      $t = n(10, 
                n(8, 
                    n(2, *, *),
                    *),$ \\
      \hspace*{2.75cm} $
                n(17,n(13, *, *),n(23, *,*)))$
\item Fügen wir den Schlüssel 15 ein, so erhalten wir 
      \\[0.2cm]
      \hspace*{1.3cm}
      $t = n(10, 
                n(8, 
                    n(2, *, *),
                    *),$ \\
      \hspace*{2.75cm} $
                n(17,
                     n(13, 
                            *, 
                            n(15, *,*)),
                     n(23, *,*)))$
      \\[0.2cm]
      Dies ist bereits ein AVL-Baum.
\item Nachdem wir den Schlüssel $2$ entfernt haben, hat der Baum die Form
      \\[0.2cm]
      \hspace*{1.3cm}
      $t = n(10, 
                n(8, 
                    *,
                    *),$ \\
      \hspace*{2.75cm} $
                n(17,
                     n(13, 
                            *, 
                            n(15, *,*)),
                     n(23, *,*)))$
      \\[0.2cm]
      Jetzt ist die Balancierungs-Bedingung an der Wurzel verletzt.
      Ein Aufruf von $\textsl{restore}()$ liefert
      \\[0.2cm]
      \hspace*{1.3cm}
      $t = n(13, n(10, n(8, *, *), *),$ \\
      \hspace*{2.75cm} $
                n(17,
                     n(15, *, *),
                     n(23, *,*)))$.
\end{enumerate}
\vspace{0.3cm}

\exercise
Betrachten Sie das folgende Programm:
\begin{verbatim}
    sum := procedure(n) {
        i := 0;
        s := 0;
        while (i <= n) {
            s := i + s;
            i := i + 1;
        }
        return s;
    }
\end{verbatim}
Die Funktion $\textsl{sum}$ soll die folgende Spezifikation erfüllen:
\\[0.2cm]
\hspace*{1.3cm} $\textsl{sum}(n) = \frac{1}{2} \cdot n \cdot (n + 1)$
\begin{enumerate}
\item Weisen Sie mit Hilfe des Hoare-Kalküls nach, dass das Programm korrekt ist.
\item Beweisen Sie mit Hilfe der Methode der symbolischen Programm-Ausführung nach,
      dass das Programm korrekt ist.
\end{enumerate}
\vspace{0.3cm}

\noindent
\textbf{Lösung}:
\begin{enumerate}
\item Zunächst der Hoare-Kalkül:
\begin{enumerate}
      \renewcommand{\labelenumii}{\arabic{enumii}.}
\item Wir zeigen als erstes, dass die \texttt{while}-Schleife der Invariante 
      \\[0.2cm]
      \hspace*{1.3cm}
      $I := \bigl(s = \frac{1}{2} \cdot i \cdot (i - 1)\bigr)$ 
      \\[0.2cm]
      genügt.  
      Für die erste Zuweisung in der Schleife gilt
      \\[0.2cm]
      \hspace*{1.3cm}
      $\{ I \wedge i \leq n \}$ \quad \texttt{s := s + i;} \quad $\{ (I \wedge i \leq n)[s \mapsto s - i] \}$
      \\[0.2cm]
      Wir formen den Ausdruck $\bigl(I \wedge i \leq n\bigr)[s \mapsto s - i]$ um:
      \begin{eqnarray*}
        \bigl(I \wedge i \leq n\bigr)[s \mapsto s - i] 
        & \leftrightarrow & \bigl(s = \frac{1}{2} \cdot i \cdot (i-1) \wedge i \leq n\bigr)[s \mapsto s - i] \\
        & \leftrightarrow & s - i = \frac{1}{2} \cdot i \cdot (i-1) \wedge i \leq n \\
        & \leftrightarrow & s = \frac{1}{2} \cdot i \cdot (i-1) + i \wedge i \leq n \\
        & \leftrightarrow & s = \frac{1}{2} \cdot i \cdot (i+1) \wedge i \leq n \\
      \end{eqnarray*}
      Als nächstes betrachten wir die Zuweisung ``\texttt{i := i + 1;}'':
      \\[0.2cm]
      \hspace*{1.3cm}
      $\{ s = \frac{1}{2} \cdot i \cdot (i+1) \wedge i \leq n \}$ \quad \texttt{i := i + 1;} \quad
      $\{ \bigl(s = \frac{1}{2} \cdot i \cdot (i+1)\wedge i \leq n\bigr)[i \mapsto i - 1] \}$ 
      \\[0.2cm]
      Es gilt 
      \begin{eqnarray*}        
      &                 & \bigl(s = \frac{1}{2} \cdot i \cdot (i+1)\wedge i \leq n\bigr)[i \mapsto i - 1] \\
      & \leftrightarrow & s = \frac{1}{2} \cdot (i-1) \cdot i \wedge i - 1 \leq n                         \\
      & \leftrightarrow & s = \frac{1}{2} \cdot i \cdot (i-1) \wedge i \leq n + 1                         
      \end{eqnarray*}
      und damit haben wir die Invariante nachgewiesen.
\item Die Invariante ist zu Beginn der Schleife erfüllt, denn zu Beginn der
      Schleife gilt $s = 0$ und $i = 0$ und offenbar gilt
      \\[0.2cm]
      \hspace*{1.3cm}
      $i = 0 \wedge s = 0 \rightarrow s = \frac{1}{2} \cdot (i-1) \cdot i$.
\item Nach Beendigung der Schleife gilt $i = n + 1$ und damit hat die Invariante die Form
      \\[0.2cm]
      \hspace*{1.3cm}
      $s = \frac{1}{2} \cdot \bigl((n+1)-1\bigl) \cdot (n+1) = \frac{1}{2} \cdot n \cdot (n+1)$.
      \\[0.2cm]
      Das ist aber genau die Behauptung.
\end{enumerate}
\item Jetzt die symbolische Programm-Ausführung:
      \begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 1.3cm,
                  xrightmargin  = 1.3cm,
                  codes         = {\catcode`_=8\catcode`$=3},
                  commandchars  = \\\{\},
                ]
    unsigned sum(unsigned n) \{
        unsigned i$_0$ = 0;
        unsigned s$_0$ = 0;
        while (i$_0$ <= n) \{
            s$_{k+1}$ = i$_k$ + s$_k$;
            i$_{k+1}$ = i$_k$ + 1;
        \}
        return s$_{K}$;
    \}
    \end{Verbatim} 
    %\$
      Wir zeigen nun, dass für $s_k$ die folgende Invariante gilt: 
      \\[0.2cm]
      \hspace*{1.3cm}
      $s_k = \frac{1}{2} \cdot (i_{k}-1) \cdot i_k$.
      \renewcommand{\labelenumii}{\arabic{enumii}.}
      \begin{enumerate}
      \item[I.A.:] $k=0$.

            Es gilt $s_0 = 0$ und $i_0 = 0$ und damit folgt sofort
            \\[0.2cm]
            \hspace*{1.3cm} $s_0 = \frac{1}{2} \cdot (i_{0}-1) \cdot i_0$.
      \item[I.S.:] $k \mapsto k+1$ 

            Offenbar gilt $i_{k+1} = i_k + 1$ und damit haben wir 
            \begin{eqnarray*}
              s_{k+1} & = & i_k + s_k \\
            & \stackrel{IV}{=} & i_k + \frac{1}{2} \cdot (i_{k}-1) \cdot i_k \\
            & = & \frac{1}{2} \cdot i_{k} \cdot (i_k + 1) \\
            & = & \frac{1}{2} \cdot (i_{k+1} - 1) \cdot i_{k+1}.
            \end{eqnarray*}
      \end{enumerate}
      Die Schleife wird offenbar $n+1$ mal durchlaufen und es gilt $i_K = n+1$.  Daraus folgt
      \\[0.2cm]
      \hspace*{1.3cm}
      $s_K = s_{n+1} = \frac{1}{2} \cdot (i_{n+1} - 1) \cdot i_{n+1} = \frac{1}{2} \cdot n \cdot (n+1)$.
\end{enumerate}
\vspace{0.3cm}
\pagebreak

\exercise
Im Skript
werden Gleichungen angegeben, die das Einfügen und Löschen in einem Heap beschreiben.
In diesem Zusammenhang sollen Sie in dieser Aufgabe  einige zusätzliche Methoden auf
binären Bäumen durch bedingte Gleichungen spezifizieren.
\begin{enumerate}
\item Spezifizieren Sie eine Methode \textsl{isHeap}, so
      dass für einen binären Baum $b \in \mathcal{B}$ der Ausdruck 
      $b.\mathtt{isHeap}()$ genau dann den Wert $\mathtt{true}$ hat, wenn $b$ die
      \emph{Heap-Bedingung} erfüllt.  \hspace*{\fill} (10 Punkte)
\item Implementieren Sie eine Methode \textsl{isBalanced}, so
      dass für einen binären Baum $b \in \mathcal{B}$ der Ausdruck 
      $b.\mathtt{isBalanced}()$ genau dann den Wert $\mathtt{true}$ hat, wenn $b$ die
      \emph{Balancierungs-Bedingung} für \emph{Heaps} erfüllt.  
      \hspace*{\fill} (5 Punkte)
\end{enumerate}
\vspace{0.3cm}

\noindent
\textbf{Lösung}:
\begin{enumerate}
\item Um die Methode \textsl{isHeap} leicht spezifizieren zu können, definieren wir zunächst
      eine Hilfsfunktion
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{isBigger} : \mathcal{B}  \times \textsl{Key}  \rightarrow \mathbb{B}$.
      \\[0.2cm]
      Für einen binären Baum $b$ und einen Schlüssel $k$ soll $b.\textsl{isBigger}(k)$ genau dann gelten,
      wenn alle Schlüssel, die in $b$ auftreten, größer-gleich $k$ sind.
      Diese Funktion wird durch Gleichungen spezifiziert:
      \begin{enumerate}
      \item $\textsl{nil}.\textsl{isBigger}(k) = \mathtt{true}$,
      \item $\textsl{node}(k_1,v_1,l,r).\textsl{isBigger}(k) = \bigl(k_1 \geq k_1 \wedge l.\textsl{isBigger}(k) \wedge r.\textsl{isBigger}(k)\bigr)$.
      \end{enumerate}
      Damit lässt sich jetzt die Methode $\textsl{isHeap}()$ durch Gleichungen spezifizieren:
      \begin{enumerate}
      \item $\textsl{nil}.\textsl{isHeap}() = \mathtt{true}$,
      \item $\textsl{node}(k,v,l,r).\textsl{isHeap}() = 
             \bigl(l.\textsl{isBigger}(k) \wedge r.\textsl{isBigger}(k) \wedge l.\textsl{isHeap}() \wedge r.\textsl{isHeap}()\bigr)$.
      \end{enumerate}
\item Wir definieren die Methode $\textsl{isBalanced}()$ induktiv.
      \begin{enumerate}
      \item $\textsl{nil}.\textsl{isBalanced}() = \mathtt{true}$,
      \item $\textsl{node}(k,v,l,r).\textsl{isBalanced}() =$ \\[0.1cm]
            \hspace*{\fill}
            $\bigl(|l.\textsl{count}() - r.\textsl{count}()| \leq 1 
             \wedge l.\textsl{isBalanced}()\wedge r.\textsl{isBalanced}()\bigr)$.
      \end{enumerate}
      Hier haben wir eine Hilfsfunktion $\textsl{count}$ benutzt, die wie folgt spezifiziert werden kann:
      \begin{enumerate}
      \item $\textsl{Nil}.\textsl{count}() = 0$
      \item $\textsl{Node}(p,v,l,r).\textsl{count}() = 1 + l.\textsl{count}() + r.\textsl{count}()$.
      \end{enumerate}
\end{enumerate}
\pagebreak

\exercise
Es sei 
$f(n) := \biggl(\sum\limits_{i=1}^n \frac{1}{i}\biggr) - \ln(n)$.
Zeigen Sie $f(n)\in \mathcal{O}\bigl(1\bigr)$. \hspace*{\fill} (12 Punkte)

\noindent
\textbf{Hinweis}:  Zeigen Sie 
\\[0.2cm]
\hspace*{1.3cm}
$0 \leq \biggl(\sum\limits_{i=1}^n \frac{1}{i}\biggr) - \ln(n) \leq 1$.

\solution
Für alle $x \in [i-1,i]$ gilt:
\begin{eqnarray*}
&             & x \leq i \\[0.3cm]
& \Rightarrow & \bruch{1}{x} \geq \bruch{1}{i} \\[0.2cm]
& \Rightarrow & \int_{i-1}^i \bruch{1}{x} dx \geq \int_{i-1}^i \bruch{1}{i} dx \\[0.2cm]
& \Rightarrow & \int_{i-1}^i \bruch{1}{x} dx \geq \bruch{1}{i} \\[0.2cm]
& \Rightarrow & \sum\limits_{i=2}^{n} \int_{i-1}^i \bruch{1}{x} dx \geq 
                \sum\limits_{i=2}^{n} \bruch{1}{i}                      \\[0.2cm]
& \Rightarrow & \int_{1}^n \bruch{1}{x} dx \geq \sum\limits_{i=2}^{n} \bruch{1}{i} \\[0.2cm]
& \Rightarrow & \ln(n) - \ln(1) \geq \sum\limits_{i=2}^{n} \bruch{1}{i} \\[0.2cm]
& \Rightarrow & \ln(n) + 1 \geq \sum\limits_{i=1}^{n} \bruch{1}{i} \\[0.2cm]
& \Rightarrow & \sum\limits_{i=1}^{n} \bruch{1}{i} - \ln(n) \leq 1 
\end{eqnarray*}
Analog gilt für alle $x \in [i-1,i]$:
\begin{eqnarray*}
&             & x \geq i - 1 \\[0.3cm]
& \Rightarrow & \bruch{1}{x} \leq \bruch{1}{i-1} \\[0.2cm]
& \Rightarrow & \int_{i-1}^i \bruch{1}{x} dx \leq \int_{i-1}^i \bruch{1}{i-1} dx \\[0.2cm]
& \Rightarrow & \int_{i-1}^i \bruch{1}{x} dx \leq \bruch{1}{i-1} \\[0.2cm]
& \Rightarrow & \sum\limits_{i=2}^{n} \int_{i-1}^i \bruch{1}{x} dx \leq 
                \sum\limits_{i=2}^{n} \bruch{1}{i-1}                      \\[0.2cm]
& \Rightarrow & \int_{1}^n \bruch{1}{x} dx \leq \sum\limits_{i=2}^{n} \bruch{1}{i-1} \\[0.2cm]
& \Rightarrow & \ln(n) - \ln(1) \leq \sum\limits_{i=2}^{n} \bruch{1}{i-1} \\[0.2cm]
& \Rightarrow & \ln(n) \leq \sum\limits_{i=1}^{n-1} \bruch{1}{i} \\[0.2cm]
& \Rightarrow & 0 \leq \sum\limits_{i=1}^{n-1} \bruch{1}{i} - \ln(n) \\[0.2cm]
& \Rightarrow & 0 \leq \sum\limits_{i=1}^{n} \bruch{1}{i} - \ln(n) 
\end{eqnarray*}
Insgesamt haben wir damit die Ungleichungs-Kette
\\[0.2cm]
\hspace*{1.3cm}
$0 \leq \biggl(\sum\limits_{i=1}^n \frac{1}{i}\biggr) - \ln(n) \leq 1$
\\[0.2cm]
bewiesen und daraus folgt die Behauptung unmittelbar.

\exercise
Es sei $\mathcal{B}$ die Menge der binären Bäume, die im Skript definiert wird.  
\begin{enumerate}
\item Spezifizieren Sie eine Methode \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{isOrdered}: \mathcal{B} \rightarrow \mathbb{B}$
      \\[0.2cm]
      durch bedingte Gleichungen.  Für einen binären Baum $b$ soll der Aufruf
      $b.\textsl{isOrdered}()$ genau dann \texttt{true} zurück liefern, wenn $b\in \mathcal{B}_<$
      gilt.
      \hspace*{\fill} (8 Punkte)

      \textbf{Hinweis}: Definieren Sie sich geeignete Hilfsfunktionen.
\item Es sei $\textsl{insert}()$ die in Abschnitt 7.2 des Skripts definierte Methode.
      Nehmen Sie an, dass Sie für alle $b\in \mathcal{B}_<$, alle Schlüssel $k$ und alle Werte
      $v$ die Gleichung
      \\[0.2cm]
      \hspace*{1.3cm} $b.\textsl{insert}(k,v).\textsl{isOrdered}() = \texttt{true}$
      \\[0.2cm]
      beweisen sollen.  Geben Sie an, welche Lemmata über die in Teil (a) definierten
      Hilfsfunktionen zu einem solchen Beweis benötigt werden.
      \hspace*{\fill} (4 Punkte)
\item Zeigen Sie nun für geordnete binäre Bäume die Gleichung
      \\[0.2cm]
      \hspace*{1.3cm} $b.\textsl{insert}(k,v).\textsl{isOrdered}() = \texttt{true}$ 
      \hspace*{\fill} (12 Punkte)
      \\[0.2cm]
      Sie dürfen dabei die Lemmata, die Sie in Teil (b) angeben sollen, benutzen.
\end{enumerate}

\solution
\begin{enumerate}
\item Wir definieren zunächst zwei Hilfsfunktionen
      \\[0.2cm]
      \hspace*{1.3cm} 
      $\textsl{smaller}: \mathcal{B} \times \textsl{Key} \rightarrow \mathbb{B}$ 
      \quad und \quad
      $\textsl{bigger}: \mathcal{B} \times \textsl{Key} \rightarrow \mathbb{B}$.
      \\[0.2cm]
      Der Aufruf $b.\textsl{smaller}(k)$ soll als Ergebnis genau dann \texttt{true}
      liefern, wenn alle in dem Baum $b$ auftretenden Schlüssel kleiner als der Schlüssel
      $k$ sind.  Analog liefert der Aufruf $b.\textsl{bigger}(k)$  als Ergebnis genau dann \texttt{true},
      wenn alle in dem Baum $b$ auftretenden Schlüssel größer als der Schlüssel
      $k$ sind.  Die beiden Funktionen werden durch die folgenden Gleichungen definiert:
      \begin{enumerate}
      \item $\textsl{nil}.\textsl{smaller}(k) = \mathtt{true}$.
      \item $\textsl{node}(k_1,v_1,l,r).\textsl{smaller}\bigl(k\bigr) = 
                \bigl(k_1 < k \wedge l.\textsl{smaller}(k) \wedge r.\textsl{smaller}(k)\bigr)$.
      \item $\textsl{nil}.\textsl{bigger}(k) = \mathtt{true}$.
      \item $\textsl{node}(k_1,v_1,l,r).\textsl{bigger}\bigl(k\bigr) = 
             \bigl(k_1 > k \wedge l.\textsl{bigger}(k) \wedge r.\textsl{bigger}(k)\bigr)$.
      \end{enumerate}
      Damit kann nun die Funktion $\textsl{isOrdered}()$ wie folgt spezifiziert werden:
      \begin{enumerate}
      \item $\textsl{nil}.\textsl{isOrdered}() = \mathtt{true}$.
      \item $\textsl{node}(k,v,l,r).\textsl{isOrdered}() = 
             \bigl(l.\textsl{smaller}(k) \wedge r.\textsl{bigger}(k) 
             \wedge l.\textsl{isOrdered}() \wedge r.\textsl{isOrdered}()\bigr)
            $.
      \end{enumerate}
\item Wir benötigen die folgenden beiden Eigenschaften der Funktionen $\textsl{smaller}$ und
      $\textsl{bigger}$:
      \begin{enumerate}
      \item $k < k_1 \wedge l.\textsl{smaller}(k_1) \rightarrow l.\textsl{insert}(k,v).\textsl{smaller}(k_1)$,
      \item $k > k_1 \wedge r.\textsl{bigger}(k_1)  \rightarrow r.\textsl{insert}(k,v).\textsl{bigger}(k_1)$.
      \end{enumerate}
\item Wir führen den Beweis durch Wert-Verlaufsinduktion.
      \begin{enumerate}
      \item Fall:
            $\textsl{nil}.\textsl{insert}(k,v).\textsl{isOrdered}() =
             \textsl{node}(k,v,\textsl{nil},\textsl{nil}).\textsl{isOrdered}() = \texttt{true}$.
      \item Fall: Es gelte $k < k_1$.  Dann können wir voraussetzen, dass
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{node}(k_1,v_1,l,r).\textsl{isOrdered}()$
            \\[0.2cm]
            gilt und müssen zeigen, dass daraus
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{node}(k_1,v_1,l,r).\textsl{insert}(k,v).\textsl{isOrdered}()$
            \\[0.2cm]
            folgt.  Dies sehen wir wie folgt:
            \\[0.2cm]
            \hspace*{1.3cm}
            $\begin{array}[t]{cl}
                & \textsl{node}(k_1,v_1,l,r).\textsl{insert}(k,v).\textsl{isOrdered}() \\[0.2cm]
              = & \textsl{node}(k_1,v_1,l.\textsl{insert}(k,v),r).\textsl{isOrdered}()     \\[0.2cm]
              = & \bigl(l.\textsl{insert}(k,v).\textsl{smaller}(k_1) \wedge
                        r.\textsl{bigger}(k_1) \;\wedge            \\[0.1cm]
                & \;\;  l.\textsl{insert}(k,v).\textsl{isOrdered}()    \wedge
                        r.\textsl{isOrdered}()\bigr)\\[0.2cm]
            \end{array}
            $
            \\[0.2cm]
            Wir zeigen nun, dass alle vier Bestandteile dieser Konjunktion den Wert
            \texttt{true} haben.
            \begin{enumerate}
            \item Aus der Voraussetzung, dass
                  $\textsl{node}(k_1,v_1,l,r).\textsl{isOrdered}()$ gilt, folgt zunächst
                  \\[0.2cm]
                  \hspace*{1.3cm}
                  $l.\textsl{smaller}(k_1)$.
                  \\[0.2cm]
                  Nach Teil $(b)$ folgt wegen $k < k_1$ dann auch
                  \\[0.2cm]
                  \hspace*{1.3cm}
                  $l.\textsl{insert}(k,v).\textsl{smaller}(k_1)$.
            \item Aus der Voraussetzung
                  $\textsl{node}(k_1,v_1,l,r).\textsl{isOrdered}()$ folgt unmittelbar
                  \\[0.2cm]
                  \hspace*{1.3cm}
                  $r.\textsl{bigger}(k_1)$.
            \item Aus der Voraussetzung
                  $\textsl{node}(k_1,v_1,l,r).\textsl{isOrdered}()$ folgt zunächst
                  \\[0.2cm]
                  \hspace*{1.3cm}
                  $l.\textsl{isOrdered}()$.
                  \\[0.2cm]
                  Nach Induktions-Voraussetzung haben wir dann auch
                  \\[0.2cm]
                  \hspace*{1.3cm}
                  $l.\textsl{insert}(k,v).\textsl{isOrdered}()$.
            \item Aus der Voraussetzung
                  $\textsl{node}(k_1,v_1,l,r).\textsl{isOrdered}()$ folgt sofort
                  \\[0.2cm]
                  \hspace*{1.3cm}
                  $r.\textsl{isOrdered}()$.
            \end{enumerate}
            Damit haben wir insgesamt gezeigt, dass
            $\textsl{node}(k_1,v_1,l.\textsl{insert}(k,v),r).\textsl{isOrdered}()$ gilt.
      \item Fall: Es gelte $k > k_1$.  Dann können wir voraussetzen, dass
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{node}(k_1,v_1,l,r).\textsl{isOrdered}()$
            \\[0.2cm]
            gilt und müssen zeigen, dass daraus
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{node}(k_1,v_1,l,r).\textsl{insert}(k,v).\textsl{isOrdered}()$
            \\[0.2cm]
            folgt, was darauf herausläuft zu zeigen, dass
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{node}\bigl(k_1,v_1,l,r.\textsl{insert}(k,v)\bigr).\textsl{isOrdered}()$
            \\[0.2cm]
            gilt.  Da die Rechnung analog zum zweiten Fall ist, führen wir sie nicht weiter aus.
      \end{enumerate}
\end{enumerate}
\pagebreak

\exercise
Es gelte $\Sigma = \{ \mathtt{a},\,\mathtt{b},\,\mathtt{c},\,\mathtt{d},\,\mathtt{e},\,\mathtt{f} \}$.
Die Häufigkeit, mit der diese Buchstaben in dem zu kodierenden String $s$ auftreten, sei durch die
folgende Tabelle gegeben:

\begin{center}
\begin{tabular}[t]{|l|r|r|r|r|r|r|}
\hline
Buchstabe  & \texttt{a} & \texttt{b} & \texttt{c} & \texttt{d} & \texttt{e} & \texttt{f} \\
\hline
Häufigkeit &          8 &          9 &         10 &         11 &         12 &         13 \\
\hline
\end{tabular}
\end{center}
\begin{enumerate}
\item Berechnen sie einen optimalen Kodierungs-Baum für die angegebenen Häufigkeiten.
\item Geben die Kodierung der einzelnen Buchstaben an, die sich aus diesem Baum ergibt.
\end{enumerate}

\noindent
\textbf{Lösung}:
\begin{enumerate}
\item Wir wenden den Huffman-Algorithmus an und erhalten die folgenden Mengen.  Zur Abkürzung
      schreiben wir dort $l(a,f)$ statt $\textsl{leaf}(a,f)$ und $n(l,r)$ statt $\textsl{node}(l,r)$.
      \begin{enumerate}
      \item $\{ l(a,8), l(b,9), l(c,10), l(d,11), l(e,12), l(f,13) \}$
      \item $\{ l(c,10), l(d,11), l(e,12), l(f,13), n(l(a,8), l(b,9)):17 \}$
      \item $\{ l(e,12), l(f,13), n(l(a,8), l(b,9)):17, n(l(c,10), l(d,11)):21 \}$
      \item $\{ n(l(a,8), l(b,9)):17, n(l(c,10), l(d,11)):21, n(l(e,12), l(f,13)):25 \}$
      \item $\{ n(l(e,12), l(f,13)):25, n(n(l(a,8), l(b,9)):17, n(l(c,10), l(d,11)) :21):38 \}$
      \item $\{ n(n(l(e,12), l(f,13)):25, n(n(l(a,8), l(b,9)):17, n(l(c,10), l(d,11)):21):38):63 \}$
      \end{enumerate}
      Damit ist 
      \\[0.2cm]
      \hspace*{1.3cm} $n(n(l(e,12), l(f,13)), n(n(l(a,8), l(b,9)), n(l(c,10), l(d,11))))$
      \\[0.2cm]
      der gesuchte Kodierungsbaum.
\item Also ergibt sich die folgende Kodierung für die einzelnen Buchstaben:
      \begin{verbatim}
      e = 00, f = 01, a = 100, b = 101, c = 110, d = 111.
      \end{verbatim}
\end{enumerate}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
